### 概述

因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。常见的八大排序算法，他们之间关系如下：

![](/gallery/sort-algorithms/1156494-ab4cecff133d87b3.png)

- 直接插入排序
- 希尔排序
- 简单选择排序
- 堆排序
- 冒泡排序
- 快速排序
- 归并排序
- 基数排序

![](/gallery/sort-algorithms/2016-07-15_常用排序算法.png)


### 一、直接插入排序（Insertion Sort）

#### 1、基本思想

将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。

![](/gallery/Insertion-sort-example-300px.gif)

#### 2、算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

![](/gallery/insert-sort.gif)

如果*比较操作*的代价比*交换操作*大的话，可以采用[二分查找法](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95)来减少*比较操作*的数目。该算法可以认为是**插入排序**的一个变种，称为[二分查找插入排序](https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&action=edit&redlink=1)。

#### 3、代码实现

```java
	/**
     * 插入排序
     *
     * 1. 从第一个元素开始，该元素可以认为已经被排序
     * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
     * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
     * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
     * 5. 将新元素插入到该位置后
     * 6. 重复步骤2~5
     * @param arr  待排序数组
     */
    public static void insertionSort(int[] arr){
        for( int i=0; i<arr.length-1; i++ ) {
            for( int j=i+1; j>0; j-- ) {
                if( arr[j-1] <= arr[j] )
                    break;
                int temp = arr[j];		//交换操作
                arr[j] = arr[j-1];
                arr[j-1] = temp;
                System.out.println("Sorting:  " + Arrays.toString(arr));
            }
        }
    }
```

执行结果如下：

```java
Before: [5, 3, 9, 1, 6, 4, 10, 2, 8, 7]
Sorting:  [3, 5, 9, 1, 6, 4, 10, 2, 8, 7]
Sorting:  [3, 5, 1, 9, 6, 4, 10, 2, 8, 7]
Sorting:  [3, 1, 5, 9, 6, 4, 10, 2, 8, 7]
Sorting:  [1, 3, 5, 9, 6, 4, 10, 2, 8, 7]
Sorting:  [1, 3, 5, 6, 9, 4, 10, 2, 8, 7]
Sorting:  [1, 3, 5, 6, 4, 9, 10, 2, 8, 7]
Sorting:  [1, 3, 5, 4, 6, 9, 10, 2, 8, 7]
Sorting:  [1, 3, 4, 5, 6, 9, 10, 2, 8, 7]
Sorting:  [1, 3, 4, 5, 6, 9, 2, 10, 8, 7]
Sorting:  [1, 3, 4, 5, 6, 2, 9, 10, 8, 7]
Sorting:  [1, 3, 4, 5, 2, 6, 9, 10, 8, 7]
Sorting:  [1, 3, 4, 2, 5, 6, 9, 10, 8, 7]
Sorting:  [1, 3, 2, 4, 5, 6, 9, 10, 8, 7]
Sorting:  [1, 2, 3, 4, 5, 6, 9, 10, 8, 7]
Sorting:  [1, 2, 3, 4, 5, 6, 9, 8, 10, 7]
Sorting:  [1, 2, 3, 4, 5, 6, 8, 9, 10, 7]
Sorting:  [1, 2, 3, 4, 5, 6, 8, 9, 7, 10]
Sorting:  [1, 2, 3, 4, 5, 6, 8, 7, 9, 10]
Sorting:  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
After:  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```



###  二、希尔排序（Shell Sort）

希尔排序，也称**递减增量排序算法**，是插入排序的一种高速而稳定的改进版本。

> 1959年Shell发明；
> 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。

#### 1、基本思想

![](/gallery/shell-sort.jpg)

将待排序数组按照步长gap进行分组（一般的初次取数组长度的一半为增量），然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。

#### 2、算法描述

1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；（**一般初次取数组半长，之后每次再减半，直到增量为1**）
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

#### 3、代码实现










































### 参考资料

- 数据结构可视化：[visualgo](https://visualgo.net/zh)
- [Sorting - 卡内基梅隆大学课件](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html)
- [数据结构常见的八大排序算法（详细整理）](http://www.jianshu.com/p/7d037c332a9d)
- [必须知道的八大种排序算法【java实现】](http://www.jianshu.com/p/8c915179fd02)
- [十大经典排序算法](http://web.jobbole.com/87968/)
- [视觉直观感受 7 种常用的排序算法](http://blog.jobbole.com/11745/)