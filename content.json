{"meta":{"title":"iTime","subtitle":null,"description":"Someone knock at the door.","author":"Mr.Seven","url":"http://github.com"},"pages":[{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2016-11-04T06:07:33.469Z","comments":true,"path":"about/index.html","permalink":"http://github.com/about/index.html","excerpt":"","text":"That maybe happiness is something that we can only pursue. And maybe we can actually never have it….no matter what. Be stupid is a part in my life. This part of my life is called “happiness“. Profile Bello, guys. I am ： Wenlong Xue I’m an Android Developer + prefer Python &amp; Golang + interest in AI(Artificial Intelligence) + Google radicals（Golang+Docker+Kubernetes+AnglarJS) ContactYou can reach me by Email: xuewenlong_2008@sina.com Github: iTimeTraveler Google+: iTimeTraveler Weibo: iTimee Funny Links stormzhang ibireme Red Blob Games Joe’s Blog EVAN YOU Just For Fun pinggod BNGH fatesinger themeakina KIERAN’S BLOG tagDiv &amp; NEWSMAG 成浩的博客 宅談"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2016-10-20T07:28:45.428Z","comments":false,"path":"categories/index.html","permalink":"http://github.com/categories/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2016-08-26T08:58:29.695Z","comments":true,"path":"archives/index.html","permalink":"http://github.com/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2016-10-20T07:26:52.010Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Neo4j进行全栈Web开发","slug":"使用Neo4j进行全栈Web开发","date":"2016-11-10T03:08:00.000Z","updated":"2016-11-10T03:17:06.105Z","comments":true,"path":"2016/11/10/使用Neo4j进行全栈Web开发/","link":"","permalink":"http://github.com/2016/11/10/使用Neo4j进行全栈Web开发/","excerpt":"在开发一个全栈web应用时，作为整个栈的底层，你可以在多种数据库之间进行选择。作为事实的数据源，你当然希望选择一种可靠的数据库，但同时也希望它能够允许你以良好的方式进行数据建模。在本文中，我将为你介绍Neo4j，当你的数据模型包含大量关联数据以及关系时，它可以成为你的web应用栈的基础的一个良好选择。 Neo4j是什么？ Neo4j是一个图形数据库，这也就意味着它的数据并非保存在表或集合中，而是保存为节点以及节点之间的关系。在Neo4j中，节点以及关系都能够包含保存值的属性，此外： 可以为节点设置零或多个标签（例如Author或Book） 每个关系都对应一种类型（例如WROTE或FRIEND_OF） 关系总是从一个节点指向另一个节点（但可以在不考虑指向性的情况下进行查询）","text":"在开发一个全栈web应用时，作为整个栈的底层，你可以在多种数据库之间进行选择。作为事实的数据源，你当然希望选择一种可靠的数据库，但同时也希望它能够允许你以良好的方式进行数据建模。在本文中，我将为你介绍Neo4j，当你的数据模型包含大量关联数据以及关系时，它可以成为你的web应用栈的基础的一个良好选择。 Neo4j是什么？ Neo4j是一个图形数据库，这也就意味着它的数据并非保存在表或集合中，而是保存为节点以及节点之间的关系。在Neo4j中，节点以及关系都能够包含保存值的属性，此外： 可以为节点设置零或多个标签（例如Author或Book） 每个关系都对应一种类型（例如WROTE或FRIEND_OF） 关系总是从一个节点指向另一个节点（但可以在不考虑指向性的情况下进行查询） 为什么要选择Neo4j？在考虑为web应用选择某个数据库时，我们需要考虑对它有哪些方面的期望，其中最重要的一些条件包括： 它是否易于使用？ 它是否允许你方便地回应对需求的变更？ 它是否支持高性能查询？ 是否能够方便地对其进行数据建模？ 它是否支持事务？ 它是否支持大规模应用？ 它是否足够有趣（很遗憾的是对于数据库的这方面要求经常被忽略）？ 从这几个方面来说，Neo4j是一个合适的选择。Neo4j…… 自带一套易于学习的查询语言（名为 Cypher） 不使用schema，因此可以满足你的任何形式的需求 与关系型数据库相比，对于高度关联的数据（图形数据）的查询快速要快上许多 它的实体与关系结构非常自然地切合人类的直观感受 支持兼容ACID的事务操作 提供了一个高可用性模型，以支持大规模数据量的查询，支持备份、数据局部性以及冗余 提供了一个可视化的查询控制台，你不会对它感到厌倦的 什么时候不应使用Neo4j？作为一个图形NoSQL数据库，Neo4j提供了大量的功能，但没有什么解决方案是完美的。在以下这些用例中，Neo4j就不是非常适合的选择： 记录大量基于事件的数据（例如日志条目或传感器数据） 对大规模分布式数据进行处理，类似于Hadoop 二进制数据存储 适合于保存在关系型数据库中的结构化数据 在上面的示例中，你看到了由Author、City、Book和Category以及它们之间的关系所组成的一个图形。如果你希望通过Cypher语句在Neo4j web控制台中列出这些数据结果，可以执行以下语句： 12345MATCH (city:City)&lt;-[:LIVES_IN]-(:Author)-[:WROTE]-&gt; (book:Book)-[:HAS_CATEGORY]-&gt;(category:Category) WHERE city.name = “Chicago” RETURN * 请注意这种ASCII风格的语法，它在括号内表示节点名称，并用箭头表示一个节点指向另一个节点的关系。Cypher通过这种方式允许你匹配某个指定的子图形模式。 当然，Neo4j的功能不仅仅在于展示漂亮的图片。如果你希望按照作者所处的地点（城市）计算书籍的分类数目，你可以通过使用相同的MATCH模式，返回一组不同的列，例如： 1234MATCH (city:City)&lt;-[:LIVES_IN]-(:Author)-[:WROTE]-&gt; (book:Book)-[:HAS_CATEGORY]-&gt;(category:Category) RETURN city.name, category.name, COUNT(book) 执行这条语句将返回以下结果： city.name category.name COUNT(category) Chicago Fantasy 1 Chicago Non-Fiction 2 虽然Neo4j也能够处理“大数据”，但它毕竟不是Hadoop、HBase或Cassandra，通常来说不会在Neo4j数据库中直接处理海量数据（以PB为单位）的分析。但如果你乐于提供关于某个实体及其相邻数据关系（比如你可以提供一个web页面或某个API返回其结果），那么它是一种良好的选择。无论是简单的CRUD访问，或是复杂的、深度嵌套的资源视图都能够胜任。 你应该选择哪种技术栈以配合Neo4j？所有主流的编程语言都通过HTTP API的方式支持Neo4j，或者采用基本的HTTP类库，或是通过某些原生的类库提供更高层的抽象。此外，由于Neo4j是以Java语言编写的，因此所有包含JVM接口的语言都能够充分利用Neo4j中的高性能API。 Neo4j本身也提供了一个“技术栈”，它允许你选择不同的访问方式，包括简单访问乃至原生性能等等。它提供的特性包括： 通过一个HTTP API执行Cypher查询，并获取JSON格式的结果 一种“非托管扩展”机制，允许你为Neo4j数据库编写自己的终结点 通过一个高层Java API指定节点与关系的遍历 通过一个低层的批量加载API处理海量初始数据的获取 通过一个核心Java API直接访问节点与关系，以获得最大的性能 一个应用程序示例最近我正好有机会将一个项目扩展为基于Neo4j的应用程序。该应用程序（可以访问graphgist.neo4j.com查看）是关于GraphGist的一个门户网站。GraphGist是一种通过交互式地渲染（在你的浏览器中）生成的文档，它基于一个简单的文本文件（AsciiDoctor），其中用文字描述以及图片描述了整个数据模型、架构以及用例查询，可以在线执行它们，并使它们保持可视化。它非常类似一个iPython notebook或是一张交互式的白纸。GraphGist也允许读者在浏览器中编写自己定义的查询，以查看整个数据集。 Neo4j的原作者Neo Technology希望为GraphGist提供一个由社区创建的展示项目。当然，后端技术选用了Neo4j，而整个技术栈的其余部分，我的选择是： Node.js配合Express.js，其中引入了neo4j包 Angular.js Swagger UI 所有代码都已开源，可以在GitHub上任意浏览。 从概念上讲，GraphGist门户网站是一个简单的应用，它提供了一个GraphGist列表，允许用户查看每个GraphGist的详细内容。数据领域是由Gist、Keyword/Domain/Use Case（作为Gist分类）以及Person（作为Gist的作者）所组成的： 现在你已经熟悉这个模型了，在继续深入学习之前，我想为你快速地介绍一下Cypher这门查询语言。举例来说，如果我们需要返回所有的Gist和它们的关键字，可以通过以下语句实现： 12MATCH (gist:Gist)-[:HAS_KEYWORD]-&gt;(keyword:Keyword)RETURN gist.title, keyword.name 这段语句将返回一张表，其中的每一行是由每个Gist和Keyword的组合构成的，正如同SQL join的行为一样。现在我们更深入一步，假设我们想要找到某个人所编写的Gist对应的所有Domain，我们可以执行下面这条查询语句： 123MATCH (person:Person)-[:WRITER_OF]-&gt;(gist:Gist)-[:HAS_DOMAIN]-&gt;(domain:Domain)WHERE person.name = “John Doe”RETURN domain.name, COUNT(gist) 该语句将返回另一个结果表，其中的每一行包含Domain的名称，以及这个Person对于这一Domain所编写的全部Gist的数量。这里无需使用GROUP BY语句，因为当我们使用例如COUNT()这样的聚合函数时，Neo4j会自动在RETURN语句中对其它列进行分组操作。 现在你对Cypher已经有一点感觉了吧？那么让我们来看一个来自实际应用中的查询。在创建这个门户时，如果能够通过某种方式，只需对数据库进行一次请求就能够返回我们所需的所有数据，并且以一种我们需要的格式进行结构组织，那将十分有用。 让我们开始创建这个用于门户的API（可以在GitHub上找到）的查询吧。首先，我们需要按照Gist的title属性进行匹配，并匹配所有相关的Gist节点： 123456// Match Gists based on title MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; // Optionally match Gists with the same keyword // and pass on these related Gists with the // most common keywords first OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) 这里有几个要注意的地方。首先，WHERE语句是通过一个正则表达式（即=~操作符）和一个参数对title属性进行匹配的。参数（Parameter）是Neo4j的一项特性，它能够将查询与其所代表的数据进行分离。使用参数能够让Neo4j对查询和查询计划进行缓存，这也意味着你无需担心遭遇查询注入攻击。其次，我们在这里使用了一个OPTIONAL MATCH语句，它表示我们希望始终返回原始的Gist，即使它并没有相关的Gist。 现在让我们对之前的查询进行扩展，将RETURN语句替换为WITH语句： 12345678910MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) WITH gist, related_gist, COUNT(DISTINCT keyword.name) AS keyword_count ORDER BY keyword_count DESC RETURN gist, COLLECT(DISTINCT &#123;related: &#123; id: related_gist.id, title: related_gist.title, poster_image: related_gist.poster_image, url: related_gist.url &#125;, weight: keyword_count &#125;) AS related 在RETURN语句中的COLLECT()作用是将由Gist和相关Gist所组成的节点转换为一个结果集，让其中每一行Gist只出现一次，并对应一个相关Gist的节点数组。在COLLECT()语句中，我们在相关Gist中仅指定了所需的部分数据，以减小整个响应的大小。 最后，我们将产生这样一条查询语句，这也是最后一次使用WITH语句了： 123456789101112131415161718192021222324MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) WITH gist, related_gist, COUNT(DISTINCT keyword.name) AS keyword_count ORDER BY keyword_count DESC WITH gist, COLLECT(DISTINCT &#123;related: &#123; id: related_gist.id, title: related_gist.title, poster_image: related_gist.poster_image, url: related_gist.url &#125;, weight: keyword_count &#125;) AS related // Optionally match domains, use cases, writers, and keywords for each Gist OPTIONAL MATCH (gist)-[:HAS_DOMAIN]-&gt;(domain:Domain) OPTIONAL MATCH (gist)-[:HAS_USECASE]-&gt;(usecase:UseCase) OPTIONAL MATCH (gist)&lt;-[:WRITER_OF]-(writer:Person) OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword:Keyword) // Return one Gist per row with arrays of domains, use cases, writers, and keywords RETURN gist, related, COLLECT(DISTINCT domain.name) AS domains, COLLECT(DISTINCT usecase.name) AS usecases, COLLECT(DISTINCT keyword.name) AS keywords COLLECT(DISTINCT writer.name) AS writers, ORDER BY gist.title 在这个查询中，我们将选择性地匹配所有相关的Domain、Use Case、Keyword和Person节点，并且将它们全部收集起来，与我们对相关Gist的处理方式相同。现在我们的结果不再是平坦的、反正规化的，而是包含一列Gist，其中每个Gist都对应着相关Gist的数组，形成了一种“has many”的关系，并且没有任何重复数据。太酷了！ 不仅如此，如果你觉得用表的形式返回数据太老土，那么Cypher也可以返回对象： 12345678910RETURN &#123;gist: gist, domains: collect(DISTINCT domain.name) AS domains, usecases: collect(DISTINCT usecase.name) AS usecases, writers: collect(DISTINCT writer.name) AS writers, keywords: collect(DISTINCT keyword.name) AS keywords, related_gists: related &#125; ORDER BY gist.title 通常来说，在稍具规模的web应用程序中，需要进行大量的数据库调用以返回HTTP响应所需的数据。虽然你可以并行地执行查询，但通常来说你需要首先返回某个查询的结果集，才能发送另一个数据库请求以获取相关的数据。在SQL中，你可以通过生成复杂的、开销很大的表join语句，通过一个查询从多张表中返回结果。但只要你在同一个查询中进行了多次SQL join，这个查询的复杂性将会飞快地增长。更不用说数据库仍然需要进行表或索引扫描才能够获得相应的数据了。而在Neo4j中，通过关系获取实体的方式是直接使用对应于相关节点的指针，因此服务器可以随意进行遍历。 尽管如此，这种方式也存在着诸多缺陷。虽然这种方式能够通过一个查询返回所有数据，但这个查询会相当长。我至今也没有找到一种方式能够对进行模块化以便重用。进一步考虑：我们可以在其它场合同样调用这个终结点，但让它显示相关Gist的更多信息。我们可以选择修改这个查询以返回更多的数据，但也意味着对于原始的用例来说，它返回了额外的不必要数据。 我们是幸运的，因为有这么多优秀的数据库可以选择。虽然关系型数据库对于保存结构化数据来说依然是最佳的选择，但NoSQL数据库更适合于管理半结构化数据、非结构化数据以及图形数据。如果你的数据模型中包括大量的关联数据，并且希望使用一种直观的、有趣的并且快速的数据库进行开发，那么你就应当尝试一下Neo4j。 本文由Brian Underwood撰写，而Michael Hunger也为本文作出了许多贡献。 关于作者Brian Underwood是一位软件工程师，喜爱任何与数据相关的东西。作为一名Neo4j 的Developer Advocate，以及neo4j ruby gem的维护者，Brian经常通过一些演讲，以及在他的博客上的文章宣传图形数据库的强大与简洁。Brian如今正与他的妻儿在全球旅行。可以在Twitter 上找到Brian，或在LinkedIn上联系他。 查看英文原文：Full Stack Web Development Using Neo4j","categories":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://github.com/tags/Neo4j/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}]},{"title":"谷歌整体战略：关于人工智能、云服务和登月计划的未来","slug":"谷歌整体战略：关于人工智能、云服务和登月计划的未来","date":"2016-10-21T07:43:20.000Z","updated":"2016-10-26T10:36:27.379Z","comments":true,"path":"2016/10/21/谷歌整体战略：关于人工智能、云服务和登月计划的未来/","link":"","permalink":"http://github.com/2016/10/21/谷歌整体战略：关于人工智能、云服务和登月计划的未来/","excerpt":"CB Insights 今日发布了一篇关于谷歌业务战略的深度分析报告: Google Strategy Teardown: Betting The Future On AI, Cloud Services, And (Tamed) Moonshots，盘点了谷歌在人工智能、云服务、虚拟现实/增强现实、电信与能源、运输与物流、硬件和服务平台等众多领域的业务和战略。其中人工智能是贯穿谷歌所有方面的创新的线索。 自 1998 年谷歌在加利福尼亚州门洛帕克的一间车库变成一家公司以来，它已经发展成为了后 .com 时代企业创新的火炬手。谷歌对长远创新的亲睐体现在多个方面——从其广为人知的员工可用于个人项目的「20% 个人时间」政策（这个政策导致了 Gmail 和 AdSense 的诞生），到其在 2009 年成立的准独立的风险资本部分 Google Ventures，再到其面向未来创新的「登月计划」的 Google X 创新实验室（已改称 X）。 但是，近些年来，该公司已经开始转变其实验性的方法、有风险的研发和分散式的公司结构了。 在 2011 年执掌谷歌后，CEO Larry Page（现为 Alphabet 的领导者）就宣布谷歌将在「更少的箭头后放更多木材」，要向更重要的方向投入更多资源：从民主化的自下而上的创新方法变成更为自上而下的重点式战略。 实际上，据报道「20% 个人时间」政策在近些年来已经受到了限制，需要更多的管理批准和监督。 与此同时，谷歌已经从核心的搜索和广告业务扩展到了更为广阔的业务领域，其涵盖了从消费硬件到汽车到电信到医疗到风险投资等众多领域。","text":"CB Insights 今日发布了一篇关于谷歌业务战略的深度分析报告: Google Strategy Teardown: Betting The Future On AI, Cloud Services, And (Tamed) Moonshots，盘点了谷歌在人工智能、云服务、虚拟现实/增强现实、电信与能源、运输与物流、硬件和服务平台等众多领域的业务和战略。其中人工智能是贯穿谷歌所有方面的创新的线索。 自 1998 年谷歌在加利福尼亚州门洛帕克的一间车库变成一家公司以来，它已经发展成为了后 .com 时代企业创新的火炬手。谷歌对长远创新的亲睐体现在多个方面——从其广为人知的员工可用于个人项目的「20% 个人时间」政策（这个政策导致了 Gmail 和 AdSense 的诞生），到其在 2009 年成立的准独立的风险资本部分 Google Ventures，再到其面向未来创新的「登月计划」的 Google X 创新实验室（已改称 X）。 但是，近些年来，该公司已经开始转变其实验性的方法、有风险的研发和分散式的公司结构了。 在 2011 年执掌谷歌后，CEO Larry Page（现为 Alphabet 的领导者）就宣布谷歌将在「更少的箭头后放更多木材」，要向更重要的方向投入更多资源：从民主化的自下而上的创新方法变成更为自上而下的重点式战略。 实际上，据报道「20% 个人时间」政策在近些年来已经受到了限制，需要更多的管理批准和监督。 与此同时，谷歌已经从核心的搜索和广告业务扩展到了更为广阔的业务领域，其涵盖了从消费硬件到汽车到电信到医疗到风险投资等众多领域。 去年十月份的 Alphabet 组织架构重组就是为了这个庞大的规划网引入更大的结构、透明度和财政责任。为了同样的目的，该公司还在今年七月份聘请了摩根士丹利在财务纪律（financial discipline）享有盛名的资深高管 Ruth Porat 作为首席财务官。 一年来，这些举措已经给山景城应对收购和研发的方法带来了明显的改变。新的股权激励将会将员工的奖励和个人单位绩效挂钩。在 X 实验室，负责人 Astro Teller 曾写了需要推进登月项目「毕业」——「毕业」是指项目最终成长为 Alphabet 企业家族中可扩展的团队和产品。以 GV 为例，该投资部门已经很长时间没有领导了，其规模以及尤其的种子交易截至今年目前为止已经缩减了。 由于该公司幅员辽阔，我们使用了 CB Insights 科技市场智能平台中的许多工具来提炼 Alphabet 组织范围内各个单位的收购、投资和研究/专利活动，从而获得了一个关于其未来战略的数据驱动的视角。鉴于该公司运营范围的辽阔，我们不会触及每一项计划和部门，而只关注推动谷歌系向前的主要和反复出现的主题，其中包括： 推进云和硬件：Alphabet 推动增长的领域已经不再限于广告了，也在研发、收购和投资有可能实现收入和带来利润的业务和领域，例如高级移动和智能家居硬件，尤其是云和企业服务。比如谷歌在 Nest 之后最大的收购 Apigee 就是一家已经上市的企业云公司。 人工智能优先（AI-first）战略：该公司正在利用其人工智能/机器学习的专家人才（包括那些通过 DeepMind 收购吸纳进来的）来差异化自己在上述部门以及搜索和广告、整个面向消费者的网页服务和其它 Alphabet 单位的产品。谷歌新款的高端移动和智能家居设备就是提供一些人工智能服务的渠道。 关注增强现实/虚拟现实、自动驾驶和数字医疗：投资、收购和山景城的专利数据范围包括自动驾驶、可穿戴、人工智能驱动的医疗和为全球更大范围的人口提供网络接入。 收购再次回升：该公司在 2016 年第 3 季度进行了 9 次收购，是自 2014 年第 3 季度以来最多的。这说明了该公司的兼并收购（M&amp;A）意愿的复兴，因为其已经表现出了进一步拓展移动硬件（包括 Pixel 手机和智能家居中枢）、企业云服务、交通/物流、虚拟现实等领域的打算。 GV 已经大大退出了种子市场：GV 已经基本上不再投资年轻的创业公司了。其种子投资上的行为已经较去年同期下降了 85%，在 2016 年上半年完全没有任何新的种子交易。 规范其它登月项目：控制开支和强迫登月项目概划盈利的途径。这让该公司启用了资深人士和重组了团队以实现业务化，另外还招募了一些外部行业资深人士来推动 Loon 和自动汽车项目的商业化。 目录 谷歌核心的一些背景 收购 投资 谷歌 GV 谷歌资本 专利数据分析 按领域划分的 Alphabet 计划 人工智能 云与企业 消费硬件和平台 增强现实/虚拟现实 电信与能源 交通与物流 医疗保健和数字健康 金融科技 结语 谷歌核心的一些背景在我们深入到 Alphabet 未来战略背后的数据之前，我们必须快速了解其目前最成熟和最盈利的业务线：谷歌搜索和广告。 提醒一下，现在的谷歌包含搜索、地图、云和企业、谷歌品牌的硬件和操作系统（Chrome、安卓等）和 YouTube。其它所有单位（从投资部门（GV、Google Capital）到 X 部门）现在都直接隶属于 Alphabet。但我们将统一使用「谷歌」进行指代，不管它现在确实属于谷歌还是在 Alphabet 之前属于谷歌。 2016 年第 2 季度，该公司的总收入（top-line）和净收入（bottom-line）增长超出了分析预期。主要在谷歌的核心广告业务的推动下，Alphabet 的季度收入跃升了 21%，增长至 215 亿美元，利润则增长了 24%，超出了市场预估。这种强劲的势头的推动力来自向移动平台的成功过渡，其中包括新的移动广告格式和更好的效果评估。 尽管上个季度的结果大部分是积极的，但也存在一些可能会影响长期前景的趋势。首先，谷歌广告业务的收入中来自其自家网站的份额在 2016 年第 2 季度首次达到了巅峰的 80%，而在 2011 年时这个比例是 70%。这意味着未来的广告增长将前所未有地更加依赖于谷歌向其自己网站（例如搜索结果和谷歌新闻等等）的流量引导，而不是向网络成员的网站。 移动广告通常比桌面广告的利润低，所以谷歌的成功是在每次点击的收入（CPC，当消费者点击广告商的广告时，广告商向谷歌的平均付费）更低的情况下实现的，其巨大的增量抵消一些这种情况的影响。2016 年第 2 季度在自家网站的 CPC 仅有两年前自家网站的 CPC 的 76%。 应用程序和连接设备数量的激增也带来了挑战，因为在 Facebook 和微信等应用程序占用大量用户在线时间，以及新一代设备（如智能家居中心）导流搜索流量成为潜在竞争对手的情况下，还不清楚谷歌的搜索引擎是否会继续占领主导地位（例如通过亚马逊的 Echo 智能家居设备和其 Alexa 语音助手直接进行的搜索）。 事实上，谷歌在全球数字广告支出中所占的份额持续下降，因为像 Facebook 这样的国内竞争对手以及百度和阿里巴巴等国际竞争对手都在持续增加市场份额。 谷歌的广告业务使公司长期以来一直保持稳定，同时它的财务手段也成为其登月计划（moonshot）的支撑。然而，尽管 Alphabet 的业务数量庞大，其财务业绩和增长前景仍然严重依赖于谷歌的原有业务（广告占了 Alphabet 2016 年第二季度收入的 89％）。其核心业务的卓越表现在其它不稳定的业务中是显而易见的，但是山景城（加利福尼亚州的一个县）已经敏锐地觉察到谷歌的收入来源是缺乏多样性的。当我们通过它的子公司深入了解 Alphabet 的活动时，我们将看到寻找新的增长途径是如何塑造了该公司的战略的收购。 收购传统认为谷歌是最有收购能力的科技公司之一，但它的收购步伐速度放缓，并导致了 Alphabet 架构下的机构重组。 自 2001 年以来，该公司已经进行了近 200 次收购，引进外部人才和扩展新的部门，并在这个过程中创造了 Larry Page 的另一句「牙刷测试（toothbrush test）」技术格言，来确定并购目标是否值得。（目标是必须开发客户认为每天都不可缺少的产品。） 我们的收购跟踪工具包括在山景城稳定的收购流中的每个收购记录。Alphabet 今年迄今（16 年 10 月 10 日）已经收购了 13 家公司，仅在上个月就进行了 3 次收购，其中包括 6.5 亿美元收购上市云公司 Apigee。我们使用 CB Insights Acquirer Analytics 工具跟踪谷歌自 2010 年以来的并购活动： 在这十年的大部分时间里，谷歌一直是技术并购的主导力量；活动在 2014 年达到顶峰，因为谷歌在第二季度收购了十多家公司，远远领先于那一年其它科技巨头的收购规模。然而，该公司的收购步伐大幅放缓，Alphabet 重组，并在 2016 年上半年大幅下降。最近一个季度的收购活动增加，虽然是否为昙花一现还有待观察，也或许是山景城适应了 Alphabet 的新收购速度释放的信号。到目前为止，2016 年第四季度，Alphabet 只收购了 Famebit，一个可以帮助商业品牌与 YouTube 上的视频创作者建立联系的平台。 除了最新的财务紧张问题，近十年来大规模收购带来的低迷结果可能也促使了公司收购活动的暂停。该公司快速地收购了至少 7 家机器人公司——Schaft , Industrial Perception , Meka Robotics, Redwood Robotics ,Bot &amp; Dolly , Holomni , 以及最著名的波士顿动力（Boston Dynamics）——触发了 2014 年的炒作高峰（如趋势图所示，如下），但这些公司从来没有合并成为一个高效的机器人公司。前安卓负责人 Andy Rubin 带领了机器人浪潮，但 Rubin 于 2014 年 10 月离开公司创办全球硬件创业孵化器 Playground Global。失去了有远见的人物可能会阻碍机器人部门的发展，不管是在谷歌或是在 Alphabet，这个名为 Replicant 的机器人部门从未真正合并成为一个完整的公司。 相反，在 Alphabet 创立后，Replicant 直接进入管理层的视线，新公司 Alphabet 对其各公司的创收潜力进行了严格的审查。虽然像波士顿动力公司这样的子公司在 YouTube 上备受推崇，但是漫长的商业化道路导致该公司在 2016 年初被出售。最近，谷歌 2014 年对智能家居的重要战略环节——收购 Revolv，Dropcam（5.55 亿美元）和 Nest（3.2 亿美元，迄今为止收购的最大的初创公司）也被管理不善和员工流失的指控所困扰。Nest 的紧张局势随着 Nest 联合创始人兼首席执行官 Tony Fadell 在 6 月份的离开而公之于众。Fadell 辞职的事件中反复提到了智能家居领导层之间的摩擦，最引人注目的是 Dropcam 创始人 Greg Duffy 在 Medium 上的一篇博客（他的 Dropcam 团队被纳入 Nest 智能家居部门）： 将 Dropcam 卖给 Alphabet 是我的错误……可以说，我与当前 Nest 的领导在管理方式上有极大的差异。 Nest 的问题可以看作是旧的管理结构的失败，即在公司扩展到新的市场和产品线时，没有正确地管理其各个子公司，在 Googleplex 背景下协调达成一致的目标和企业文化。事实上，Nest 部门（现在是一个独立的 Alphabet 公司）远离了该公司的新智能家居硬件的努力方向（刚于 2016 年 10 月 4 日的智能硬件大会上发布 Google Home）。作为 Alphabet 的事实上的智能家居公司，Nest 可能是成为亚马逊 Echo 设备的竞争者的最好的选择。然而，亚马逊设备对谷歌公司的主要搜索业务的明显威胁，以及与亚马逊竞争的日益激烈，可能导致谷歌得出结论：必须将开发智能家居作为公司核心，并由谷歌的执行官直接监督。 此外，这样的产品需要与谷歌的核心搜索和虚拟助理服务紧密集成。Nest 作为谷歌的非核心公司想要实现这一点，跨越部门间的界限和达成共识将有更多的麻烦。 新成立的 Alphabet 结构可能有助于更成功的并购和不同业务的整合。Alphabet 旗下的不同部门将可以根据它们自己的战略利益和路线规划进行收购游说；但也会面临一个更为清晰的组织结构，能让 Alphabet 称霸天下，也会迫使其减少对投机项目的投入。 尽管谷歌的机器人和智能家居的投资已经变成了警示性的故事，但谷歌在许多其它领域的收购却带来了毫无疑问更为积极的结果。2014 年谷歌收购的 DeepMind（金额在 5 亿到 6 亿美元之间）已经通过其高调的 AlphaGo 和 WaveNet 项目巩固了谷歌在人工智能研究方面的声誉，而且其技术也已经在谷歌的数据中心和翻译工具等产品中得到了应用。 除了智能家居，谷歌与亚马逊的激烈竞争也带来了对云和企业服务的收购，以及一种完全不同的战略方法。谷歌正确地将云平台作为了其优先事项，因为其过去在这方面落后于亚马逊的 AWS 和微软的 Azure（尽管谷歌最近得到了一些战略性的云客户，其中包括苹果和 Spotify）。 在这个领域，谷歌严重依赖于收购来补充其内部研发和在其平台之上提供增值服务。特别地，CEO Sundar Pichai 曾说过该公司的目标是通过稳健的、对开发者友好的服务进行竞争，而不是单纯的规模。我们的收购方分析数据也突出了这方面的努力： 一个主要的例子是谷歌在今年 9 月对 Api.ai 的收购，这是一家帮助开发者开发对话式智能接口的创业公司。这能很好地和人工智能交织在一起，而人工智能则是谷歌的差异化战略的另一支柱（更多细节请参看行业部分）。 谷歌在这一领域的其它收购还包括 2014 年的 Stackdriver、Appurify、Firebase 和 Zync Render，以及过去两个月的 Apigee 和 Orbitera。事实上，谷歌 2016 年的一半以上的收购都涉及到企业应用或 B2B 云服务。其中许多都发生在 Recode 3 月份的谷歌在寻找企业云领域的目标上最活跃的报道之后。 据最近离开谷歌的人说，那些收购请求出现最频繁的是这个领域：企业。 在云的推动下，谷歌得以关注服务中端市场的多个目标，旨在增加多样化的企业能力，这和对 Nest 的数十亿美元的重磅收购不同。其 1 亿美元收购的计费服务公司 Orbitera 是这种追赶策略以及其对一个灵活的、「多云（multi-cloud）」世界（其中企业将越来越依赖于多个供应商）的支持的象征。 另外值得一提的是，和押注前沿的有希望但未得到证明的领域相比（比如，自动驾驶汽车和机器人），Alphabet 的一系列云和企业收购更倾向于有明显的赚钱机会的较为成熟的公司。 Alphabet 六月份对 Webpass 的收购也是来自于对成熟的电信领域的收购。Alphabet 运营 Fiber 业务的 Access &amp; Energy 部门已经宣布了利用 Webpass 的无线技术降低资本开支和部署时间的计划（伴随着 Fiber 业务成本高昂的扩张）。在这样的背景中，Webpass 看起来像是又一个带来了即时影响的收购——降低了开始并提升了盈利能力。 不可否认，自 Alphabet 诞生以来的这短短一年时间，数据就已经深远地影响了这个新组织在平衡「登月项目」和财政责任上的尝试，并且明晰了其实现收入的路径。 投资：谷歌，GV 和谷歌资本Alphabet 的投资活动一直被竞争者和观察家们关注。一部分投资由下属的谷歌或其分支直接发起（例如 DeepMind 直接投资了远程医疗初创公司 Babylon）。但大部分投资来自 Alphabet 的两家主要投资机构：专注于早期初创企业的 GV（前谷歌风投）和对扩张期公司投资的谷歌资本（Google Capital）。 这些投资分支一直强调其投资策略与谷歌本身互相独立。在 2015 年 9 月，集团的运营策略发生了改变，GV 和谷歌资本成为了新控股公司下的两家分支公司。（但他们共同接受 Aphabet 的高级副总裁 David Drummond 的监督，此人同时监管集团的企业并购业务。）我们相应地单独分析他们的活动，但它们仍会同时出现在一些深入的剖析中。 正如上图显示的，三家机构的投资活动数量在近期有很大波动。GV 的交易活动在 Alphabet 成立之前已经开始下降，而投资的增长来自于谷歌资本和谷歌本身的战略投资。 谷歌从谷歌开始，公司的主要战略投资包括几次大型交易到一些「前沿」领域如增强现实，太空运输和探索。谷歌在 2014 年 10 月领投了隐形增强现实设备 Magic Leap 5.42 亿美元的一轮投资，在 2015 年 1 月又参与了 Space X 10 亿美元的 D 轮融资。有消息称谷歌正准备在未来对这家宇航公司继续投资 90 亿美元，以获得 7.5% 股权。 这种投资活动的规模强调了山景城对于先进科技领域的重视。谷歌认为 AR/VR 是未来计算视觉呈现的核心。其 Magic Leap 的交易宣示了公司策略的进一步多元化（谷歌已有包括在 2016 年 10 月发布的消费级产品 Daydream 移动 VR 头盔，和其他早期产品，如 Cardboard，Google Glass 和 Tango）。 与此同时，谷歌向 SpaceX 进行了大笔投资，这将帮助 Alphabet 的「登月计划」为谷歌提供地理信息（Terra Bella，前 Skybox Imaging 项目），同时帮助提升全球互联网覆盖面积（Access and Energy，前 Project Loon 等计划）。廉价高效的地球卫星发射将会为对这两个方面提供便利，而 SpaceX 的首席执行官埃隆·马斯克对此也志趣相投，他决心建立一个以卫星为媒介的全球通信网络。谷歌直接资助了卫星服务公司 O3b Networks ── 而 O3b 已被欧洲卫星通信公司 SES 以 14 亿美元的价格收购──这些投资也与上述活动相关。 除了战略投资，在 2016 年 4 月谷歌建立了 Area 120，一个为公司内部员工准备的创业孵化器。这些措施是为了防止公司人才的外流。孵化器的名字中提及挤出 20% 的时间进行创业，就像谷歌的其他传统一样，这已经变成了一个正式的，明确的计划。 GVAlphabet 风投机构自 2009 年成立以来，已经成为了风投生态中的重要一环，它一直是最为活跃的风投公司。我们接下来分析 GV。 有这样一个事实：Bill Maris，作为创始人和首席执行官在 8 月初离开了 GV。有匿名消息称这次人员变动与上级公司 Alphabet 的重组有关（在 Maris 治下的 GV 以自主决定权而闻名）。目前事件的双方仍公开表示友好，Maris 这样评论： 我的离开是因为所有事情都很棒……我与 Alphabet 之间没有问题。但 Alphabet 的改变对所有人都有一点影响。我们（GV）从第一天开始就是独立的。 虽然如此，在后 Aphabet 时代里，创始人的离去仍将成为主题，这一幕也许将会在公司的其他部门继续呈现。 通过 CB Insight 的投资分析工具分析 GV 近期的投资活动，我们可以看到 GV 的投资速度自 2013 年末到 2014 年初的顶峰（约每季度 30 笔投资）以后，有逐渐下降的趋势。这与我们之前 GV 正在减少新投资活动的结论相同。 GV 在 2009 年以 10 亿美元资本起家，每年膨胀 50 亿美元。随着 GV 资金来源的充裕，它逐渐参与进了大型投资，如 2014 年优步 12 亿美元的 D 轮投资和 Jet.com 在 2015 年的 B 轮投资。CB Insight 的投资分析工具显示了 GV 持续增长的中型交易，在 2016 年第一季度，公司一跃进入了大型投资的行列，包括 2 月份对 Oscar（40 亿美元）和 Magic Leap（7.94 亿美元）的投资。总的来说，数据显示 GV 的大型投资脱离了 2015 年以前的中位数，出现了急剧上升。 交易数量的减少和投资金额的增加表明 GV 已完全退出天使轮投资市场，这个曾经它赖以为生的领域。在过去的两年里，它的天使轮投资活动每年减少 85%，在 2016 年上半年则完全没有这种投资出现。 Bill Maris 在去年 12 月承认了这种变化，认为在前期投资中的机会正在减少。在 今年 8 月 Maris 离职的采访中，他同样指出 GV 目前对于投资形式存在限制： 当你有 25 亿美元的资金，进行种子轮投资就是浪费时间了。 同时，GV 融资项目的区域也越来越固定了──以美国为中心。公司 2014 年启动了 12.5 亿美元的欧洲投资专项资金，由五位合伙人进行管理。然而，在后 Alphabet 时代，这个项目在 2015 年 12 月宣告终止，其中资金被回收并投入 GV 品牌再造项目。 在大约一年半之前，欧洲的分部进行了不到十项投资，其中最大的交易是对宾馆预定网站 Secret Escapes 6000 万美元的 C 轮融资（Octopus Investments 是这次投资的另一个领投者）。 从行业上看，GV 一直被其「独立」的策略所束缚，公司表面上追求高风险，但潜在高回报的登月式的项目，实际上却与传统风投公司别无二致。Maris 的个人魅力渲染了谷歌对于登月式项目的追求。医疗领域的投资为这种看法做出了注解，正如 Maris 在 2015 年文件中所说： 如果你今天问我，我们会活到 500 岁吗？答案是肯定的……如果有人让你在很多钱和能活很久中进行选择，你会怎么选？ 的确，GV 一直在强调他们会投资医疗初创企业。他们的投资范围从数字医疗公司（Flatiron Health）到供应商（One Medical），也包括新方向如基因医疗（Editas，Foundation Medicine，23andMe）。近年来，公司正在这些公司上投入越来越多的资金。在 2015 年 3 月，Maris 在接受彭博社的采访时披露，其时 GV 已将 36% 的资金投入生命科学领域，而在 2013 年，这个数字只有 6%。 GV 的投资和 Alphabet 其他部门 Verily 与 Calico 的投资共同正在为变革性医疗研究助力。如此重视医疗行业无疑是因为 Bill Maris 拥有生命科学背景；事实上，这位前生物科学公司管理人直接推动了 Calico，Alphabet 神秘的抗衰老研究部门。在 CB Insight 中，我们可以深入了解 GV 对于其他领域的投资，跨度从 AR/VR 领域到无人机，互联网金融，网络安全，再到人工智能。GV 的投资组合与 Alphabet 令人眼花缭乱的资本操作有着很多重合。至少 6 家 GV 投资的公司最终都被山景城收购，其中值得注意的是 2014 年的 Nest。 另一方面，优步突然变成了 GV 甚至 Alphabet 投资策略中潜在的不和谐音符。随着竞争对手的压力，优步开始将重心转向他们的自动驾驶汽车，而谷歌此前也投资了拼车应用 Waze（收购于 2013 年）探索共乘车市场。随着这些步骤的实施，在共乘车服务上他们正在对优步形成威胁。 作为回应，优步正在逐渐稀释管理层中 Alphabet 的地位，交易负责人 David Drummond 离开了优步董事会。这家打车公司同时驱逐了董事会观察员 David Krane，后者是 GV 的合伙人，现已成为 Bill Maris 的继任者。 谷歌资本谷歌资本是 Alphabet 风投家庭中年轻的一员，于 2013 年创立。因其资金充裕，公司的投资方向明显不同于集团内老一代的同僚，谷歌资本主要参与初创企业的后期融资阶段。据称，他们每年的投资数量为 30 亿美元。一个健康的数字，但略微少于 GV。正如其宣称的，谷歌资本将自身定位于盈利导向（而不是战略导向）的投资者。当然，其不断增长的资金仍正在利用专业知识，招募基础和其母公司谷歌的威望作为其核心卖点。集团的其他公司承诺给对谷歌资本共享资源。Edward Kim，被投资公司 Gusto 的首席技术官赞赏这种工作方式： 他们真的从谷歌内部找到了一个人，一个能够解决我们问题的人。相比资金，他们其实带来了更多技术上的帮助。 自成立以来，谷歌资本一直维持比 GV 更低的活跃度。他们每季度的成交数量维持在 1 至 3 笔，只在 2015 年第三季度超过了这一数字。 谷歌资本通常参与 2500 万至 10 亿美元的融资轮，这不属于很大的交易。其中一些包括 CloudFlare 的 D 轮融资（11 亿美元），FanDuel 的 E 轮融资（27.5 亿美元），和 Oscar 的 C 轮融资（40 亿美元）。 谷歌资本的投资方式反映了硅谷大多数高端投资公司的习惯，与那些著名对冲基金，或老虎基金与富达投资的科技投资共同基金相似。 GV 很少在谷歌资本投资之前对同一家公司进行投资。前者确实出现在了谷歌资本投资的一些公司的共同投资人名单上，但这一般都是在追逐利益时出现的巧合。当然，随着 GV 正在逐渐远离早期投资市场，两家投资机构的重叠区域可能会越来越多。 谷歌资本目前最值得一提的交易是对 Care.com 的首次公开市场投资。今年 6 月，谷歌资本宣布了对这家护理服务公司 4635 万美元的投资，该公司于 2014 年 1 月份上市。这次交易意味着公司的投资部门跨越私人与公开市场，这与那些共同基金和对冲基金的业务相同，正如谷歌资本的合伙人 Laela Sturdy 在回答公司对私人和公开市场领域之间的立场的问题时所说的： Care.com 体现了本公司的投资喜好。我们一直专注于成长阶段的公司，我们唯一的目标是帮助他们成长为拥有谷歌体量的巨头。 我们可能会看到未来谷歌资本进行更多的 PIPE（私募资本投资公开市场），又或许他们将固守传统的私人投资领域。 专利数据分析使用 CBInsights 专利数据，我们还筛选出公司研究活动的趋势。这项分析在执行时有几个注意事项，主要是，专利申请过程在应用发布前有一个明显的时间差。这个延迟时间从几个月到两年不等。我也拿谷歌做过该方面分析，排除了其外部收购公司带有的专利。 另外值得注意的是，谷歌一直以来对专利所持的态度。过去，公司高管包括 Larry Page 和 Sergey Brin 他们自己都反对申请过多的专利，这会威胁到硅谷的创新精神。乔布斯发布第一台 iPhone 时，谷歌只有 38 项专利。到了 2011 年，谷歌高级副总裁总法律顾问 Kent Walker 描述了公司对专利制度的普遍厌恶，他们希望见到改革措施： 专利不是创新。这是一种阻止他人创新的特权。 然而，随着智能手机的诉讼在本世纪初加剧，谷歌被迫转变了立场。2012 年，它以 125 亿美元的价格收购了摩托罗拉手机业务，这是迄今为止该公司最大的收购，该收购为谷歌不断增长的 IP 库带来了丰富的手机专利。谷歌自己也开始迅速提交专利应用申请。 关键数据突出在与谷歌前沿产品计划相关的专利上。Mountain View 的专利点亮了其谷歌眼镜计算设备及其他可穿戴设备研究。「Balloon」也在 2014 年问世，它从今年年初到现在一直处于下面这张列表的首位，Project Loon 的气球动力互连网络开发一直在持续。 关键词「车辆（vehicle）」上升的频率也反应出谷歌在自动驾汽车领域上的投入，他们一直在扩大自动驾驶的测试团队，还在寻找汽车制造商合作伙伴。2012 年，带有汽车关键词的应用数量激增，而且最近几年一直在增长，包括专利数据可能还不完整的 2014 年，所以当这些档案公布于世时，汽车应用的数量实际上甚至会更多。 很多这些专利产生计划（moonshot），当然包括自动驾驶机车项目，已经占领了谷歌的 X 实验室。自从 2010 年建立以来，X 实验室一直在尝试成为一个成功的致力于尖端前沿的企业研究机构，其他像 PARC 和贝尔实验室最终都因其母公司而失败了（至少在资金上）。 我们的趋势工具挖掘了数百万条媒体关于技术趋势的报告后显示，「moonshot」一词的流行度一时间接近了「Google X」。换句话说，谷歌的实验室与 moonshot 概念紧密相关，像传统的企业创新实验室运营商一样，Alphabet 已经不再避开专利系统了。 下一节中，我们将细究遗爱谷歌的一些优先项目，以及它们是如何融合进 Alphabet 的特定产业策略中的。 Alphabet 在各领域的战略和其投资部门很像，Alphabet 其他的子公司（包括谷歌）的业务都涉足了不同的领域。这里，我们对 Alphabet 涉足的重点领域进行分组深入分析。再次强调，下面的列表中不包括这家公司的所有业务活动，而是综合概述了其目前的兴趣领域。 人工智能今年 10 月在其最新高端 Pixel 智能手机的发布会展示中，谷歌 CEOSundar Pichai 说世界正在从「移动至上」转向「人工智能至上」。谷歌与人工智能这一时髦领域有着密切的联系，而且占领这一领域的欲望越来越强烈，并成为了最活跃的人工智能公司卖家。 在其公司内部，谷歌大脑以一个 X 项目成功凸显。去年，Astro Teller 将谷歌大脑描述成「谷歌的生产价值所在，可以抵得上 GoogleX 的总成本了，」这个小组开发了 tensorflow，并提高了从翻译到语音搜索的核心技术。在 Alphabet 今年第二季度盈利的电话会议上，Sundar Pichai 也对投资人重复强调了机器学习的重要性。 机器学习是驱动未来的引擎… 谷歌内部目前有超过 100 个团队在使用机器学习，从街景到 gmail 到语音搜索等等。 除了实体产品外，一个脱胎于 DeepMind 的系统已经帮助其耗电量巨大的数据中心减少了成本和实现了环境保护功能，将能源使用效率提升了 15%。 谷歌正在将机器智能和学习部署到它的所有业务上，我们也在几个关键领域对其人工智能方面的业务活动做出分析。 云&amp; 企业谷歌的云和企业服务已快速上升至其优先项目中了，这一点在其疯狂的收购中可见一斑。进一步推进有利可盈的服务市场延伸了 Alphabet 所强调的能直接带来财务上涨的机会的逻辑（上一季度，亚马逊 AWS 部门产生近 100 亿美元收入） 在 Alphabet 成立谷歌云事业部 Google Cloud Enterprise 后，谷歌立即挖来了 VMWare 的前 CEODiane Greene 任职谷歌的云计算事业部的高级副总裁。谷歌云包括了 Google for Work、云平台（针对 AWS）、和 Google App。谷歌已经开始重新定位其品牌。2016 年 9 月，Google for Work 品牌更名为 G Suite。视频群聊和没人爱的 Google+网络也正在转向企业用户。我们已经看到，谷歌正在收购和建立众多对开发人员友好的服务来区分其平台。然而，谷歌也在很多业务中利用了机器学习技术，以便在与对手的竞争中抢占先机。 谷歌大脑和公司的人工智能收购业务有助于推动这些进展，同时也肩负着提醒旁观者 Mountain View 在人工智能领域的领先地位的责任。然而据我们的趋势分析显示，就其云产品而言，谷歌在媒体报道上依然落后于微软 Azure 和 AWS。 虽然谷歌一直落后于亚马逊、微软，甚至是 IBM，但早期的回报总是积极性的。今年第二季度谷歌的「其他收入」（包括云及许可费用，硬件、及其他非广告业务）为 22 亿美元，并以 33% 的年增长率上升。公司高管们很快就注意到了，云服务是这一增长的主要驱动力，而且将仍然是谷歌找到创收新途径的战略基石。 消费硬件&amp;平台我们已经涉足了这个领域，但是 Alphabet 面向消费者的项目一直在努力平衡他们在金融实用主义上对激进项目的偏好。Nest 最近的已经出现在各个角落，但是其他部门的业务还在面临自己的困难。 谷歌搞出了 X，而 Advanced Technology and Projects（ATAP）的研发部门也在开发「epic shit（史诗级项目）」，并与公司保持适当的整合。但是，像其他的部门一样，针对于消费者的研发部门今年也经历了更换重要领导。 谷歌自从把摩托罗拉前总裁 Rick Osterloh 拉回董事会主持新一轮洗牌时，汇集了像 ATAP, Chromecast, Nexus, Pixel 智能手机和谷歌眼镜（后者原先由 Tony Fadell 负责）不同的面向消费者团队。这个新的硬件部门最近搁置了 Project Ara，自 2013 起来一度大肆宣传的模块化智能手机。 谷歌一直对其自主手机硬件品牌产品 Nexus 和 Pixel 不太满意，现在 Pixel 取代了 Nexus，并与运营商签约了正式分销协议。 谷歌的消费设备跨越各种智能手机、平板电脑、笔记本电脑，以及一个运行 Andromeda 的混合设备，一个统一了安卓和 Chrome 的操作系统。该公司继续在很大程度上轮流依赖于多家制造商伙伴（三星、HTC、华为等等）为其生产设备。 显然，谷歌谷歌刚刚宣布了 Pixel 线的品牌制造厂商，并促成了合作伙伴 HTC 与富士康合作（据说导致华为退出该项目）。 这些新手机与 Home 和 Daydream 一起在 10 月的「Made by Google」大会上发布。该产品的闪电问世为 Osterloh 的新硬件部门定下了基调，以谷歌为中心的品牌推广透露着该公司有点模仿微软 Surface 产品线的意味，更加接近苹果在硬件设计和软件服务上的业务布局。新的 Pixel 设备的溢价定价比对了之前 Apple 的 iPhone7 系产品的定价。谷歌又一次在一个成熟的行业中追逐一块高利润的馅饼。 谷歌也在展望对话智能平台的未来，从 Allo 的即时讯息到智能家居。此外，新的 Pixel 智能手机已经有内置捆绑人工智能的功能，包括新的虚拟谷歌助手，以及 Pixel 用户的照片和视频无限存储。至少现在，谷歌正在为其品牌 Pixel 和家居设备保留了语音助手（通过 Allo 的机器人聊天可以用上这个语音助手，但是没有整合进来）。 谷歌一直在利用人工智能来区分其消费云产品，比如其带有自然语言搜索和自动脸与对象识别的照片产品 在硬件和即时讯息这两个业务上，谷歌已经晚了一步，但是这些举措都对山景（Mountain View）产品在人工智能技术和作为搜索平台中心上奠定重要地位起到了关键作用。每个通过一个 Alexa-或者 Siri 驱动的设备的查询都威胁到了谷歌当前收入模型的基础。即便谷歌在这里取得了成功，一个以语音为中心的搜索形式仍有可能颠覆其已经依赖了十几年的传统网页搜索广告的显示模式。 同时，如果谷歌能将其设备和服务通过其人工智能技术含量区分开来，它将有机会创造出一个新的、潜在的高利润业务线，甚至可以通过拓展市场份额加强其与苹果和亚马逊的对抗。 增强现实（AR）/虚拟现实（VR）Alphabet 的增强现实/虚拟现实的经典战略已经开展成了多个并行运行的项目。该公司在这项业务上已经从预算虚拟现实（Cardboard），到 AR（谷歌眼镜）硬件再到 VR（Daydream）和 AR（Tango）平台，还有其前面提到的 Magic Leap。在我们的增强与虚拟现实研究简报中，我们已经研究了谷歌和其他科技公司。从产品创新来看，Daydream 头戴设备很有趣，它一改之前笨重的塑料套而使用了轻便的布状织物，是一款面向大众消费者的虚拟现实概念的新设计产品。 事实上，围绕谷歌 AR/VR 的讨论大部分都是讨论 VR 而不是 AR，这并不意外，因为它的 AR 可穿戴产品 Google Glass 失败了，而 Daydream 成为了谷歌在此领域中的旗手。 通信 &amp; 能源Alphabet 通过外部投资（SpaceX、O2b Networks）、收购（Titan Aerospace，现在是 Project Skybender）以及一些内部项目，投入了数十亿美元改进全球互联网的接通性。Google Fiber 要做的事已经演变成了对市场中传统电信服务提供商的打击，也就是那些为大半城市群提供千兆网络和电视服务的一方。 然而，Fiber 已经被部署光纤网络的成本困扰一段时间了，更不要提来自在位者的条例和法规难题了（Fiber 曾被指为 Alphabet「Other Bets」中最大的单项支出，Other Bets 是该集团对登月项目经济报告的涵盖性术语。）一旦资本支出自由流通，Fiber 如今正被邀请接受 Alphabet 的经济审查，8 月份来自高层的一份措辞严厉的要求就可见一般： Alphabet CEO 拉里·佩奇命令 Fiber 减少客户攫取成本到目前的 1/10，同时要求 Fiber 主管 Craig Barratt 砍掉一半职员，从 1000 到 500。 就像我们上面提到的，对 Webpass 的收购就像一剂药膏，直接缓和了这些损失。 其他项目包括谷歌的 Project Fi mobile virtual network operator（MVNO），谷歌称该项目是一项实验，动机是改进现任运营商。一个 MVNO，本质上也就是从无线和市场手机服务商那里购买带宽放到自己品牌、价位和支撑方案下面。 Link、Skybender 和 Loon 项目针对的是偏远地区和新兴市场的完全不同的人群，但这显然是「所有人都接入网络」理念的延展。和其它 X 单元一样，Loon 项目最近已经走出了 X，得到了来自 WildBlue 的行业老兵 Tom Moore 的领导，以推动该项目实现商业化。Loon 项目也利用了谷歌的机器学习之力，部署了能够优化气球的位置和方向的算法。 只要这些「登月项目」从 X 毕业，就很容易预想它们会被收纳到 Alphabet 的 Access &amp; Energy 的旗帜之下。有传言说这个 A&amp;E 单位将会换个新名字，但目前仍然还会包括 Alphabet 在能源方面的工作。Sunroof 项目是其中的一项计划，Makani 机载风力涡轮机（在 2013 年收购）如果成功，也是另一个自然的候选项目。 交通和物流谷歌自动驾驶汽车项目于 2010 年在 Google X 成立；其表现和公众知名度使之成为了 Google X 这个部门事实上的代言人。该公司已经相应地进行了投资，有传言说谷歌为这个长期项目准备了 100 亿美元。 就在 Alphabet 的重组之前，该项目也雇佣了自己的行业老兵——来自 Hyundai America 和 TrueCar 的 John Krafcik。这被广泛地解读成是使该项目正式实现独立的开始。在 4 月份的一个采访中，Astro Teller 将其描述成是「正在从 X 毕业的过程中」。（尽管 X 已经从谷歌分离，但该汽车项目目前仍然保留了原来的名字）。 事实上，这个谷歌汽车项目的测试场地已经从山景城扩展到了德克萨斯州、亚利桑那州和华盛顿州。在 5 月份时，它也与一家主要的汽车制造商（Fiat Chrysler）确定了首次合作关系，并且还在 7 月份引入了一个法律领导。 但是，一些长期的团队成员已经离开了这一项目。8 月份时候我们看到项目 CTO Chris Urmson 离开，一些工程师也离开了并创立了 Otto 和 Nuro.ai 等公司。随着其他玩家的加入，谷歌在这一领域的独特地位已经受到了挑战，正如我们 Trends 趋势工具对自动驾驶相关热点的跟踪那样： 在物流方面，Alphabet 有谷歌 Express 同日送达服务，这项服务在今年 2 月份已经扩展到生鲜杂货店。 在 X 旗下，还有 Wing 无人机项目，该项目最近和 Chipotle 进行了合作在弗吉尼亚理工测试卷饼送递服务。 和其它部门一样，这两个快递项目都是针对电子商务巨头亚马逊的无人机和其它物流项目的防御，以应对其对谷歌的产品搜索流量的威胁。它们也将 Alphabet 带入了与 Instacart、FreshDirect 和 Uber 的竞争中。我们已经将 Uber 评价为了自动驾驶和驾乘共享的有力竞争者。Wing 项目也与越来越多自动快递无人机创业公司形成了竞争关系。 医疗保健和数字健康正如我们所见，Bill Maris 领导的 GV 已经投资了很多医疗保健和数字健康领域的创业公司。尽管我们目前还不清楚在 GV 的新领导下，这个趋势是否还会继续，但 Alphabet 旗下已经有两个从事生命科学研究的分支机构了。 其中 Verify（即原来的谷歌生命科学（Google Life Sciences））自 2015 年 12 月以来启动很多项目，包括智能葡萄糖感应隐形眼镜、纳米诊断和用于抵抗震颤的 stabilized spoons（收购自 Lift Labs）。Verily 也与一些顶级的医疗保健品牌建立了合作，其中包括 Johnson &amp; Johnson（Verb Surgical）、GlaxoSmithKline（Galvani Bioelectronics）和 Dexcom（连续血糖监测）。 Verily 是另一个还没有明确的商业化规划的 Alphabet 部门。Verily 已经出现了人才流失的状况，一些人回到了谷歌的怀抱，一些人则成了竞争对手。充满怀疑的观察者也在质疑 Verily 项目的有效性和实用性，其中包括斯坦福大学疾病预防学教授。 人们需要搞明白这些玩意对于市场和公司的意义──一个新世界──或者我们正在谈论的东西将很快展现影响……后者是难以想象的。 同时 Calico 展现了登月哲学的真正精神，通过研究年龄基因和挑战衰老疾病来延长人类寿命。不同于 Alphabet 的其他分支，Calico 从集团外雇佣了医疗专家。在 2015 年 9 月，谷歌披露了这家分公司的预算达到了 24 亿美元，在必要的情况下可以增至 49 亿美元。 Calico 一直笼罩在谜团之中，它只有很少的具体产品，却更重视进行长期研究项目（Verily 在其基因研究中所言）。Calico 的网站内容简单，但仍然显示他们正与许多著名公司合作，包括 AbbVie，AncestryDNA，同时还有很多大学。 金融科技我们曾详细介绍了 Alphabet 突然切入金融科技领域，所以这里只是简要介绍一下。在投资领域，GV 和谷歌资本在科技金融的投资中占有重要地位。 保险技术是其中的焦点，Alphabet 在 2015 年中参与了至少 6 次这方面的合作与投资。这包括 Nest 与 American Family 的合作，和现在已经结束的 Google Compare，CoverHound 和 Compare.com 的伙伴关系。 今年六月，谷歌又宣布禁止在其所有网站上出现发薪日贷款的广告。在支付领域，谷歌停止了实物的 Google Wallet 卡服务，但仍在继续运营 Android Pay 平台。后者面临的竞争对手不仅是苹果，还包括 Android 授权的很多公司包括三星，他们也都在自己的手机上开发出了自己的支付平台。 结语总而言之，Alphabet 目前正在公司结构的转型期。公司的目标已经转变为面向更协调的目标和多元化的盈利。Alphabet 已经在努力使长期以来分工不甚明确的各个分支目标更加清晰。观察家和股东们都欢迎新的分支，硬件和软件团队，并满意公司专注于领导行业的目标。 当然，公司内部仍有冗余，大量 X 计划在过渡期间仍然存在。Alphabet 目前正将重心转向利润和商业潜力，同时以更为集中的方式应对竞争对手的挑战，它已选择了一个主要武器：人工智能。人工智能将是 Alphabet 在未来新市场中的杀手锏。但深耕人工智能是否能为谷歌带来成功仍有待观察。这主要取决于执行，以及人工智能的应用能否在运输，云服务，医疗和消费级硬件等各项领域中同时展现出竞争力。 ✄ ———————————————————————© 本文由机器之心编译，转载请联系微信公众号获得授权。✄ ———————————————————————","categories":[],"tags":[{"name":"Google","slug":"Google","permalink":"http://github.com/tags/Google/"}],"keywords":[]},{"title":"深入了解Android Studio和Gradle","slug":"深入了解Android Studio和Gradle","date":"2016-10-18T09:08:00.000Z","updated":"2016-10-18T10:07:30.387Z","comments":true,"path":"2016/10/18/深入了解Android Studio和Gradle/","link":"","permalink":"http://github.com/2016/10/18/深入了解Android Studio和Gradle/","excerpt":"原文链接： 重新认识AndroidStudio和Gradle，这些都是我们应该知道的 — by 井方哥 前言主要从AndroidStudio的环境安装升级，Gradle，Eclipse转AS,多渠道配置，Maven私服，Action,Option，快捷键等几个方面出发，讲一些操作技巧以及我对AndroidStudio使用的一些理解与经验。本文较全面的讲述了我们在开发中必须要了解的，比较多而全，可能不能马上记住，目的在于大家看我之后能有一个认识，在需要使用的时候知道有这么个东西。希望对你的开发工作有所帮助，不足之处，请批评指正。 一、Install&amp;Settings&amp;Update1、GradleGradle官方会不断更新，我们可以使用本地安装的方式，并配置path，我们就可以使用Terminal直接输入gradle命令执行构建任务。当然如果我们想快速更新，可以修改配置文件。 首先，修改project\\gradle\\warpper\\gradle-wapper.properties 文件，其中distributionUrl的值： 1distributionUrl=https\\://services.gradle.org/distributions/gradle-2.4-all.zip 这里实际是从网络下载配置的版本，会自动检测，如果不是的就会下载。 然后修改 project的build.gradle 123456dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125;","text":"原文链接： 重新认识AndroidStudio和Gradle，这些都是我们应该知道的 — by 井方哥 前言主要从AndroidStudio的环境安装升级，Gradle，Eclipse转AS,多渠道配置，Maven私服，Action,Option，快捷键等几个方面出发，讲一些操作技巧以及我对AndroidStudio使用的一些理解与经验。本文较全面的讲述了我们在开发中必须要了解的，比较多而全，可能不能马上记住，目的在于大家看我之后能有一个认识，在需要使用的时候知道有这么个东西。希望对你的开发工作有所帮助，不足之处，请批评指正。 一、Install&amp;Settings&amp;Update1、GradleGradle官方会不断更新，我们可以使用本地安装的方式，并配置path，我们就可以使用Terminal直接输入gradle命令执行构建任务。当然如果我们想快速更新，可以修改配置文件。 首先，修改project\\gradle\\warpper\\gradle-wapper.properties 文件，其中distributionUrl的值： 1distributionUrl=https\\://services.gradle.org/distributions/gradle-2.4-all.zip 这里实际是从网络下载配置的版本，会自动检测，如果不是的就会下载。 然后修改 project的build.gradle 123456dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125; 注意：这两个配置是一一对应的，比如gradle-2.4-all对应的就是1.3.0。后者的意思是这个project配置的gradle构建版本为1.3.0，前者的意思是这个project使用的gradle的版本为2.4。我们会发现，如果我们修改前者，如果本地没有安装这个版本的gradle，会自动从gradle官网下载。但是，如果我们修改后者，它会自动从jcenter()仓库下载一些plugin之类的。 2、AS具体的安装和更新网上有许多的详细教程，我只想说以下三点。 Android Studio是Google官方基于IntelliJ IDEA开发的一款Android应用开发工具,绝逼比Eclipse强大，还没有转的尽快吧: 关闭AndroidStudio的自检升级，如果准备好升级还是自己选择想升级的版本升级靠谱； 升级前导出AndroidStudio的配置文件settings.jar(C:\\Users\\Administrator.AndroidStudio1.4\\config目录下，或者操作File|Export Setings导出)，升级后导入Settings.jar，这样就不需要重新配置，有必要的话给自己备份一个，说不定老天无缘无故挂了重装很方便。 具体细节的配置可以阅读，强烈建议直接打开AS的设置窗口，多转几次就熟悉了里边的各种配置啦。也可以参考这边文章，（1.4版本，有点旧了，差不多够用）打造你的开发工具，settings必备 二、Gradle1 简述Groovy语言Groovy是一种开发语言，是在Java平台上的，具有向Python，Ruby语言特性的灵活动态语言,Groovy保重了这些特性像Java语法一样被Java开发者使用。编译最终都会转成java的.class文件。他们的关系如下图。我想这大概也是Gradle构建系统为什么要选择Groovy的原因，它具有java语言的特性，开发者容易理解使用。一定要明白我们在build.gradle里边不是简单的配置，而是直接的逻辑开发。如果你熟练掌握Groovy，那么你在build.grale里边可以做任何你想做的事。 2 Gradle编程框架Gradle是一个工具，同时它也是一个编程框架。使用这个工具可以完成app的编译打包等工作，也可以干别的工作！Gradle里边有许多不同的插件，对应不同的工程结构、打包方式和输出文件类型。我们经常使用到的便是maven\\java\\com.android.application\\android-library等。当按照要求配置好gradle的环境后，执行gradle的task，便会自动编译打包输出你想要的.apk.aar.jar文件,如果你足够牛逼，你有gradle就够了，直接拿记事本开发； 如下图，是Gradle的工作流程。 Initializtion 初始化，执行settings.gradle(我们看到都是include”,实际里边可深了） Hook 通过API来添加，这中间我们可以自己编程干些自己想做的事情 Configuration 解析每个project的build.gradle，确定project以及内部Task关系，形成一个有向图 Execution 执行任务，输入命令 gradle xxx ,按照顺序执行该task的所有依赖以自己本身 3 关于gradle的task每个构建由一个或者多个project构成，一个project代表一个jar，一个moudle等等。一个project包含若干个task，包含多少由插件决定，而每一个task就是更细的构建任务，比如创建一个jar、生成Javadoc、上传aar到maven仓库。我们可以通过执行如下命令查看所有的task: 1gradle tasks --all 当然，我们也可以在AS中可以看到所有的task，双击就可以执行单个的task. 当然，我们也可以在build.gradle中写自己的task。关于详细的task介绍可以查看网络资料进行学习，推荐Gradle入门系列，基本花上半天到一天的时候简单的过一遍就有一个大概的了解。 4 Gradle环境下Android的文件结构 project-name gradle module-name build //构建生成文件 intermediates//构建打包的资源文件 assets//资源文件 exploded-aar//如果我们依赖了许多的aar或者依赖工程，最终都“copy”到了这个目录下 mainfests//合并的mainfest outputs apk//输出我们需要的.apk文件 lint-results.html//lint检查报告 reports tests//单元测试报告 ivy.xml//moudle的配置（task任务）、依赖关系等 libs //本地的依赖jar包等 src //本moudule所有的代码和资源文件 androidTest //需要android环境的单元测试，比如UI的单元测试 Test //普通的java单元测试 main //主渠道 java //java code jni //navtive jni so gen res assets AndroidManifest.xml +build.gradle //module build.gradle // for all module gradle.propeties //全局配置文件 local.properties //SDK、NDK配置 config.gradle//自定义的配置文件 settings.gradle//module管理 6 关于几个buid.gradle、gradle.propeties文件 build.gradle文件(主工程的Top-level) 12345678910111213141516171819apply from:\"config.gradle\"//可以给所有的moudle引入一个配置文件buildscript &#123; repositories &#123; jcenter()&#125;dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter()//引入远程仓库 maven &#123; url MAVEN_URL &#125;//引入自己的私有maven仓库 &#125;&#125; gradle.properties(全局配置文件） 1234567# This can really make a significant difference if you are building a very complex project with many sub-module dependencies:#sub-moudle并行构建org.gradle.parallel=true#后台进程构建org.gradle.daemon=true#私有maven仓库地址MAVEN_URL= http://xxx.xx.1.147:8081/nexus/content/repositories/thirdparty/ build.gradle(module) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647apply plugin: 'com.android.application'//插件 决定是apk\\aar\\jar等android &#123;compileSdkVersion 23buildToolsVersion \"24.0.0\"// 此处注释保持默认打开，关闭后可使不严格的图片可以通过编译,但会导致apk包变大//aaptOptions.cruncherEnabled = false//aaptOptions.useNewCruncher = false packagingOptions &#123; exclude 'META-INF/NOTICE.txt'// 这里是具体的冲突文件全路径 exclude 'META-INF/LICENSE.txt'&#125;//默认配置defaultConfig &#123; applicationId \"com.locove.meet\" minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName \"1.0\" multiDexEnabled=true//65536问题&#125;sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs']//重新配置路径 &#125;&#125;buildTypes &#123; release &#123; // zipAlign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources false // 混淆 minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.releaseConfig &#125;&#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.google.code.gson:gson:2.2.+' testCompile 'junit:junit:4.12'&#125; 7 gradle编译文件和缓存文件 gradle缓存文件：C:\\Users\\Administrator.gradle\\caches\\modules-2\\files-2.1 idea缓存文件： C:\\Users\\Administrator.AndroidStudio1.4 三、构建过程简析这里参考了QQ音乐技术团队Android构建过程分析 下图是文章末尾的一张构建流程图： 解压合并资源： 主要是assets目录，res目录，Androidmainfest.xml目录。其中合并的时候会涉及到优先级的问题，详情请查看该篇文章。 AAPT(Android Asset Packaging Tool)打包 R.java文件 资源ID app.ap 压缩包 对png图进行优化等 源码编译： 生成.class字节码，在这里可以进行删除无用类，字节码优化，重命名（包名），还有一点就是代码混淆。 生成dex、打包签名、zipalign","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Hiker Guide","slug":"Hiker中文使用教程","date":"2016-10-17T07:47:20.000Z","updated":"2016-10-25T03:55:53.303Z","comments":true,"path":"2016/10/17/Hiker中文使用教程/","link":"","permalink":"http://github.com/2016/10/17/Hiker中文使用教程/","excerpt":"Hiker An attractive, exquisite theme for Hexo. named “Hiker”, short for “HikerNews”. ☞ Live Preview | Hiker 中文版使用文档","text":"Hiker An attractive, exquisite theme for Hexo. named “Hiker”, short for “HikerNews”. ☞ Live Preview | Hiker 中文版使用文档 Installation Get it from GitHub 1$ git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker Enable Modify theme setting in _config.yml to hiker. 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hiker Update 12$ cd themes/Hiker$ git pull ConfigurationTheme configuration example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Header Menumenu: Home: / Archives: archives Categories: categories Tags: tags About: aboutrss: /atom.xmlsince: 2013# Set default keywords (Use a comma to separate)keywords: \"\"# Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.avatar: css/images/mylogo.jpg# Homepage# eg. home_background_image: css/images/home-bg.jpghome_background_image: css/images/home-bg.jpghome_logo_image: enable: false border: false url: css/images/homelogo.jpg# AboutPage backgroundabout_big_image: css/images/pose.jpg# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- category- tag- tagcloud- archive- recent_posts# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname:# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default# Article theme color# Available value:# random | orange | blue | red | green | blacktheme_color: random# display widgets at the bottom of index pages (pagination == 2)index_widgets:# - category# - tagcloud# - archive# widget behaviorarchive_type: 'monthly'show_count: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification:baidu_site_verification:qihu_site_verification:# Miscellaneousgoogle_analytics:gauges_analytics:twitter:google_plus:fb_admins:fb_app_id: menu - Navigation menu rss - RSS link excerpt_link - “Read More” link at the bottom of excerpted articles. false to hide the link. fancybox - Enable Fancybox sidebar - Sidebar style. You can choose left, right, bottom or false. widgets - Widgets displaying in sidebar google_analytics - Google Analytics ID favicon - Favicon path twitter - Twiiter ID google_plus - Google+ ID FeaturesHomepage backgroundYou could place the image file in YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images directory. and modify home_background_image in hiker/_config.yml. 123# Homepage# eg. home_background_image: css/images/home-bg.jpghome_background_image: css/images/home-bg.jpg If you DON’T want any image as your homepage background, just set home_background_image empty in hiker/_config.yml, then you have an default homepage with random decorative pattern. Code Highlight ThemeHiker use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hiker/_config.yml. 12345# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default Blog Theme ColorHiker provide five color themes for your blog. orange blue red green black You can modify theme_color in hiker/_config.yml. 1234# Article theme color# Available value:# random | orange | blue | red | green | blacktheme_color: random Night modeJust for article reading. In article page, you can click the logo image of header to switch to Night mode. FancyboxHiker uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hiker provides 5 built-in widgets: category tag tagcloud archives recent_posts All of them are enabled by default. You can edit them in widget setting. Comment supportHiker has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to hiker hiker/_config.yml: 123# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/tags/Hexo/"}],"keywords":[]},{"title":"Chrome自带的开发者工具进阶技巧","slug":"Chrome自带的开发者工具进阶技巧","date":"2016-09-28T10:50:00.000Z","updated":"2016-10-18T06:45:25.373Z","comments":true,"path":"2016/09/28/Chrome自带的开发者工具进阶技巧/","link":"","permalink":"http://github.com/2016/09/28/Chrome自带的开发者工具进阶技巧/","excerpt":"原文链接： Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain Chrome自带开发者工具。它的功能十分丰富，包括元素、网络、安全等等。今天我们主要介绍JavaScript控制台部分的功能。 我最早写代码的时候，也就是在JS控制台里输出一些服务器返回的内容，或者一些变量的值。但是后来通过一些深入的学习和了解，我发现Chrome的JS控制台原来还有这么多神奇的功能。 在这里我总结了一些特别有用的功能。要是你凑巧在Chrome里浏览这篇文章的话，现在就打开开发者工具，跟着随手试试吧！ 1.选取DOM元素要是你用过两天jQuery的话，一定对 $(&#39;.className&#39;) 或者 $(&#39;#id&#39;) 这种选择器不会陌生。上面这俩货分别是jQuery的类选择器和ID选择器。 在一个网页没有引入jQuery的情况下，在控制台里你也可以通过类似的方法选取DOM. 不管 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;) 还是 $(&#39;.class #id&#39;) 等类似的选择器，都相当于原生JS的document.querySelector(&#39;&#39;) 方法。这个方法返回第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;) 记得是两个\\$\\$符号来选择所有匹配规则的DOM元素。选择返回的结果是一个数组，可以通过数组的方法来访问其中的单个元素。 举个栗子 $$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。","text":"原文链接： Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain Chrome自带开发者工具。它的功能十分丰富，包括元素、网络、安全等等。今天我们主要介绍JavaScript控制台部分的功能。 我最早写代码的时候，也就是在JS控制台里输出一些服务器返回的内容，或者一些变量的值。但是后来通过一些深入的学习和了解，我发现Chrome的JS控制台原来还有这么多神奇的功能。 在这里我总结了一些特别有用的功能。要是你凑巧在Chrome里浏览这篇文章的话，现在就打开开发者工具，跟着随手试试吧！ 1.选取DOM元素要是你用过两天jQuery的话，一定对 $(&#39;.className&#39;) 或者 $(&#39;#id&#39;) 这种选择器不会陌生。上面这俩货分别是jQuery的类选择器和ID选择器。 在一个网页没有引入jQuery的情况下，在控制台里你也可以通过类似的方法选取DOM. 不管 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;) 还是 $(&#39;.class #id&#39;) 等类似的选择器，都相当于原生JS的document.querySelector(&#39;&#39;) 方法。这个方法返回第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;) 记得是两个\\$\\$符号来选择所有匹配规则的DOM元素。选择返回的结果是一个数组，可以通过数组的方法来访问其中的单个元素。 举个栗子 $$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。 2.一秒钟让Chrome变成所见即所得的编辑器你可能经常会困惑你到底能不能直接在浏览器里更改网页的文本内容。答案是肯定的，你可以只通过一行简单的指令把Chrome变成所见即所得的编辑器，直接在网页上随心所欲地删改文字。 你不需要再傻傻地右键审查元素，编辑源代码了。打开Chrome的开发者控制台，输入 1document.body.contentEditable=true 然后奇迹就发生啦，你竟然可以在网页里直接编辑，或者随意拖动图片的位置了！要是你正在用Chrome现在就可以试试！ 3.获取某个DOM元素绑定的事件在调试的时候，你肯定需要知道某个元素上面绑定了什么触发事件。Chrome的开发者控制台可以让你很轻松地找到它们。 getEventListeners($(&#39;selector&#39;)) 方法以数组对象的格式返回某个元素绑定的所有事件。你可以在控制台里展开对象查看详细的内容。 要是你需要选择其中的某个事件，可以通过下面的方法来访问： 1getEventListeners($('selector')).eventName[0].listener 这里的 eventName 表示某种事件类型，例如： 1getEventListeners($('#firstName')).click[0].listener 上面的例子会返回ID为 firstName 元素绑定的click事件。 4.监测事件当你需要监视某个DOM触发的事件时，也可以用到控制台。例如下面这些方法： monitorEvents($(&#39;selector&#39;)) 会监测某个元素上绑定的所有事件，一旦该元素的某个事件被触发就会在控制台里显示出来。 monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;) 可以监听某个元素上绑定的具体事件。第二个参数代表事件类型的名称。例如 monitorEvents($(&#39;#firstName&#39;),&#39;click&#39;) 只监测ID为firstName的元素上的click事件。 monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….]) 同上。可以同时检测具体指定的多个事件类型。 unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 5.用计时器来获取某段代码块的运行时间通过 console.time(‘labelName’) 来设定一个计时器，其中的 labelName 是计时器的名称。通过console.timeEnd(‘labelName’) 方法来停止并输出某个计时器的时间。例如： 1234console.time('myTime'); //设定计时器开始 - myTimeconsole.timeEnd('mytime'); //结束并输出计时时长 - myTime//输出: myTime:123.00 ms 再举一个通过计时器来计算代码块运行时间的例子： 123456789console.time('myTime'); //开始计时 - myTimefor(var i=0; i &lt; 100000; i++)&#123; 2+4+5;&#125;console.timeEnd('mytime'); //结束并输出计时时长 - myTime//输出 - myTime:12345.00 ms 6.以表格的形式输出数组假设我们有一个像下面这样的数组： 1var myArray=[&#123;a:1,b:2,c:3&#125;,&#123;a:1,b:2,c:3,d:4&#125;,&#123;k:11,f:22&#125;,&#123;a:1,b:2,c:3&#125;] 要是你直接在控制台里输入数组的名称，Chrome会以文本的形式返回一个数组对象。但你完全可以通过console.table(variableName) 方法来以表格的形式输出每个元素的值。例如下图： 7.通过控制台方法来检查元素你可以直接在控制台里输入下面的方法来检查元素 inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。例如 inspect($(&#39;#firstName&#39;)) 选择所有ID是 firstName 的元素，inspect($(&#39;a&#39;)[3]) 检查并返回页面上第四个 p元素。\\$0, \\$1, \\$2等等会返回你最近检查过的几个元素，例如 \\$0 会返回你最后检查的元素，\\$1 则返回倒数第二个。 8.列出某个元素的所有属性你也可以通过控制台列出某个元素的所有属性： dir($(‘selector’)) 会返回匹配选择器的DOM元素的所有属性，你可以展开输出的结果查看详细内容。 9.获取最后计算结果的值你可以把控制台当作计算器使用。当你在Chrome控制台里进行计算时，可以通过$_来获取最后的计算结果值，还是直接看例子吧： 12345678910111213142+3+49 //- The Answer of the SUM is 9$_9 // Gives the last Result$_ * $_81 // As the last Result was 9Math.sqrt($_)9 // As the last Result was 81$_9 // As the Last Result is 9 10.清空控制台输出当你需要这么做的时候，只需要输入 clear() 然后回车就好啦！ Chrome开发者工具的强大远远超出你的想象！这只是其中的一部分小技巧而已，希望能够帮到你！","categories":[],"tags":[{"name":"WebDevelopment","slug":"WebDevelopment","permalink":"http://github.com/tags/WebDevelopment/"}],"keywords":[]},{"title":"【Android】抽象布局 — include、merge 、ViewStub","slug":"【Android】抽象布局 — include、merge 、ViewStub","date":"2016-09-19T03:47:00.000Z","updated":"2016-10-18T04:55:28.728Z","comments":true,"path":"2016/09/19/【Android】抽象布局 — include、merge 、ViewStub/","link":"","permalink":"http://github.com/2016/09/19/【Android】抽象布局 — include、merge 、ViewStub/","excerpt":"在布局优化中，Androi的官方提到了这三种布局&lt;include/&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 一、布局重用&lt;include/&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下： 123456789101112131415&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; &lt;/LinearLayout&gt;","text":"在布局优化中，Androi的官方提到了这三种布局&lt;include/&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 一、布局重用&lt;include/&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下： 123456789101112131415&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; &lt;/LinearLayout&gt; 1) &lt;include /&gt;标签必须使用单独的layout属性。 2) 可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖。 3) 在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。 4) 布局中可以包含两个相同的include标签，引用时可以使用如下方法解决 比如这个布局文件：123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"android:layout_width=\"fill_parent\"android:layout_height=\"fill_parent\"android:scrollbars=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:orientation=\"vertical\" android:padding=\"10dip\" &gt; &lt;include android:id=\"@+id/discovered_servers\" layout=\"@layout/discovered_servers_element\" /&gt; &lt;include android:id=\"@+id/bookmarks\" layout=\"@layout/bookmarks_element\" /&gt; //注意以下这个include和上面的include &lt;include android:id=\"@+id/bookmarks_favourite\" layout=\"@layout/bookmarks_element\" /&gt; &lt;include android:id=\"@+id/new_conn\" layout=\"@layout/new_conn_element\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 这里我们include了两次res/layout/bookmarks_element.xml，这个子布局内容如下： 123456789101112131415161718192021&lt;!-- res/layout/bookmarks_element.xml 布局 --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;TextView android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:paddingBottom=\"10dip\" android:paddingTop=\"10dip\" android:text=\"@string/bookmarks\" android:textAppearance=\"?android:attr/textAppearanceLarge\" /&gt; &lt;LinearLayout android:id=\"@+id/bookmarks_list\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:padding=\"10dip\" /&gt;&lt;/merge&gt; 如果向下面这样调用是错的， 1LinearLayout fav_bookmarks = findViewById(R.id.bookmarks_list); // WRONG!!!! 正确的方法是这样： 123View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite); bookmarks_container_2.findViewById(R.id.bookmarks_list); 二、减少视图层级&lt;merge/&gt;&lt;merge /&gt;标签用于减少View树的层次来优化Android的布局。先来用个例子演示一下： 首先主需要一个配置文件activity_main.xml 1234567891011&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt;&lt;/RelativeLayout&gt; 再来一个最简单的Activity，文件名MainActivity.java 12345678910111213package com.example.merge;import android.app.Activity;import android.os.Bundle;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 按着上面的代码创建工程，运行后使用“DDMS -&gt; Dump View Hierarchy for UI Automator”工具，截图如下: merge 使用前： 最下面两层RelativeLayout与TextView就是 activity_main.xml 布局中的内容，上面的FrameLayout是Activity setContentView添加的顶层视图。下面使用merge标签可以查看下区别。 布局文件 activity_main.xml 修改内容如下： 1234567891011&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt;&lt;/merge&gt; 使用“DDMS -&gt; Dump View Hierarchy for UI Automator”工具，截图如下: merge 使用后 可以看到，FrameLayout下面直接就是TextView，与之前的相比少了一层 RelativeLayout 而实现的效果相同。 那么，什么情况考虑使用&lt;merge /&gt;标签？ 一种是向上面的例子一样，子视图不需要指定任何针对父视图的布局属性，例子中TextView仅仅需要直接添加到父视图上用于显示就行。 另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题，官方文档 Android Layout Tricks #3: Optimize by merging 中的例子演示的就是这种情况。 &lt;merge /&gt;标签有什么限制没？ &lt;merge /&gt;只能作为XML布局的根标签使用。 当 Inflate 以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。 三、需要时使用&lt;ViewStub /&gt;限于篇幅，这里只大概总结一下ViewStub的使用方法，详细介绍和使用写到后面的文章中。 &lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下： 1234567&lt;ViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/panel_import\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法： 1((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); or 1View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。 注：ViewStub 目前有个缺陷就是还不支持 &lt;merge /&gt; 标签。 更多&lt;ViewStub /&gt;标签介绍可以参考官网教程《Android Layout Tricks #3: Optimize with stubs》 【参考资料】： 1、Android抽象布局 — include、merge 、ViewStub2、Tech Stuff: Android &lt;include/&gt; layout pitfalls3、Android 性能优化 四 布局优化merge标签的使用4、Android之merge布局5、 Android实战技巧：ViewStub的应用","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】设计模式：深入理解单例模式","slug":"【Java】设计模式：深入理解单例模式","date":"2016-09-08T06:18:20.000Z","updated":"2016-10-18T04:56:48.874Z","comments":true,"path":"2016/09/08/【Java】设计模式：深入理解单例模式/","link":"","permalink":"http://github.com/2016/09/08/【Java】设计模式：深入理解单例模式/","excerpt":"什么是设计模式？简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，今天就先来分享下最常用的单例模式。 引言对于单例模式，有工作经验的人基本上都使用过。面试的时候提到设计模式基本上都会提到单例模式，但是很多人对单例模式也是一知半解，当然也包括我哈哈哈=_=。所以我们有必要深入理解一下所谓的「单例模式」。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式结构图： 使用单例的优点： 单例类只有一个实例 共享资源，全局使用 节省创建时间，提高性能","text":"什么是设计模式？简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，今天就先来分享下最常用的单例模式。 引言对于单例模式，有工作经验的人基本上都使用过。面试的时候提到设计模式基本上都会提到单例模式，但是很多人对单例模式也是一知半解，当然也包括我哈哈哈=_=。所以我们有必要深入理解一下所谓的「单例模式」。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式结构图： 使用单例的优点： 单例类只有一个实例 共享资源，全局使用 节省创建时间，提高性能 它的七种写法单例模式有多种写法各有利弊，现在我们来看看各种模式写法。 1、饿汉式12345678public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 这种方式和名字很贴切，饥不择食，在类装载的时候就创建，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。 Java Runtime就是使用这种方式，它的源代码如下： 1234567891011121314151617181920public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don't let anyone else instantiate this class */ private Runtime() &#123;&#125; //以下代码省略&#125; 总结：「饿汉式」是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用「饿汉式」的单例模式就是不合适的，这时候就需要用到「懒汉式」的方式去按需延迟加载单例。 2、懒汉式（非线程安全）1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。在多线程访问的时候，很可能会造成多次实例化，就不再是单例了。 「懒汉式」与「饿汉式」的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用「懒汉式」就是非常不错的选择。 3、懒汉式（线程安全）1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这两种「懒汉式」单例，名字起的也很贴切，一直等到对象实例化的时候才会创建，确实够懒，不用鞭子抽就不知道走了，典型的时间换空间，每次获取实例的时候才会判断，看是否需要创建，浪费判断时间，如果一直没有被使用，就不会被创建，节省空间。 因为这种方式在getInstance()方法上加了同步锁，所以在多线程情况下会造成线程阻塞，把大量的线程锁在外面，只有一个线程执行完毕才会执行下一个线程。 Android中的 InputMethodManager 使用了这种方式，我们看看它的源码： 1234567891011121314151617181920public final class InputMethodManager &#123; static InputMethodManager sInstance; /** * Retrieve the global InputMethodManager instance, creating it if it * doesn't already exist. * @hide */ public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 4、双重校验锁（DCL）上面的方法「懒汉式（线程安全）」毫无疑问存在性能的问题 — 如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码，就成了下面的双重校验锁（Double Check Lock）： 123456789101112131415161718192021public class Singleton &#123; /** * 注意此处使用的关键字 volatile， * 被volatile修饰的变量的值，将不会被本地线程缓存， * 所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 */ private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这种写法在getSingleton()方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，不了解volatile关键字的可以查看 Java多线程（三）volatile域 和 java中volatile关键字的含义 两篇文章，可以看到双重检查模式是正确使用volatile关键字的场景之一。 「双重校验锁」：既可以达到线程安全，也可以使性能不受很大的影响，换句话说在保证线程安全的前提下，既节省空间也节省了时间，集合了「饿汉式」和两种「懒汉式」的优点，取其精华，去其槽粕。 对于volatile关键字，还是存在很多争议的。由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 还有就是在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java1.5及以上的版本。 5、静态内部类另外，在很多情况下JVM已经为我们提供了同步控制，比如： 在static {...}区块中初始化的数据 访问final字段时 因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现「懒汉式」的延迟加载和线程安全。 12345678910public class Singleton &#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125; &#125; 第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。 然而这还不是最简单的方式，《Effective Java》中作者推荐了一种更简洁方便的使用方式，就是使用「枚举」。 6、枚举《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 12345678public enum Singleton &#123; //定义一个枚举的元素，它就是 Singleton 的一个实例 INSTANCE; public void doSomeThing() &#123; // do something... &#125; &#125; 使用方法如下： 1234public static void main(String args[]) &#123; Singleton singleton = Singleton.instance; singleton.doSomeThing();&#125; 枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。 7. 使用容器12345678910111213public class SingletonManager &#123; private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;(); private Singleton() &#123; &#125; public static void registerService(String key, Objectinstance) &#123; if (!objMap.containsKey(key) ) &#123; objMap.put(key, instance) ; &#125; &#125; public static ObjectgetService(String key) &#123; return objMap.get(key) ; &#125;&#125; 这种事用SingletonManager 将多种单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。 总结对于以上七种单例，分别是「饿汉式」、「懒汉式(非线程安全)」、「懒汉式(线程安全)」、「双重校验锁」、「静态内部类」、「枚举」和「容器类管理」。很多时候取决人个人的喜好，虽然双重检查有一定的弊端和问题，但我就是钟爱双重检查，觉得这种方式可读性高、安全、优雅（个人观点）。所以代码里常常默写这样的单例，写的时候真感觉自己是个伟大的建筑师哈哈哈哈（真不要脸(￢_￢)（逃。 【参考资料】：1、Android设计模式之单例模式2、十分钟认识单例模式的多种姿势3、设计模式（二）单例模式的七种写法4、深入Java单例模式5、java中volatile关键字的含义","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://github.com/categories/Design-Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://github.com/categories/Design-Pattern/"}]},{"title":"【Go语言】基本类型排序和 slice 排序","slug":"【Go语言】基本类型排序和 slice 排序","date":"2016-09-07T08:36:00.000Z","updated":"2016-10-18T04:56:08.221Z","comments":true,"path":"2016/09/07/【Go语言】基本类型排序和 slice 排序/","link":"","permalink":"http://github.com/2016/09/07/【Go语言】基本类型排序和 slice 排序/","excerpt":"Go 是通过 sort 包提供排序和搜索，因为 Go 暂时不支持泛型（将来也不好说支不支持），所以，Go 的 sort 和 search 使用起来跟类型是有关的，或是需要像 c 一样写比较函数等，稍微显得也不是很方便。 引言 Go 的排序思路和 C 和 C++ 有些差别。 C 默认是对数组进行排序， C++ 是对一个序列进行排序， Go 则更宽泛一些，待排序的可以是任何对象， 虽然很多情况下是一个 slice (分片， 类似于数组)，或是包含 slice 的一个对象。 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； 乍一看条件 3 是多余的， c 和 c++ 都不提供 swap 。 c 的 qsort 的用法： qsort(data, n, sizeof(int), cmp_int); data 是起始地址， n 是元素个数， sizeof(int) 是每个元素的大小， cmp_int 是一个比较两个 int 的函数。 c++ 的 sort 的用法： sort(data, data+n, cmp_int); data 是第一个元素的位置， data+n 是最后一个元素的下一个位置， cmp_int 是比较函数。","text":"Go 是通过 sort 包提供排序和搜索，因为 Go 暂时不支持泛型（将来也不好说支不支持），所以，Go 的 sort 和 search 使用起来跟类型是有关的，或是需要像 c 一样写比较函数等，稍微显得也不是很方便。 引言 Go 的排序思路和 C 和 C++ 有些差别。 C 默认是对数组进行排序， C++ 是对一个序列进行排序， Go 则更宽泛一些，待排序的可以是任何对象， 虽然很多情况下是一个 slice (分片， 类似于数组)，或是包含 slice 的一个对象。 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； 乍一看条件 3 是多余的， c 和 c++ 都不提供 swap 。 c 的 qsort 的用法： qsort(data, n, sizeof(int), cmp_int); data 是起始地址， n 是元素个数， sizeof(int) 是每个元素的大小， cmp_int 是一个比较两个 int 的函数。 c++ 的 sort 的用法： sort(data, data+n, cmp_int); data 是第一个元素的位置， data+n 是最后一个元素的下一个位置， cmp_int 是比较函数。 基本类型排序(int、float64 和 string)1、升序排序对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。 12345678910111213141516171819package main import ( \"fmt\" \"sort\") func main() &#123; intList := [] int &#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := [] float64 &#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := [] string &#123;\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"&#125; sort.Ints(intList) sort.Float64s(float8List) sort.Strings(stringList) fmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList) &#125; 2、降序排序int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。 go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写： 123456789101112131415161718package main import ( \"fmt\" \"sort\") func main() &#123; intList := [] int &#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := [] float64 &#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := [] string &#123;\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"&#125; sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(float8List))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)&#125; 3、深入理解排序sort 包中有一个 sort.Interface 接口，该接口有三个方法 Len() 、 Less(i,j) 和 Swap(i,j) 。 通用排序函数 sort.Sort 可以排序任何实现了 sort.Inferface 接口的对象(变量)。对于 [] int 、[] float64 和 [] string 除了使用特殊指定的函数外，还可以使用改装过的类型 IntSclice 、 Float64Slice 和 StringSlice ， 然后直接调用它们对应的 Sort() 方法；因为这三种类型也实现了 sort.Interface 接口， 所以可以通过 sort.Reverse 来转换这三种类型的 Interface.Less 方法来实现逆向排序， 这就是前面最后一个排序的使用。 下面使用了一个自定义(用户定义)的 Reverse 结构体， 而不是 sort.Reverse 函数， 来实现逆向排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package main import ( \"fmt\" \"sort\") // 自定义的 Reverse 类型type Reverse struct &#123; sort.Interface // 这样，Reverse可以接纳任何实现了sort.Interface的对象&#125; // Reverse 只是将其中的 Inferface.Less 的顺序对调了一下func (r Reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i)&#125; func main() &#123; ints := []int&#123;5, 2, 6, 3, 1, 4&#125; sort.Ints(ints) // 特殊排序函数，升序 fmt.Println(\"after sort by Ints:\\t\", ints) doubles := []float64&#123;2.3, 3.2, 6.7, 10.9, 5.4, 1.8&#125; sort.Float64s(doubles) fmt.Println(\"after sort by Float64s:\\t\", doubles) // [1.8 2.3 3.2 5.4 6.7 10.9] strings := []string&#123;\"hello\", \"good\", \"students\", \"morning\", \"people\", \"world\"&#125; sort.Strings(strings) fmt.Println(\"after sort by Strings:\\t\", strings) // [good hello mornig people students world] ipos := sort.SearchInts(ints, -1) // int 搜索 fmt.Printf(\"pos of 5 is %d th\\n\", ipos) dpos := sort.SearchFloat64s(doubles, 20.1) // float64 搜索 fmt.Printf(\"pos of 5.0 is %d th\\n\", dpos) fmt.Printf(\"doubles is asc ? %v\\n\", sort.Float64sAreSorted(doubles)) doubles = []float64&#123;3.5, 4.2, 8.9, 100.98, 20.14, 79.32&#125; // sort.Sort(sort.Float64Slice(doubles)) // float64 排序方法 2 // fmt.Println(\"after sort by Sort:\\t\", doubles) // [3.5 4.2 8.9 20.14 79.32 100.98] (sort.Float64Slice(doubles)).Sort() // float64 排序方法 3 fmt.Println(\"after sort by Sort:\\t\", doubles) // [3.5 4.2 8.9 20.14 79.32 100.98] sort.Sort(Reverse&#123;sort.Float64Slice(doubles)&#125;) // float64 逆序排序 fmt.Println(\"after sort by Reversed Sort:\\t\", doubles) // [100.98 79.32 20.14 8.9 4.2 3.5]&#125; sort.Ints / sort.Float64s / sort.Strings 分别来对整型/浮点型/字符串型slice进行排序。然后是有个测试是否有序的函数。还有分别对应的 search 函数，不过，发现搜索函数只能定位到如果存在的话的位置，不存在的话，位置是不对的。 关于一般的数组排序，程序中显示了，有 3 种方法！目前提供的三种类型 int，float64 和 string 呈现对称的，也就是你有的，对应的我也有。关于翻转排序或是逆向排序，就是用个翻转结构体，重写 Less() 函数即可。上面的 Reverse 是个通用的结构体。 上面说了那么多， 只是对基本类型进行排序， 该到说说 struct 结构体类型的排序的时候了， 实际中这个用得到的会更多。 结构体类型的排序结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。 1、模拟 IntSlice 排序123456789101112131415161718192021222324252627282930313233343536373839404142package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; // 按照 Person.Age 从大到小排序type PersonSlice [] Person func (a PersonSlice) Len() int &#123; // 重写 Len() 方法 return len(a)&#125;func (a PersonSlice) Swap(i, j int)&#123; // 重写 Swap() 方法 a[i], a[j] = a[j], a[i]&#125;func (a PersonSlice) Less(i, j int) bool &#123; // 重写 Less() 方法， 从大到小排序 return a[j].Age &lt; a[i].Age&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonSlice(people)) // 按照 Age 的逆序排序 fmt.Println(people) sort.Sort(sort.Reverse(PersonSlice(people))) // 按照 Age 的升序排序 fmt.Println(people) &#125; 这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。 这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。 2、封装成 Wrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; //注意此处 people [] Person by func(p, q * Person) bool&#125; func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;&#125;) fmt.Println(people) &#125; 这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。 3、进一步封装感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; people [] Person by func(p, q * Person) bool&#125; type SortBy func(p, q *Person) bool func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; // 封装成 SortPerson 方法func SortPerson(people [] Person, by SortBy)&#123; sort.Sort(PersonWrapper&#123;people, by&#125;)&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) SortPerson(people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;) fmt.Println(people) &#125; 在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。 4、另一种思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Weight int&#125; type PersonSlice []Person func (s PersonSlice) Len() int &#123; return len(s) &#125;func (s PersonSlice) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125; type ByName struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByName 中 func (s ByName) Less(i, j int) bool &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125; // 将 Less 绑定到 ByName 上 type ByWeight struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByWeight 中func (s ByWeight) Less(i, j int) bool &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125; // 将 Less 绑定到 ByWeight 上 func main() &#123; s := []Person&#123; &#123;\"apple\", 12&#125;, &#123;\"pear\", 20&#125;, &#123;\"banana\", 50&#125;, &#123;\"orange\", 87&#125;, &#123;\"hello\", 34&#125;, &#123;\"world\", 43&#125;, &#125; sort.Sort(ByWeight&#123;s&#125;) fmt.Println(\"People by weight:\") printPeople(s) sort.Sort(ByName&#123;s&#125;) fmt.Println(\"\\nPeople by name:\") printPeople(s) &#125; func printPeople(s []Person) &#123; for _, o := range s &#123; fmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight) &#125;&#125; 对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。 参考资料：1、go语言的排序和搜索","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/tags/Go语言/"}],"keywords":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}]},{"title":"【Android 】TextView 局部文字变色","slug":"【Android 】TextView 局部文字变色","date":"2016-09-07T07:02:45.000Z","updated":"2016-10-18T04:54:41.575Z","comments":true,"path":"2016/09/07/【Android 】TextView 局部文字变色/","link":"","permalink":"http://github.com/2016/09/07/【Android 】TextView 局部文字变色/","excerpt":"TextView 对于富文本效果的实现支持不支持呢？比如“局部文字颜色的变动”，“局部字体的变动” 一、需求效果","text":"TextView 对于富文本效果的实现支持不支持呢？比如“局部文字颜色的变动”，“局部字体的变动” 一、需求效果 二、解决方案针对这类问题，Android提供了 SpannableStringBuilder，方便我们自定义富文本的实现。 123456789101112131415161718textView = (TextView) findViewById(R.id.textview);SpannableStringBuilder builder = new SpannableStringBuilder(textView.getText().toString());//ForegroundColorSpan 为文字前景色，BackgroundColorSpan为文字背景色ForegroundColorSpan redSpan = new ForegroundColorSpan(Color.RED);ForegroundColorSpan whiteSpan = new ForegroundColorSpan(Color.WHITE);ForegroundColorSpan blueSpan = new ForegroundColorSpan(Color.BLUE);ForegroundColorSpan greenSpan = new ForegroundColorSpan(Color.GREEN);ForegroundColorSpan yellowSpan = new ForegroundColorSpan(Color.YELLOW); builder.setSpan(redSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(whiteSpan, 1, 2, Spannable.SPAN_INCLUSIVE_INCLUSIVE);builder.setSpan(blueSpan, 2, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(greenSpan, 3, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(yellowSpan, 4,5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);textView.setText(builder); 除了上述代码中使用的 ForegroundColorSpan 和 BackgroundColorSpan之外，还有以下这些Span可以使用： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) ScaleXSpan(float proportion) —— 缩放字体，与上面的类似，默认为1,设置后就是原来的乘以proportion，大于1时放大(zoon in)，小于时缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致 TypefaceSpan(String family) —— 字体，参数是字体的名字比如“sans”, “sans-serif”等 StyleSpan(Typeface style) —— 字体风格，比如粗体，斜体，参数是android.graphics.Typeface里面定义的常量，如Typeface.BOLD，Typeface.ITALIC等等。StrikethroughSpan—-如果设置了此风格，会有一条线从中间穿过所有的字，就像被划掉一样 三、动手试试比如实现下图中TextView的样式 然后代码如下： 1234567891011121314TextView tv = (TextView)view.findViewById(R.id.toast_text);String str1 = \"提交成功！\\n积分\";String str2 = \"+\" + score1;String str3 = \"！审核通过后再\";String str4 = \"+\" + score2;SpannableStringBuilder builder = new SpannableStringBuilder(str1 + str2 + str3 + str4 + \"！\");builder.setSpan(new ForegroundColorSpan(Color.parseColor(\"#ffffa200\")), str1.length(), (str1 + str2).length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);builder.setSpan(new ForegroundColorSpan(Color.parseColor(\"#ffffa200\")), (str1 + str2 + str3).length(), (str1 + str2 + str3 + str4).length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);tv.setText(builder); 参考资料：1、Android-修改TextView中部分文字的颜色2、Android TextView 设置部分文字背景色和文字颜色","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】获取View的截图","slug":"【Android】获取View的截图","date":"2016-08-30T02:32:00.000Z","updated":"2016-10-18T04:55:33.990Z","comments":true,"path":"2016/08/30/【Android】获取View的截图/","link":"","permalink":"http://github.com/2016/08/30/【Android】获取View的截图/","excerpt":"引言 在Android应用开发过程中，可能会遇到需要对整个界面或者某一部分进行截图的需求。 Android中对View的截图也有以下两种方式，值得注意的是两个方法都不适用于SurfaceView： 使用DrawingCache如果使用DrawingCache，则对要截图的View有一个要求：View本身已经显示在界面上。如果View没有添加到界面上或者没有显示（绘制）过，则buildDrawingCache会失败。这种方式比较适合对应用界面或者某一部分的截图。步骤很简单： 123456view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能","text":"引言 在Android应用开发过程中，可能会遇到需要对整个界面或者某一部分进行截图的需求。 Android中对View的截图也有以下两种方式，值得注意的是两个方法都不适用于SurfaceView： 使用DrawingCache如果使用DrawingCache，则对要截图的View有一个要求：View本身已经显示在界面上。如果View没有添加到界面上或者没有显示（绘制）过，则buildDrawingCache会失败。这种方式比较适合对应用界面或者某一部分的截图。步骤很简单： 123456view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能 完整的截图功能函数如下： 1234567891011121314151617181920/** * 获取一个 View 的缓存视图 * * @param view * @return */ private Bitmap getCacheBitmapFromView(View view) &#123; final boolean drawingCacheEnabled = true; view.setDrawingCacheEnabled(drawingCacheEnabled); view.buildDrawingCache(drawingCacheEnabled); final Bitmap drawingCache = view.getDrawingCache(); Bitmap bitmap; if (drawingCache != null) &#123; bitmap = Bitmap.createBitmap(drawingCache); view.setDrawingCacheEnabled(false); &#125; else &#123; bitmap = null; &#125; return bitmap; &#125; 直接调用View.draw如果需要截图的View并没有添加到界面上，可能是通过java代码创建的或者inflate创建的，此时调用DrawingCache方法是获取不到位图的。因为View在添加到容器中之前并没有得到实际的大小（如果LayoutWidth是MatchParent，它还没有Parent…），所以首先需要指定View的大小： 12345678910private void layoutView(View v, int width, int height) &#123; // validate view.width and view.height v.layout(0, 0, width, height); int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY); // validate view.measurewidth and view.measureheight v.measure(measuredWidth, measuredHeight); v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());i &#125; 使用方式如下： 1234567int viewWidth = webView.getMeasuredWidth(); int viewHeight = webView.getMeasuredHeight(); if (viewWidth &gt; 0 &amp;&amp; viewHeight &gt; 0) &#123; b = Bitmap.createBitmap(viewWidth, viewHeight, Config.ARGB_8888); Canvas cvs = new Canvas(b); webView.draw(cvs); &#125; 对于WebView的截图有一点特殊，网页内容并不能在布局完成后立即渲染出来，大概需要300ms的时间（对于不同性能的设备、网页复杂程度和Webkit版本可能不同）。 如果创建后台的WebView需要截图的话，应该在创建时就对其进行布局操作，这样加载完成后大部分就已经渲染完毕了（除非有异步的js处理）。 【参考资料】： 1、Android应用截图两种方法2、知乎和简书的夜间模式实现套路","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】如何加速 AndroidStudio 的编译效率","slug":"【Android】如何加速 AndroidStudio 的编译效率","date":"2016-08-26T07:20:00.000Z","updated":"2016-10-18T04:55:51.767Z","comments":true,"path":"2016/08/26/【Android】如何加速 AndroidStudio 的编译效率/","link":"","permalink":"http://github.com/2016/08/26/【Android】如何加速 AndroidStudio 的编译效率/","excerpt":"引言如果你之前用eclipse开发过Android app的话，转到android studio的第一反应也许就是：”编译速度有点慢“，表现的最明显的一点就是，每次android studio使用gradle编译，即便是更改的代码量很少，也会按照预先设置的task的顺序，依次走完编译的各项流程。这时候如果电脑CPU配置不高的时候，就会超级卡界面，更别说改代码了。 所以 这点就让人很痛苦， 然而问题总还是要被解决的，作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下)。 现在把如何优化gradle编译速度的方法记录在此，希望可以 帮助到广大的同行们。 准备工作首先，保证项目使用的Gradle是最新的，我这里用的是2.10版本。因为Gradle 2.4之后在编译效率上面有了一个非常大的提高，看下图官方的速度对比。","text":"引言如果你之前用eclipse开发过Android app的话，转到android studio的第一反应也许就是：”编译速度有点慢“，表现的最明显的一点就是，每次android studio使用gradle编译，即便是更改的代码量很少，也会按照预先设置的task的顺序，依次走完编译的各项流程。这时候如果电脑CPU配置不高的时候，就会超级卡界面，更别说改代码了。 所以 这点就让人很痛苦， 然而问题总还是要被解决的，作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下)。 现在把如何优化gradle编译速度的方法记录在此，希望可以 帮助到广大的同行们。 准备工作首先，保证项目使用的Gradle是最新的，我这里用的是2.10版本。因为Gradle 2.4之后在编译效率上面有了一个非常大的提高，看下图官方的速度对比。 然后先在你的项目build.gradle文件内(不是app里面的gradle文件), 就是这里： 添加一个task， 代码如下: 123task wrapper(type: Wrapper) &#123; gradleVersion = '2.10' //你安装的最新Gradle版本&#125; 加进去以后是这个样子： 12345678910111213141516171819202122232425// Top-level build file where you can add configuration options common to all sub-projects/modules.// Running 'gradle wrapper' will generate gradlew - Getting gradle wrapper working and using it will save you a lot of pain.task wrapper(type: Wrapper) &#123; gradleVersion = '2.10'&#125;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0' &#125; ext &#123; compileSdkVersion = 21 buildToolsVersion =\"23.0.2\" minSdkVersion = 18 targetSdkVersion = 21 sourceCompatibility = JavaVersion.VERSION_1_7 targetCompatibility = JavaVersion.VERSION_1_7 &#125;&#125; 然后打开terminal, 输入./gradlew wrapper，Windows 下输入： 1gradlew wrapper 然后gradle就会自动去下载2.4版本,这也是官方推荐的手动设置gradle的方法 守护进程，并行编译通过以上步骤,我们设置好了 Android Studio 使用最新的 Gradle 版本，下一步就是正式开启优化之路了。我们需要将gradle作为守护进程一直在后台运行，这样当我们需要编译的时候，gradle就会立即跑过来然后 吭哧吭哧的开始干活。除了设置gradle一直开启之外，当你的工作空间存在多个project的时候，还需要设置gradle对这些projects并行编译，而不是单线的依次进行编译操作。 说了那么多， 那么怎么设置守护进程和并行编译呢？其实非常简单，gradle本身已经有了相关的配置选项，在你电脑的GRADLE_HOME这个环境变量所指的那个文件夹内，有一个.gradle/gradle.properties文件。 在这个文件里，放入下面两句话就OK了: 12org.gradle.daemon=trueorg.gradle.parallel=true 有一个地方需要注意的是,android studio 本身在编译的时候,已经是使用守护进程中的gradle了,那么这里加上了org.gradle.daemon=true就是保证了你在使用命令行编译apk的时候也是使用的守护进程. 你也可以将上述的配置文件放到你project中的根目录下,以绝对确保在任何情况下,这个project都会使用守护进程进行编译.不过有些特殊的情况下也许你应该注意守护进程的使用,具体的细节参考官网When should I not use the Gradle Daemon? 在使用并行编译的时候必须要注意的就是,你的各个project之间不要有依赖关系,否则的话,很可能因为你的Project A 依赖Project B, 而Project B还没有编译出来的时候,gradle就开始编译Project A 了.最终 导致编译失败.具体可以参考官网Multi-Project Building and Testing。 还有一些额外的gradle设置也许会引起你的兴趣,例如你想增加堆内存的空间,或者指定使用哪个jvm虚拟机等等(代码如下) 12org.gradle.jvmargs=-Xmx768morg.gradle.java.home=/path/to/jvm 如果你想详细的了解gradle的配置,请猛戳官网 Gradle User Guide。 【参考资料】：1、Boosting the performance for Gradle in your Android projects2、译文：优化android studio编译效率的方法3、How/when to generate Gradle wrapper files?","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Go】为什么 Go 语言把类型声明放在后面？","slug":"【Go】为什么 Go 语言把类型声明放在后面？","date":"2016-08-18T08:36:00.000Z","updated":"2016-10-18T04:56:04.881Z","comments":true,"path":"2016/08/18/【Go】为什么 Go 语言把类型声明放在后面？/","link":"","permalink":"http://github.com/2016/08/18/【Go】为什么 Go 语言把类型声明放在后面？/","excerpt":"关于类型，官网上有一段仔细地介绍了一下函数指针的部分，现在的设计比起 C 的语法，清晰很多。 也就是说，类型放在后面是为了更加清晰易懂。Rob Pike 曾经在 Go 官方博客解释过这个问题（查看原文：Go’s Declaration Syntax），简略翻译如下（水平有限翻译的不对的地方见谅）： 引言Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。 C 的语法首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如： 1int x; 上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明： 12int *p;int a[3];","text":"关于类型，官网上有一段仔细地介绍了一下函数指针的部分，现在的设计比起 C 的语法，清晰很多。 也就是说，类型放在后面是为了更加清晰易懂。Rob Pike 曾经在 Go 官方博客解释过这个问题（查看原文：Go’s Declaration Syntax），简略翻译如下（水平有限翻译的不对的地方见谅）： 引言Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。 C 的语法首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如： 1int x; 上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明： 12int *p;int a[3]; 指明了 p 是一个int类型的指针，因为 *p的类型为int。而 a 是一个 int 数组，因为 a[3]的类型为 int（别管这里出现的索引值，它只是用于指明数组的长度）。 我们接下来看看函数声明的情况。C 的函数声明中关于参数的类型是写在括号外的，像下面这样： 1234int main(argc, argv) int argc; char *argv[];&#123; /* ... */ &#125; 如前所述，我们可以看到 main 之所以是函数，是因为表达式 main(argc, argv) 返回 int。在现代记法中我们是这么写的： 1int main(int argc, char *argv[]) &#123; /* ... */ &#125; 尽管看起来有些不同，但是基本的结构是一样的。 总的来看，当类型比较简单时，C的语法显得很聪明。但是遗憾的是一旦类型开始复杂，C的这套语法很快就能让人迷糊了。著名的例子如函数指针，我们得按下面这样来写： 1int (*fp)(int a, int b); 在这儿，fp 之所以是一个指针是因为如果你写出 (*fp)(a, b) 这样的表达式将会调用一个函数，其返回 int 类型的值。如果当 fp 的某个参数本身又是一个函数，情况会怎样呢？ 1int (*fp)(int (*ff)(int x, int y), int b) 这读起来可就点难了。 当然了，我们声明函数时是可以不写明参数的名称的，因此 main 函数可以声明为： int main(int, char *[]) 回想一下，之前 argv 是下面这样的 1char *argv[] 你有没有发现你是从声明的「中间」去掉变量名而后构造出其变量类型的？尽管这不是很明显，但你声明某个 char *[]类型的变量的时候，竟然需要把名字插入到变量类型的中间。我们再来看看，如果我们不命名 fp 的参数会怎样： 1int (*fp)(int (*)(int, int), int) 这东西难懂的地方可不仅仅是要记得参数名原本是放这中间的 1int (*)(int, int) 它更让人混淆的地方还在于甚至可能都搞不清这竟然是个函数指针声明。我们接着看看，如果返回值也是个函数指针类型又会怎么样 1int (*(*fp)(int (*)(int, int), int))(int, int) 这已经很难看出是关于 fp 的声明了。 你自己还可以构建出比这更复杂的例子，但这已经足以解释 C 的声明语法引入的某些复杂性了。还有一点需要指出，由于类型语法和声明语法是一样的，要解析中间带有类型的表达式可能会有些难度。这也就是为什么，C 在做类型转换的时候总是要把类型用括号括起来的原因，像这样 1(int)M_PI Go 的语法非C家族的语言通常在声明时使用一种不同的类型语法。一般是名字先出现，然后常常跟着一个冒号。按照这样来写，我们上面所举的例子就会变成下面这样： 123x: intp: pointer to inta: array[3] of int 这样的声明即便有些冗长，当至少是清晰的——你只需从左向右读就行。Go 语言所采用的方案就是以此为基础的，但为了追求简洁性，Go 语言丢掉了冒号并去掉了部分关键词，成了下面这样： 123x intp *inta [3]int 在 [3]int 和表达式中 a的用法没有直接的对应关系（我们在下一节会回过头来探讨指针的问题）。至此，你获得了代码清晰性方面的提升，但付出的代价是语法上需要区别对待。 下面我们来考虑函数的问题。虽然在 Go 语言里，main 函数实际上没有参数，但是我们先誊抄一下之前的 main 函数的声明： 1func main(argc int, argv *[]byte) int 粗略一看和 C 没什么不同，不过自左向右读的话还不错。main 函数接受一个 int 和一个指针并返回一个int。如果此时把参数名去掉，它还是很清楚——因为参数名总在类型的前面，所以不会引起混淆。 1func main(int, *[]byte) int 这种自左向右风格的声明的一个价值在于，当类型变得更复杂时，它依然相对简单。下面是一个函数变量的声明（相当于 C 语言里的函数指针） 1f func(func(int,int) int, int) int 或者当它返回一个函数时： 1f func(func(int,int) int, int) func(int, int) int 上面的声明读起来还是很清晰，自左向右，而且究竟哪一个变量名是当前被声明的也容易看懂——因为变量名永远在首位。类型语法和表达式语法带来的差别使得在 Go 语言里调用闭包也变得更简单： 1sum := func(a, b int) int &#123; return a+b &#125; (3, 4) 指针指针有些例外。注意在数组 (array )和切片 (slice) 中，Go 的类型语法把方括号放在了类型的左边，但是在表达式语法中却又把方括号放到了右边： 12var a []intx = a[1] 类似的，Go 的指针沿用了 C 的 * 记法，但是我们写的时候也是声明时 在变量名右边，但在表达式中却又得把 放到左左边： 12var p *intx = *p 不能写成下面这样 12var p *intx = p* 因为后缀的 * 可能会和乘法运算混淆，也许我们可以改用 Pascal 的 ^ 标记，像这样 12var p ^intx = p^ 我们也许还真的应该把 * 像上面这样改成 ^ （当然这么一改 xor 运算的符号也得改），因为在类型和表达式中的 * 前缀确实把好些事儿都搞得有点复杂，举个例子来说，虽然我们可以像下面这样写 1[]int(\"hi\") 但在转换时，如果类型是以 * 开头的，就得加上括号： 1(*int)(nil) 如果有一天我们愿意放弃用 *作为指针语法的话，那么上面的括号就可以省略了。 可见，Go 的指针语法是和 C 相似的。但这种相似也意味着我们无法彻底避免在文法中有时为了避免类型和表达式的歧义需要补充括号的情况。 总而言之，尽管存在不足，但我们相信 Go 的类型语法要比 C 的容易懂。特别是当类型比较复杂时。 我擦，这边文章被知识库收录而且上了首页，吓死宝宝了。赶紧改个Bug压压惊=_=","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/tags/Go语言/"}],"keywords":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}]},{"title":"【Machine Learning】机器学习：简明入门指南","slug":"【Machine Learning】机器学习：简明入门指南","date":"2016-08-14T09:32:55.000Z","updated":"2016-10-18T04:57:03.883Z","comments":true,"path":"2016/08/14/【Machine Learning】机器学习：简明入门指南/","link":"","permalink":"http://github.com/2016/08/14/【Machine Learning】机器学习：简明入门指南/","excerpt":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。","text":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。 何为机器学习？机器学习这个概念认为，对于待解问题，你无需编写任何专门的程序代码，遗传算法（generic algorithms）能够在数据集上为你得出有趣的答案。对于遗传算法，不用编码，而是将数据输入，它将在数据之上建立起它自己的逻辑。 举个例子，有一类算法称为分类算法，它可以将数据划分为不同的组别。一个用来识别手写数字的分类算法，不用修改一行代码，就可以用来将电子邮件分为垃圾邮件和普通邮件。算法没变，但是输入的训练数据变了，因此它得出了不同的分类逻辑。 机器学习算法是个黑盒，可以重用来解决很多不同的分类问题。 “机器学习”是一个涵盖性术语，覆盖了大量类似的遗传算法。 两类机器学习算法你可以认为机器学习算法分为两大类：监督式学习（Supervised Learning）和非监督式学习（Unsupervised Learning）。两者区别很简单，但却非常重要。 监督式学习假设你是一名房产经纪，生意越做越大，因此你雇了一批实习生来帮你。但是问题来了——你可以看一眼房子就知道它到底值多少钱，实习生没有经验，不知道如何估价。 为了帮助你的实习生（也许是为了解放你自己去度个假），你决定写个小软件，可以根据房屋大小、地段以及类似房屋的成交价等因素来评估你所在地区房屋的价值。 你把3个月来城里每笔房屋交易都写了下来，每一单你都记录了一长串的细节——卧室数量、房屋大小、地段等等。但最重要的是，你写下了最终的成交价： 这是我们的“训练数据”: 我们要利用这些训练数据来编写一个程序来估算该地区其他房屋的价值： 这就称为监督式学习。你已经知道每一栋房屋的售价，换句话说，你知道问题的答案，并可以反向找出解题的逻辑。 为了编写软件，你将包含每一套房产的训练数据输入你的机器学习算法。算法尝试找出应该使用何种运算来得出价格数字。 这就像是算术练习题，算式中的运算符号都被擦去了：天哪！一个阴险的学生将老师答案上的算术符号全擦去了。 看了这些题，你能明白这些测验里面是什么样的数学问题吗？你知道，你应该对算式左边的数字“做些什么”以得出算式右边的答案。 在监督式学习中，你是让计算机为你算出数字间的关系。而一旦你知道了解决这类特定问题所需要的数学方法后，你就可以解答同类的其它问题了。 非监督式学习让我们回到开头那个房地产经纪的例子。要是你不知道每栋房子的售价怎么办？即使你所知道的只是房屋的大小、位置等信息，你也可以搞出很酷的花样。这就是所谓的非监督式学习。 即使你不是想去预测未知的数据（如价格），你也可以运用机器学习完成一些有意思的事。 这就有点像有人给你一张纸，上面列出了很多数字，然后对你说:“我不知道这些数字有什么意义，也许你能从中找出规律或是能将它们分类，或是其它什么-祝你好运！” 你该怎么处理这些数据呢？首先，你可以用个算法自动地从数据中划分出不同的细分市场。也许你会发现大学附近的买房者喜欢户型小但卧室多的房子，而郊区的买房者偏好三卧室的大户型。这些信息可以直接帮助你的营销。 你还可以作件很酷的事，自动找出房价的离群数据，即与其它数据迥异的值。这些鹤立鸡群的房产也许是高楼大厦，而你可以将最优秀的推销员集中在这些地区，因为他们的佣金更高。 本文余下部分我们主要讨论监督式学习，但这并不是因为非监督式学习用处不大或是索然无味。实际上，随着算法改良，不用将数据和正确答案联系在一起，因此非监督式学习正变得越来越重要。 老学究请看:还有很多其它种类的机器学习算法。但初学时这样理解不错了。 太酷了，但是评估房价真能被看作“学习”吗？作为人类的一员，你的大脑可以应付绝大多数情况，并且没有任何明确指令也能够学习如何处理这些情况。如果你做房产经纪时间很长，你对于房产的合适定价、它的最佳营销方式以及哪些客户会感兴趣等等都会有一种本能般的“感觉”。强人工智能（Strong AI）研究的目标就是要能够用计算机复制这种能力。 但是目前的机器学习算法还没有那么好——它们只能专注于非常特定的、有限的问题。也许在这种情况下，“学习”更贴切的定义是“在少量范例数据的基础上找出一个等式来解决特定的问题”。 不幸的是，“机器在少量范例数据的基础上找出一个等式来解决特定的问题”这个名字太烂了。所以最后我们用“机器学习”取而代之。 当然，要是你是在50年之后来读这篇文章，那时我们已经得出了强人工智能算法，而本文看起来就像个老古董。未来的人类，你还是别读了，叫你的机器仆人给你做份三明治吧。 让我们写代码吧!前面例子中评估房价的程序，你打算怎么写呢？往下看之前，先思考一下吧。 如果你对机器学习一无所知，很有可能你会尝试写出一些基本规则来评估房价，如下： 123456789101112131415161718192021222324252627def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # In my area, the average house costs $200 per sqft price_per_sqft = 200 if neighborhood == \"hipsterton\": # but some areas cost a bit more price_per_sqft = 400 elif neighborhood == \"skid row\": # and some areas cost less price_per_sqft = 100 # start with a base price estimate based on how big the place is price = price_per_sqft * sqft # now adjust our estimate based on the number of bedrooms if num_of_bedrooms == 0: # Studio apartments are cheap price = price — 20000 else: # places with more bedrooms are usually # more valuable price = price + (num_of_bedrooms * 1000) return price 假如你像这样瞎忙几个小时，也许会取得一点成效，但是你的程序永不会完美，而且当价格变化时很难维护。 如果能让计算机找出实现上述函数功能的办法，这样岂不更好？只要返回的房价数字正确，谁会在乎函数具体干了些什么呢？ 1234def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = &lt;computer, plz do some math for me&gt; return price 考虑这个问题的一种角度是将房价看做一碗美味的汤，而汤中成分就是卧室数、面积和地段。如果你能算出每种成分对最终的价格有多大影响，也许就能得到各种成分混合起来形成最终价格的具体比例。 这样可以将你最初的程序（全是疯狂的if else语句）简化成类似如下的样子： 12345678910111213141516def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * .841231951398213 # and a big pinch of that price += sqft * 1231.1231231 # maybe a handful of this price += neighborhood * 2.3242341421 # and finally, just a little extra salt for good measure price += 201.23432095 return price 请注意那些用粗体标注的神奇数字——.841231951398213, 1231.1231231,2.3242341421, 和201.23432095。它们称为权重。如果我们能找出对每栋房子都适用的完美权重，我们的函数就能预测所有的房价！ 找出最佳权重的一种笨办法如下所示： 步骤1：首先，将每个权重都设为1.0： 12345678910111213141516def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * 1.0 # and a big pinch of that price += sqft * 1.0 # maybe a handful of this price += neighborhood * 1.0 # and finally, just a little extra salt for good measure price += 1.0 return price 步骤2：将每栋房产带入你的函数运算，检验估算值与正确价格的偏离程度： 运用你的程序预测房屋价格。 例如：上表中第一套房产实际成交价为25万美元，你的函数估价为17.8万，这一套房产你就差了7.2万。 再将你的数据集中的每套房产估价偏离值平方后求和。假设数据集中有500套房产交易，估价偏离值平方求和总计为86,123,373美元。这就反映了你的函数现在的“正确”程度。 现在，将总计值除以500，得到每套房产的估价偏离平均值。将这个平均误差值称为你函数的代价。 如果你能调整权重使得这个代价变为0，你的函数就完美了。它意味着，根据输入的数据，你的程序对每一笔房产交易的估价都是分毫不差。而这就是我们的目标——尝试不同的权重值以使代价尽可能的低。 步骤3：不断重复步骤2，尝试所有可能的权重值组合。哪一个组合使得代价最接近于0，它就是你要使用的，你只要找到了这样的组合，问题就得到了解决! 思想扰动时间这太简单了，对吧？想一想刚才你做了些什么。你取得了一些数据，将它们输入至三个通用的简单步骤中，最后你得到了一个可以对你所在区域的房屋进行估价的函数。房价网，要当心咯！但是下面的事实可能会扰乱你的思想： 1.过去40年来，很多领域（如语言学/翻译学）的研究表明，这种通用的“搅动数据汤”（我编造的词）式的学习算法已经胜过了需要利用真人明确规则的方法。机器学习的“笨”办法最终打败了人类专家。 2.你最后写出的函数真是笨，它甚至不知道什么是“面积”和“卧室数”。它知道的只是搅动，改变数字来得到正确的答案。 3.很可能你都不知道为何一组特殊的权重值能起效。所以你只是写出了一个你实际上并不理解却能证明的函数。 4.试想一下，你的程序里没有类似“面积”和“卧室数”这样的参数，而是接受了一组数字。假设每个数字代表了你车顶安装的摄像头捕捉的画面中的一个像素，再将预测的输出不称为“价格”而是叫做“方向盘转动度数”，这样你就得到了一个程序可以自动操纵你的汽车了！ 太疯狂了，对吧？ 步骤3中的“尝试每个数字”怎么回事？好吧，当然你不可能尝试所有可能的权重值来找到效果最好的组合。那可真要花很长时间，因为要尝试的数字可能无穷无尽。 为避免这种情况，数学家们找到了很多聪明的办法（比如Gradient descent算法）来快速找到优秀的权重值，而不需要尝试过多。下面是其中一种： 首先，写出一个简单的等式表示前述步骤2，这是你的代价函数： 接着，让我们将这同一个等式用机器学习的数学术语（现在你可以忽略它们）进行重写： θ表示当前的权重值。 J(θ) 意为“当前权重值对应的代价”。 这个等式表示我们的估价程序在当前权重值下偏离程度的大小。如果将所有赋给卧室数和面积的可能权重值以图形形式显示，我们会得到类似下图的图表： 代价函数的图形像一支碗。纵轴表示代价。 图中蓝色的最低点就是代价最低的地方——即我们的程序偏离最小。最高点意味着偏离最大。所以，如果我们能找到一组权重值带领我们到达图中的最低点，我们就找到了答案！ 因此，我们只需要调整权重值使我们在图上能向着最低点“走下坡路”。如果对于权重的细小调节能一直使我们保持向最低点移动，那么最终我们不用尝试太多权重值就能到达那里。 如果你还记得一点微积分的话，你也许记得如果你对一个函数求导，结果会告诉你函数在任一点的斜率。换句话说，对于图上给定一点，它告诉我们那条路是下坡路。我们可以利用这一点朝底部进发。 所以，如果我们对代价函数关于每一个权重求偏导，那么我们就可以从每一个权重中减去该值。这样可以让我们更加接近山底。一直这样做，最终我们将到达底部，得到权重的最优值。（读不懂？不用担心，接着往下读）。 这种找出最佳权重的办法被称为批量梯度下降，上面是对它的高度概括。如果想搞懂细节，不要害怕，继续深入下去吧。 当你使用机器学习算法库来解决实际问题，所有这些都已经为你准备好了。但明白一些具体细节总是有用的。 还有什么你随便就略过了？上面我描述的三步算法被称为多元线性回归。你估算等式是在求一条能够拟合所有房价数据点的直线。然后，你再根据房价在你的直线上可能出现的位置用这个等式来估算从未见过的房屋的价格。这个想法威力强大，可以用它来解决“实际”问题。 但是，我为你展示的这种方法可能在简单的情况下有效，它不会在所有情况下都有用。原因之一是因为房价不会一直那么简单地跟随一条连续直线。 但是，幸运的是，有很多办法来处理这种情况。对于非线性数据，很多其他类型的机器学习算法可以处理（如神经网络或有核向量机）。还有很多方法运用线性回归更灵活，想到了用更复杂的线条来拟合。在所有的情况中，寻找最优权重值这一基本思路依然适用。 还有，我忽略了过拟合的概念。很容易碰上这样一组权重值，它们对于你原始数据集中的房价都能完美预测，但对于原始数据集之外的任何新房屋都预测不准。这种情况的解决之道也有不少（如正则化以及使用交叉验证数据集）。学会如何处理这一问题对于顺利应用机器学习至关重要。 换言之，基本概念非常简单，要想运用机器学习得到有用的结果还需要一些技巧和经验。但是，这是每个开发者都能学会的技巧。 机器学习法力无边吗？一旦你开始明白机器学习技术很容易应用于解决貌似很困难的问题（如手写识别），你心中会有一种感觉，只要有足够的数据，你就能够用机器学习解决任何问题。只需要将数据输入进去，就能看到计算机变戏法一样找出拟合数据的等式。 但是很重要的一点你要记住，机器学习只能对用你占有的数据实际可解的问题才适用。 例如，如果你建立了一个模型来根据每套房屋内盆栽数量来预测房价，它就永远不会成功。房屋内盆栽数量和房价之间没有任何的关系。所以，无论它怎么去尝试，计算机也推导不出两者之间的关系。 你只能对实际存在的关系建模。 怎样深入学习机器学习我认为，当前机器学习的最大问题是它主要活跃于学术界和商业研究组织中。对于圈外想要有个大体了解而不是想成为专家的人们，简单易懂的学习资料不多。但是这一情况每一天都在改善。 吴恩达教授（Andrew Ng）在Coursera上的机器学习免费课程非常不错。我强烈建议由此入门。任何拥有计算机科学学位、还能记住一点点数学的人应该都能理解。 另外，你还可以下载安装SciKit-Learn，用它来试验成千上万的机器学习算法。它是一个python框架，对于所有的标准算法都有“黑盒”版本。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/tags/Machine-Learning/"}],"keywords":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}]},{"title":"【Machine Learning】Github上关注最多的53个深度学习项目","slug":"【Machine Learning】Github上关注最多的53个深度学习项目","date":"2016-08-12T07:22:00.000Z","updated":"2016-10-18T04:56:59.609Z","comments":true,"path":"2016/08/12/【Machine Learning】Github上关注最多的53个深度学习项目/","link":"","permalink":"http://github.com/2016/08/12/【Machine Learning】Github上关注最多的53个深度学习项目/","excerpt":"Top Deep Learning ProjectsA list of popular github projects related to deep learning (ranked by stars). Last Update: 2016.08.09","text":"Top Deep Learning ProjectsA list of popular github projects related to deep learning (ranked by stars). Last Update: 2016.08.09 Project Name Stars Description TensorFlow 29622 Computation using data flow graphs for scalable machine learning. Caffe 11799 Caffe: a fast open framework for deep learning. Neural Style 10148 Torch implementation of neural style algorithm. Deep Dream 9042 Deep Dream. Keras 7502 Deep Learning library for Python. Convnets, recurrent neural networks, and more. Runs on Theano and TensorFlow. Roc AlphaGo 7170 An independent, student-led replication of DeepMind’s 2016 Nature publication, “Mastering the game of Go with deep neural networks and tree search” (Nature 529, 484-489, 28 Jan 2016). TensorFlow Models 6671 Models built with TensorFlow Neural Doodle 6275 Turn your two-bit doodles into fine artworks with deep neural networks, generate seamless textures from photos, transfer style from one image to another, perform example-based upscaling, but wait… there’s more! (An implementation of Semantic Style Transfer.) CNTK 5957 Computational Network Toolkit (CNTK). TensorFlow Examples 5872 TensorFlow tutorials and code examples for beginners. ConvNet JS 5231 Deep Learning in Javascript. Train Convolutional Neural Networks (or ordinary ones) in your browser. Torch 5133 Torch7, Deep Learning Library. OpenFace 4855 Face recognition with deep neural networks. MXNet 4685 Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Scala, Go, Javascript and more. Nupic 4364 Numenta Platform for Intelligent Computing: a brain-inspired machine intelligence platform, and biologically accurate neural network based on cortical learning algorithms. Theano 4286 Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. It can use GPUs and perform efficient symbolic differentiation. Leaf 4281 Open Machine Intelligence Framework for Hackers. Char RNN 3820 Multi-layer Recurrent Neural Networks (LSTM, GRU, RNN) for character-level language models in Torch. Neural Talk 3694 NeuralTalk is a Python+numpy project for learning Multimodal Recurrent Neural Networks that describe images with sentences. deeplearning4j 3673 Deep Learning for Java, Scala &amp; Clojure on Hadoop, Spark. TFLearn 3368 Deep learning library featuring a higher-level API for TensorFlow. TensorFlow Playground 3352 Play with neural networks! OpenAI Gym 3020 A toolkit for developing and comparing reinforcement learning algorithms. Magenta 2914 Magenta: Music and Art Generation with Machine Intelligence Colornet 2798 Neural Network to colorize grayscale images. Synaptic 2666 architecture-free neural network library for node.js and the browser Neural Talk 2 2550 Efficient Image Captioning code in Torch, runs on GPU. Image Analogies 2540 Generate image analogies using neural matching and blending. TensorFlow Tutorials 2413 From the basics to slightly more interesting applications of Tensorflow. Lasagne 2355 Lightweight library to build and train neural networks in Theano. PyLearn2 2153 A Machine Learning library based on Theano. LISA-lab Deep Learning Tutorials 2134 Deep Learning Tutorial notes and code. See the wiki for more info. Neon 2121 Fast, scalable, easy-to-use Python based Deep Learning Framework by Nervana™. Matlab Deep Learning Toolbox 2032 Matlab/Octave toolbox for deep learning. Includes Deep Belief Nets, Stacked Autoencoders, Convolutional Neural Nets, Convolutional Autoencoders and vanilla Neural Nets. Each method has examples to get you started. Deep Learning Flappy Bird 1721 Flappy Bird hack using Deep Reinforcement Learning (Deep Q-learning). Chainer 1573 A flexible framework of neural networks for deep learning. Neural Story Teller 1514 A recurrent neural network for generating little stories about images. DIGITS 1353 Deep Learning GPU Training System. Deep Jazz 1229 Deep learning driven jazz generation using Keras &amp; Theano! Brainstorm 1143 Fast, flexible and fun neural networks. Darknet 937 Open Source Neural Networks in C Theano Tutorials 904 Bare bones introduction to machine learning from linear regression to convolutional neural networks using Theano. RNN Music Composition 904 A recurrent neural network designed to generate classical music. Blocks 866 A Theano framework for building and training neural networks. TDB 860 Interactive, node-by-node debugging and visualization for TensorFlow. Scikit Neural Net 849 Deep neural networks without the learning cliff! Classifiers and regressors compatible with scikit-learn. Veles 760 Distributed machine learning platform (Python, CUDA, OpenCL) Deep Detect 759 Deep Learning API and Server in C++11 with Python bindings and support for Caffe. TensorFlow DeepQ 759 A deep Q learning demonstration using Google Tensorflow. Caffe on Spark 724 Caffe On Spark. Nolearn 702 Abstractions around neural net libraries, most notably Lasagne. DCGAN TensorFlow 568 A tensorflow implementation of Deep Convolutional Generative Adversarial Networks MatConvNet 479 MATLAB CNN toolbox for computer vision applications. DeepCL 413 OpenCL library to train deep convolutional neural networks. 中文版 项 目 名 称 Stars 项目介绍 TensorFlow 29622 使用数据流图计算可扩展机器学习问题 Caffe 11799 Caffe是一个高效的开源深度学习框架 Neural Style 10148 Torch实现的神经网络算法 Deep Dream 9042 Deep Dream，一款图像识别工具 Keras 7502 一款Python实现的深度学习库，包括卷积神经网络、递归神经网络等。运行在Theano和TensorFlow之上。 Roc AlphaGo 7170 学生主导的一个独立项目，从新实现了 DeepMind在2016 Nature发表的内容， 《用深度神经网络和树搜索学习围棋》 (Nature 529, 484-489, 28 Jan 2016). TensorFlow Models 6671 基于TensorFlow开发的模型 Neural Doodle 6275 运用深度神经网络将涂鸦变为优雅的艺术品，从照片生成无缝纹理，转变图片风格，进行基于实例的提升，等等…还有更多！（语义风格传递的实现） CNTK 5957 计算网络工具（Computational Network Toolkit，CNTK） TensorFlow Examples 5872 初学者的TensorFlow教程和代码示例。 ConvNet JS 5231 基于Javascript的深度学习库。在浏览器中训练卷积神经网络模型（或者普通模型）。 Torch 5133 Torch7，深度学习库。 OpenFace 4855 基于深度学习网络的面部识别。 MXNet 4685 轻巧、便携、灵活的分布式/移动深度学习框架，支持Python, R, Julia, Scala, Go, Javascript等等语言。 Nupic 4364 智能计算的Numenta平台：一个脑启发式的计算智能和机器智能平台，基于皮层学习算法的生物精确神经网络模型。 Theano 4286 Theano 是一个 Python 库,用来定义、优化和模拟数学表达式计算,用于高效的解决多维数组的计算问题。 Leaf 4281 黑客的开源机器智能框架。 Char RNN 3820 多层递归神经网络的字符级别语言模型，基于Torch开发。 Neural Talk 3694 NeuralTalk是一个Python+numpy项目，用多模式递归神经网络描述图像。 deeplearning4j 3673 基于Hadoop和Spark的Java, Scala &amp; Clojure深度学习工具。 TFLearn 3368 深度学习库，包括高层次的TensorFlow接口。 TensorFlow Playground 3352 神经网络模型示例。 OpenAI Gym 3020 一种用于开发和比较强化学习算法的工具包。 Magenta 2914 Magenta: 音乐和艺术的生成与机器智能 Colornet 2798 用神经网络模型给灰度图上色。 Synaptic 2666 基于node.js和浏览器的免架构神经网络库。 Neural Talk 2 2550 Torch开发的图像简介生成代码，运行在GPU上。 Image Analogies 2540 使用神经匹配和融合生成相似图形。 TensorFlow Tutorials 2413 Tensorflow，从基础原理到应用。 Lasagne 2355 基于Theano训练和构建神经网络的轻型函数库。 PyLearn2 2153 基于Theano的机器学习库。 LISA-lab Deep Learning Tutorials 2134 深度学习教程笔记和代码。详情参见wiki页面。 Neon 2121 Nervana™开发的一款快速、可扩展、易上手的Python深度学习框架. Matlab Deep Learning Toolbox 2032 Matlab/Octave的深度学习工具箱。包括深度信念网络、自动编码机、卷积神经网络、卷积自动编码机和vanilla神经网络等。每种方法都有入门示例。 Deep Learning Flappy Bird 1721 使用深度强化学习破解Flappy Bird游戏(深度 Q-学习). Chainer 1573 一款灵活的深度学习神经网络框架。 Neural Story Teller 1514 看图讲故事的递归神经网络模型。 DIGITS 1353 深度学习GPU训练系统。 Deep Jazz 1229 基于Keras和Theano生成jazz的深度学习模型！ Brainstorm 1143 快速、灵活、有趣的神经网络。 Darknet 937 C语言版本的开源神经网络。 Theano Tutorials 904 基于Theano的机器学习入门教程，从线性回归到卷积神经网络。 RNN Music Composition 904 一款生成古典音乐的递归神经网络工具。 Blocks 866 用于构建和训练神经网络模型的Theano框架。 TDB 860 TensorFlow的交互式、节点调试和可视化的工具。 Scikit Neural Net 849 深度神经网络入门工具，类似scikit-learn的分类器和回归模型。 Veles 760 分布式机器学习平台(Python, CUDA, OpenCL) Deep Detect 759 基于C++11的深度学习接口和服务器，与Python绑定并支持Caffe。 TensorFlow DeepQ 759 基于Google Tensorflow的深度Q学习演示。 Caffe on Spark 724 基于Spark的Caffe。 Nolearn 702 神经网络库的抽象，著名的Lasagne。 DCGAN TensorFlow 568 基于tensorflow实现的深度卷积生成对抗网络。 DeepCL 413 用于训练深度卷积神经网络模型的OpenCL库。 来源：Top Deep Learning Projects","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/tags/Machine-Learning/"}],"keywords":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}]},{"title":"【Android】使用shape的同时，动态替换shape的颜色属性","slug":"【Android】使用shape的同时，动态替换shape的颜色属性","date":"2016-08-08T10:10:00.000Z","updated":"2016-10-18T04:55:58.087Z","comments":true,"path":"2016/08/08/【Android】使用shape的同时，动态替换shape的颜色属性/","link":"","permalink":"http://github.com/2016/08/08/【Android】使用shape的同时，动态替换shape的颜色属性/","excerpt":"在实现布局的时候，有些按钮形状相同，只是颜色有差异，如果使用自定义shape实现了其中一种按钮，有没有可能不需要再为其他每个颜色都写一个shape文件呢？ 一、问题比如以下这三个按钮： 为第一个灰色按钮自定义背景如下：1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" android:color=\"@color/gray\"&gt; &lt;corners android:radius=\"60dip\"/&gt; &lt;stroke android:width=\"0dp\" android:color=\"@color/gray\" /&gt; &lt;solid android:color=\"@color/gray\" /&gt;&lt;/shape&gt; 然后，如果再为每个颜色的按钮都写一个shape背景也太麻烦，重用性太差。","text":"在实现布局的时候，有些按钮形状相同，只是颜色有差异，如果使用自定义shape实现了其中一种按钮，有没有可能不需要再为其他每个颜色都写一个shape文件呢？ 一、问题比如以下这三个按钮： 为第一个灰色按钮自定义背景如下：1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" android:color=\"@color/gray\"&gt; &lt;corners android:radius=\"60dip\"/&gt; &lt;stroke android:width=\"0dp\" android:color=\"@color/gray\" /&gt; &lt;solid android:color=\"@color/gray\" /&gt;&lt;/shape&gt; 然后，如果再为每个颜色的按钮都写一个shape背景也太麻烦，重用性太差。 二、解决方法参考 stackoverflow 这里， 在java代码里使用 GradientDrawable 动态设置12GradientDrawable myGrad = (GradientDrawable)rectangle.getBackground();myGrad.setColor(Color.BLACK); 【参考资料】1、How to change solid color from the code?","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"BAT人才体系的职位层级、薪酬、晋升标准","slug":"BAT人才体系的职位层级、薪酬、晋升标准大全","date":"2016-08-02T03:06:00.000Z","updated":"2016-10-25T08:26:53.661Z","comments":true,"path":"2016/08/02/BAT人才体系的职位层级、薪酬、晋升标准大全/","link":"","permalink":"http://github.com/2016/08/02/BAT人才体系的职位层级、薪酬、晋升标准大全/","excerpt":"互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？可以先看看这个话题百度、腾讯和阿里内部的级别和薪资待遇是什么样的？ ★ 腾讯 ★1、职级腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如： 产品/项目通道，简称P族技术通道，简称T族市场通道，简称M族职能通道，简称S族 以T族为例，分别为： T1：助理工程师 （一般为校招新人） T2：工程师 T3：高级工程师 3-1相当于阿里的p6+到p7（能力强可能到p7） T4：专家工程师 T5：科学家 T6：首席科学家","text":"互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？可以先看看这个话题百度、腾讯和阿里内部的级别和薪资待遇是什么样的？ ★ 腾讯 ★1、职级腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如： 产品/项目通道，简称P族技术通道，简称T族市场通道，简称M族职能通道，简称S族 以T族为例，分别为： T1：助理工程师 （一般为校招新人） T2：工程师 T3：高级工程师 3-1相当于阿里的p6+到p7（能力强可能到p7） T4：专家工程师 T5：科学家 T6：首席科学家 目前全腾讯貌似就一个T6。 每一级之间又分为3个子级，3-1是任命组长/副组长的必要条件，其他线也是这样。T4基本为总监级，也不排除有T3-3的总监，因为T4非常难晋级。 2、晋升腾讯的晋级还是很困难的。尤其是T2 升T3，T3升T4。非常多的人卡在2-3,3-3没办法晋级。有的小伙伴做了3、4年的2-3 也升不上去啊。 3、薪水腾讯薪资架构：12+1+1=14薪 年终奖：看部门盈利情况，一般是3个月 职级待遇基本如下(2015年左右)： 级别越高base薪酬也越高，一年根据你的performance大概能发15.3个月至18个月的工资，T3.1的base 2w+，T3以上级别的员工都会有股票期权，腾讯09以前的员工赚钱主要靠股票，从08到现在股票up了500%+，T5+的base薪酬在600w~800w/年。 4、人才人才流动的可能： 深圳：很多腾讯员工都买了房，当你的房子，妻子的工作，儿子的学校，你的朋友圈，都在一个城市的时候，换城市就有困难了。所以只能挖一些比较浅的人走。 北京：人数不少 ，不过骨干员工不多。腾讯视频的主要团队在北京的倒是不少。 成都、大连：在这些二线城市，腾讯就是当地最好的互联网公司了，提供的待遇也是非常高的，不少人都对自己的薪资比较满意，工作环境也很满意。跳槽的可能性低了很多。 人才结构： 腾讯的研发序列硕士学历的占多度，211大学，985大学占多数。大家都知道腾讯研究院解散了。去年走出来很多人，腾讯人才创业比例不高。 在腾讯最常碰到的晋升问题就是天花板。可能新人进去，学东西会很多，但业务线就这些，没有那么多坑，自然也就很难晋升高级岗。 在腾讯最悲剧的时刻就是公司有收购和整合。搜狗合并，搜搜的人哭了，京东合作，易迅的人哭了。在腾讯跳出来碰到最大的问题就是，外面的公司太不完善了。 ★ 阿里巴巴 ★1、层级阿里的职称大部分都归纳在P序列 ,你的title+工种。比如P7产品经理=产品专家。 一般到P3为助理 P4=专员 P5=资深专员 P6=高级专员（也可能是高级资深） P7=专家 P8=资深专家（架构师） P9=高级专家（资深架构师） P10=研究员 P11=高级研究员 P12=科学家 P13=首席科学家 P14=马云 同时对应P级还有一套管理层的机制在： M1=P6 主管 M2=P7 经理 M3=P8 资深经理 M4 =P9 总监 M5= P10 资深总监 M6 =P11 副总裁 M7=P12 资深副总裁 M8=P13 子公司CEO 或集团其他O M9=P14 陆兆禧（前马云） 在阿里早些时候P级普遍偏低，专员可能是P2这样，后来有了一次P级通货膨胀，出现了更多的P级。在阿里只有P6（M1）后才算是公司的中层。不同的子公司给出P级的标准不一样。 比如：B2B的普遍P级较高，但是薪资水平低于天猫子公司的同级人员。同时到达该P级员工才有享受公司RSU的机会。（低于P6的除非项目出色有RSU奖励，否则1股都拿不到） 2、晋升晋升很简单： 晋升资格：上年度KPI达3.75。 主管提名。一般KPI不达3.75主管不会提名。 晋升委员会面试。（晋升委员会组成一般是合作方业务部门大佬、HRG、该业务线大佬等。） 晋升委员会投票。 P5升P6相对容易，再往上会越来越难，一般到P7都是团队技术leader了，P6到P7非常难，从员工到管理的那一步跨出去不容易，当然有同学说P一般都是专家，M才是管理，actually，专家线/管理线有时并不是分的那么清楚的。 3、薪水• 阿里薪资结构：一般是12+1+3=16薪 • 年底的奖金为0-6个月薪资，90%人可拿到3个月 • 股票是工作满2年才能拿，第一次拿50%，4年能全部拿完 ★ 百度 ★1、层级百度的级别架构分成四条线。 技术序列 T：T3 - T11 （一般对应阿里高一级序列，如：百度T3=阿里P4，T5/T6属于部门骨干，非常抢手，人人猎中相当一部分offer人选都来自这个序列） 产品运营序列 P：p3-P11 （产品和运营岗，对应阿里高1-1.5级序列 百度p3=阿里P4-P5之间) 后勤支持部门 S ：S3-S11 (主要是公共、行政、渠道等等，晋升比较困难) 管理序列 M：M1-M5 (每一级又分为2个子级 M1A、M1B , 最低的是M1A，至少是部门二把手了，李明远是M3.2，以前的汤和松都是这个级别，李彦宏是唯一的M5，其实从M3开始就有机会加入E——star，类似于阿里的合伙人会议，属于最高战略决策层。 2、薪资月薪14.6（12+0.6+2）,其他岗位：月薪14 T5以上为关键岗位，另外有股票、期权。T5、T6占比最大的级别，T8、T9占比最小，级别越高，每档之间的宽幅越大。 3、晋升基本上应届毕业生应该是T3，但是内部晋升非常激烈。公司那么大，部门和部门之间有业务竞争，肯定也有人才竞争。 通常应届毕业生入职1年多能升到T4，但如果你的部门业务足够核心，或许1年就可以了。3年升T5。从目前百度的情况来看，核心工程师集中在T5/6，但是从5/6到7是非常艰难的过程。 百度是很唯KPI至上的，其次部门很核心，再次老大话语权比较高，相对晋升容易些。 一般情况分2种： 自己提名，当你自己觉得已经具备下一level的素质，可以自己提名，提名后进入考察期，主管设定考察期目标，考察通过顺利晋升，考察不通过维持原层级不变； 主管提名，如果是主管提名，一般都是直接通过的，但是如果你现层级已经比较高了，那就不是直接提名这么简单了。 P.S.如果你能升到T7，基本上是TL的级别，写代码/直接做业务的时间就很少了。","categories":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/categories/BAT/"}],"tags":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/tags/BAT/"}],"keywords":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/categories/BAT/"}]},{"title":"【Android】dip和px之间到底如何转换","slug":"【Android】dip和px之间到底如何转换","date":"2016-07-22T04:02:00.000Z","updated":"2016-10-18T04:55:04.190Z","comments":true,"path":"2016/07/22/【Android】dip和px之间到底如何转换/","link":"","permalink":"http://github.com/2016/07/22/【Android】dip和px之间到底如何转换/","excerpt":"在Android xml布局文件中，我们既可以设置px，也可以设置dp（或者dip）。一般情况下，我们都会选择使用dp，这样可以保证不同屏幕分辨率的机器上布局一致。 但是在代码中，如何处理呢？很多控件的方法中都只提供了设置px的方法，例如setPadding，并没有提供设置dp的方法。这个时候，如果需要设置dp的话，就要将dp转换成px了。 一、名词介绍 PPI = Pixels per inch，每英寸上的像素数,即 “像素密度”&nbsp;&nbsp;&nbsp;&nbsp; ● xhdpi: 2.0&nbsp;&nbsp;&nbsp;&nbsp; ● hdpi: 1.5&nbsp;&nbsp;&nbsp;&nbsp; ● mdpi: 1.0 (baseline)&nbsp;&nbsp;&nbsp;&nbsp; ● ldpi: 0.75下图是Android官网dpi的定义（其实在计算机中dpi就是ppi。注意，是dpi，不是dip，dpi是现实概念，dip是人为抽象概念。还是不明白可以看看这里 dpi与ppi区别）： dp = 也就是dip（device independent pixels），设备独立像素。以160PPI屏幕为标准，则1dp=1px，在不同的像素密度的设备上会自动适配，比如:&nbsp;&nbsp;&nbsp;&nbsp; ● 在320x480分辨率，像素密度为160，1dp=1px&nbsp;&nbsp;&nbsp;&nbsp; ● 在480x800分辨率，像素密度为240，1dp=1.5px&nbsp;&nbsp;&nbsp;&nbsp; &gt; 计算公式：1dp*像素密度/160 = 实际像素数 sp = Scale-independent pixels，它是安卓的字体单位","text":"在Android xml布局文件中，我们既可以设置px，也可以设置dp（或者dip）。一般情况下，我们都会选择使用dp，这样可以保证不同屏幕分辨率的机器上布局一致。 但是在代码中，如何处理呢？很多控件的方法中都只提供了设置px的方法，例如setPadding，并没有提供设置dp的方法。这个时候，如果需要设置dp的话，就要将dp转换成px了。 一、名词介绍 PPI = Pixels per inch，每英寸上的像素数,即 “像素密度”&nbsp;&nbsp;&nbsp;&nbsp; ● xhdpi: 2.0&nbsp;&nbsp;&nbsp;&nbsp; ● hdpi: 1.5&nbsp;&nbsp;&nbsp;&nbsp; ● mdpi: 1.0 (baseline)&nbsp;&nbsp;&nbsp;&nbsp; ● ldpi: 0.75下图是Android官网dpi的定义（其实在计算机中dpi就是ppi。注意，是dpi，不是dip，dpi是现实概念，dip是人为抽象概念。还是不明白可以看看这里 dpi与ppi区别）： dp = 也就是dip（device independent pixels），设备独立像素。以160PPI屏幕为标准，则1dp=1px，在不同的像素密度的设备上会自动适配，比如:&nbsp;&nbsp;&nbsp;&nbsp; ● 在320x480分辨率，像素密度为160，1dp=1px&nbsp;&nbsp;&nbsp;&nbsp; ● 在480x800分辨率，像素密度为240，1dp=1.5px&nbsp;&nbsp;&nbsp;&nbsp; &gt; 计算公式：1dp*像素密度/160 = 实际像素数 sp = Scale-independent pixels，它是安卓的字体单位 二、换算公式 PPI 的运算方式是：PPI = √（长度像素数² + 宽度像素数²） / 屏幕对角线英寸数 dp和px的换算公式 ：dp*ppi/160 = px。比如1dp x 320ppi/160 = 2px。 sp 与 px 的换算公式：sp*ppi/160 = px 三、总结px = dp*ppi/160dp = px / (ppi / 160) px = sp*ppi/160sp = px / (ppi / 160) dp = sp? 四、转换代码 为了方便进行px和dp之间的转换，可以使用以下代码。 1234567891011121314151617181920import android.content.Context; public class DensityUtil &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; &#125; 【参考资料】1、px 与 dp, sp换算公式2、dp、sp、px傻傻分不清楚[完整]","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Monkey压力测试与停止","slug":"【Android】Monkey压力测试与停止","date":"2016-07-19T03:09:00.000Z","updated":"2016-10-18T04:55:14.551Z","comments":true,"path":"2016/07/19/【Android】Monkey压力测试与停止/","link":"","permalink":"http://github.com/2016/07/19/【Android】Monkey压力测试与停止/","excerpt":"一、Monkey 是什么？Monkey测试是Android自动化测试的一种手段。该工具用于进行压力测试，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。 二、Monkey命令1）. 标准的monkey 命令[adb shell] monkey [options] &lt; eventcount &gt; , 例如： adb shell monkey -v 500 产生500次随机事件，作用在系统中所有activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。上面只是一个简单的例子，实际情况中通常会有很多的options 选项. 2）. 四大类 常用选项 事件选项 约束选项 调试选项 具体的命令解释可以看这里：android 压力测试命令monkey详解","text":"一、Monkey 是什么？Monkey测试是Android自动化测试的一种手段。该工具用于进行压力测试，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。 二、Monkey命令1）. 标准的monkey 命令[adb shell] monkey [options] &lt; eventcount &gt; , 例如： adb shell monkey -v 500 产生500次随机事件，作用在系统中所有activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。上面只是一个简单的例子，实际情况中通常会有很多的options 选项. 2）. 四大类 常用选项 事件选项 约束选项 调试选项 具体的命令解释可以看这里：android 压力测试命令monkey详解 一个简单的Monkey命令如下： adb shell monkey -p com.example.xystudy -s 500 -v 10000 工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。monkey 测试命令如下： 1234567/** * monkey 作用的包：com.ckt.android.junit * 产生时间序列的种子值：500 * 忽略程序崩溃、 忽略超时、 监视本地程序崩溃、 详细信息级别为2， 产生10000个事件 。 */adb shell monkey -p com.xy.android.junit -s 500 --ignore-crashes--ignore-timeouts --monitor-native-crashes -v -v 10000 &gt; E:\\monkey_log\\java_monkey_log.txt 三、强制停止Monkey测试1adb shell ps | awk '/com\\.android\\.commands\\.monkey/ &#123; system(\"adb shell kill \" $2) &#125;' ####【参考资料】 1、android 压力测试命令monkey详解2、Monkey 的专项测试浅谈","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？","slug":"【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？","date":"2016-07-14T08:27:00.000Z","updated":"2016-10-18T04:55:00.540Z","comments":true,"path":"2016/07/14/【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？/","link":"","permalink":"http://github.com/2016/07/14/【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？/","excerpt":"英文原文： Auto Restart application after Crash/Force Close in Android. 手机上的Android应用，经常会出现“Force Close”的错误，这种情况一般是因为代码中没有正确获取到Exceptions。那么如果想让App在出现这种错误崩溃Crash以后自动重启，我们该怎么办呢？ 这篇教程我们将学到如何自动处理Exception，并且了解在App Crash以后如何自动重启。 其实方法很简单，这里我们需要用到 Thread.setDefaultUncaughtExceptionHandler()，当应用崩溃的时候代码就会自动调用 uncaughtException() 这个方法。","text":"英文原文： Auto Restart application after Crash/Force Close in Android. 手机上的Android应用，经常会出现“Force Close”的错误，这种情况一般是因为代码中没有正确获取到Exceptions。那么如果想让App在出现这种错误崩溃Crash以后自动重启，我们该怎么办呢？ 这篇教程我们将学到如何自动处理Exception，并且了解在App Crash以后如何自动重启。 其实方法很简单，这里我们需要用到 Thread.setDefaultUncaughtExceptionHandler()，当应用崩溃的时候代码就会自动调用 uncaughtException() 这个方法。 操作步骤如下： Step 1 像下面这样创建一个重启目标 Activity 的 Intent，并添加一些 Activity 启动的 Flags： 1234Intent intent = new Intent(activity, RelaunchActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); 其中， Intent.FLAG_ACTIVITY_CLEAR_TOP ： 销毁目标Activity和它之上的所有Activity，重新创建目标Activity。 Intent.FLAG_ACTIVITY_CLEAR_TASK ： 启动Activity时，清除之前已经存在的Activity实例所在的task，这自然也就清除了之前存在的Activity实例！ Intent.FLAG_ACTIVITY_NEW_TASK ： 很少单独使用，通常与FLAG_ACTIVITY_CLEAR_TASK或FLAG_ACTIVITY_CLEAR_TOP联合使用。 Step 2 在 uncaughtException() 方法中，添加如下代码： 12345678910PendingIntent pendingIntent = PendingIntent.getActivity( YourApplication.getInstance().getBaseContext(), 0, intent, intent.getFlags()); AlarmManager mgr = (AlarmManager) YourApplication.getInstance().getBaseContext() .getSystemService(Context.ALARM_SERVICE);mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, pendingIntent); activity.finish();System.exit(2); 这里的 PendingIntent 不同于常见的 Intent ，PendingIntent 是对 Intent 的一个包装，可以保存下来在将来某一刻执行。它存储了request code、intent 和 flags。 AlarmManager 是为了设置一个计时器来延迟两秒再执行 pendingIntent 的，也就是重启我们的Activity的任务。 Step 3 最后，在 Activity 的 onCreate() 方法中调用如下代码： 1Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler(this)); 【完整代码】 YourApplication.java 1234567891011121314151617181920212223242526272829import android.app.Application; /** * This custom class is used to Application level things. * * @author Chintan Rathod (http://www.chintanrathod.com) */public class YourApplication extends Application &#123; private static Context mContext; public static YourApplication instace; @Override public void onCreate() &#123; super.onCreate(); mContext = getApplicationContext(); instace = this; &#125; @Override public Context getApplicationContext() &#123; return super.getApplicationContext(); &#125; public static YourApplication getIntance() &#123; return instace; &#125;&#125; DefaultExceptionHandler.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.lang.Thread.UncaughtExceptionHandler;import java.text.SimpleDateFormat;import java.util.Date; import android.app.Activity;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.Environment;import android.util.Log; /** * This custom class is used to handle exception. * * @author Chintan Rathod (http://www.chintanrathod.com) */public class DefaultExceptionHandler implements UncaughtExceptionHandler &#123; private UncaughtExceptionHandler defaultUEH; Activity activity; public DefaultExceptionHandler(Activity activity) &#123; this.activity = activity; &#125; @Override public void uncaughtException(Thread thread, Throwable ex) &#123; try &#123; Intent intent = new Intent(activity, RelaunchActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity( YourApplication.getInstance().getBaseContext(), 0, intent, intent.getFlags()); //Following code will restart your application after 2 seconds AlarmManager mgr = (AlarmManager) YourApplication.getInstance().getBaseContext() .getSystemService(Context.ALARM_SERVICE); mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent); //This will finish your activity manually activity.finish(); //This will stop your application and take out from it. System.exit(2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【参考资料】： 1、Activity启动模式(二)之 Intent的Flag属性","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【SVN】使用patch命令保存更改","slug":"【SVN】使用patch命令保存更改","date":"2016-06-12T03:06:00.000Z","updated":"2016-10-18T04:57:14.094Z","comments":true,"path":"2016/06/12/【SVN】使用patch命令保存更改/","link":"","permalink":"http://github.com/2016/06/12/【SVN】使用patch命令保存更改/","excerpt":"使用svn管理工程代码时，有些时候的更改尚未整理好，需要暂时搁置，转而进行下一个任务，此时就需要将当前的更改（diff）暂时保存下来，忙完其他的任务之后再继续进行。但是如果不进行commit，怎么保存当前的更改呢？答案是使用 patch 命令！ 一、生成patch文件12svn diff &gt; patchFile // 整个工程的变动生成patchsvn diff FILE_NAME &gt; patchFile // 某个文件单独变动的patch 二、svn回滚123svn revert FILE // 单个文件回滚svn revert DIR --depth=infinity // 整个目录进行递归回滚svn revert . --depth=infinity // 当前目录进行递归回滚","text":"使用svn管理工程代码时，有些时候的更改尚未整理好，需要暂时搁置，转而进行下一个任务，此时就需要将当前的更改（diff）暂时保存下来，忙完其他的任务之后再继续进行。但是如果不进行commit，怎么保存当前的更改呢？答案是使用 patch 命令！ 一、生成patch文件12svn diff &gt; patchFile // 整个工程的变动生成patchsvn diff FILE_NAME &gt; patchFile // 某个文件单独变动的patch 二、svn回滚123svn revert FILE // 单个文件回滚svn revert DIR --depth=infinity // 整个目录进行递归回滚svn revert . --depth=infinity // 当前目录进行递归回滚 三、打patch12patch -p0 &lt; test.patch // -p0 选项要从当前目录查找目的文件（夹）patch -p1 &lt; test.patch // -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录（夹）","categories":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/categories/SVN/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/tags/SVN/"}],"keywords":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/categories/SVN/"}]},{"title":"【Java】按位存储：使用int存储boolean数组","slug":"【Java】按位存储：使用int存储boolean数组","date":"2016-06-02T03:55:00.000Z","updated":"2016-10-18T04:56:22.429Z","comments":true,"path":"2016/06/02/【Java】按位存储：使用int存储boolean数组/","link":"","permalink":"http://github.com/2016/06/02/【Java】按位存储：使用int存储boolean数组/","excerpt":"有一种场景，比如App设置页中会有一组开关选项，这个时候保存这些开关的状态，如果每个按钮都对应一个boolean值的话，太大材小用显得鸡肋，频繁读取SharedPreferences 存取效率自然快不过一次读取。 首先，敲定每个boolean值存储的位置12345private int mBroadcastCustomValue = 0; //用来存储的int值public static final int BROADCAST_TYPE_CUSTOM_BASE = 1; //基础类播报public static final int BROADCAST_TYPE_CUSTOM_TRAFFIC = 1 &lt;&lt; 1; //实时路况public static final int BROADCAST_TYPE_CUSTOM_CAMERA = 1 &lt;&lt; 2; //摄像头限速播报public static final int BROADCAST_TYPE_CUSTOM_SAFE = 1 &lt;&lt; 3; //安全提醒类 一、添加Add123456private void addLevel(int level)&#123; mBroadcastCustomValue |= level; //add&#125;//调用方式如下addLevel(BROADCAST_TYPE_CUSTOM_BASE);","text":"有一种场景，比如App设置页中会有一组开关选项，这个时候保存这些开关的状态，如果每个按钮都对应一个boolean值的话，太大材小用显得鸡肋，频繁读取SharedPreferences 存取效率自然快不过一次读取。 首先，敲定每个boolean值存储的位置12345private int mBroadcastCustomValue = 0; //用来存储的int值public static final int BROADCAST_TYPE_CUSTOM_BASE = 1; //基础类播报public static final int BROADCAST_TYPE_CUSTOM_TRAFFIC = 1 &lt;&lt; 1; //实时路况public static final int BROADCAST_TYPE_CUSTOM_CAMERA = 1 &lt;&lt; 2; //摄像头限速播报public static final int BROADCAST_TYPE_CUSTOM_SAFE = 1 &lt;&lt; 3; //安全提醒类 一、添加Add123456private void addLevel(int level)&#123; mBroadcastCustomValue |= level; //add&#125;//调用方式如下addLevel(BROADCAST_TYPE_CUSTOM_BASE); 二、删除Delete123456private void deleteLevel(int level)&#123; mBroadcastCustomValue ^= mBroadcastCustomValue &amp; level; //delete&#125;//调用方式如下deleteLevel(BROADCAST_TYPE_CUSTOM_BASE); 三、读取Read123456789101112/** * 从value中读取level的设置值，level即是某个boolean值的位置 */private boolean isLevelAccess(int value, int level)&#123; if((value &amp; level) == level)&#123; return true; &#125; return false;&#125;//调用方式如下boolean a = isLevelAccess(mBroadcastCustomValue, BROADCAST_TYPE_CUSTOM_BASE);","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】技术调研：用代码模拟屏幕点击、触摸事件","slug":"【Android】技术调研：用代码模拟屏幕点击、触摸事件","date":"2016-06-02T03:55:00.000Z","updated":"2016-10-18T04:55:38.831Z","comments":true,"path":"2016/06/02/【Android】技术调研：用代码模拟屏幕点击、触摸事件/","link":"","permalink":"http://github.com/2016/06/02/【Android】技术调研：用代码模拟屏幕点击、触摸事件/","excerpt":"在Android中，有些场景需要使用代码来模拟人的操作，比如微信自动抢红包、UI测试等都需要模拟实现点击事件（Click）、触摸事件（Touch）、键盘事件（KeyBoard）等。那么，有没有现成的方案可以实现呢？答案当然是肯定的啦，往下看。 经过调研发现，给系统模拟注入输入事件有如下几种方式： 一、使用shell命令使用android自带的adb shell，里面自带一个input工具，使用方法如下： 123adb shell #进入系统input keyevent KEYCODE_BACK #模拟按返回键input keyevent KEYCODE_HOME #模拟按Home键","text":"在Android中，有些场景需要使用代码来模拟人的操作，比如微信自动抢红包、UI测试等都需要模拟实现点击事件（Click）、触摸事件（Touch）、键盘事件（KeyBoard）等。那么，有没有现成的方案可以实现呢？答案当然是肯定的啦，往下看。 经过调研发现，给系统模拟注入输入事件有如下几种方式： 一、使用shell命令使用android自带的adb shell，里面自带一个input工具，使用方法如下： 123adb shell #进入系统input keyevent KEYCODE_BACK #模拟按返回键input keyevent KEYCODE_HOME #模拟按Home键 还可以直接输入点击屏幕的事件，模拟点击屏幕： 1input tap 100 200 #在屏幕坐标(100, 200)处点击 详细的用法如下： 二、使用 InstrumentationInstrumentation本身是Android用来做测试的工具，可以通过它监测系统与应用程序之间的交互。详情可以参考官方文档[Test Your App]。我们这里只关注怎么使用Instrumentation产生发送按键或者触屏事件。 它可以发送按键： 12Instrumentation mInst = new Instrumentation(); mInst.sendKeyDownUpSync(KeyEvent.KEYCODE_CAMERA); 也可以发送触屏事件：12345Instrumentation mInst = new Instrumentation(); mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, x, y, 0); //x,y 即是事件的坐标mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, x, y, 0); 与Shell工具一样，还有类似sendStringSync()发送文本，sendTrackballEventSync()发送轨迹球事件等方法。 1234sendCharacterSync(int keyCode) //用于发送指定KeyCode的按键sendKeyDownUpSync(int key) //用于发送指定KeyCode的按键sendPointerSync(MotionEvent event) //用于模拟TouchsendStringSync(String text) //用于发送字符串 需要注意的是，这些方法均不可以在UI主线程中执行，必须放到子线程中调用，否则就会报错。另外，使用上面的方法，需要在AndroidManifast.xml中申明如下权限： 1&lt;uses-permission android:name=\"android.permission.INJECT_EVENTS\"/&gt; 三、使用Android内部API在Android系统中，有些内部的API提供注入事件的方法。因为是内部API，在不同版本上可能变化比较大。使用如果想在普通App中使用，可能需要通过反射机制来调用。 在Android API 16之前，WindownManager有相应的方法提供注入事件的方法，如下： 123456IBinder wmbinder = ServiceManager.getService(\"window\"); IWindowManager wm = IWindowManager.Stub.asInterface(wmbinder); //pointer wm.injectPointerEvent(myMotionEvent, false); //key wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_A), false); wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_A), false); //trackball wm.injectTrackballEvent(myMotionEvent, false); 在API 15之后，引入了InputManager，把上面的哪些injectXXXEvent()方法从WindowManager中移除了。使用方法类似： 1234567891011121314IBinder imBinder = ServiceManager.getService(\"input\"); IInputManager im = IInputManager.Stub.asInterface(imBinder);//inject key eventfinal KeyEvent keyEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount, metaState, deviceId, scancode, flags | KeyEvent.FLAG_FROM_SYSTEM |KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_SOFT_KEYBOARD, source);event.setSource(InputDevice.SOURCE_ANY) im.injectInputEvent(keyEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);//inject pointer eventmotionEvent.setSource(InputDevice.SOURCE_TOUCHSCREEN); im.injectInputEvent(motionEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH); 从API 16开始，InputManager就成了一个公开的类了，可以通过如下方法获得InputManager实例： 1InputManager im = (InputManager) getSystemService(Context.INPUT_SERVICE); 注意，使用injectEvent()同样需要申明android:name=”android.permission.INJECT_EVENTS”权限。 四、可以考虑使用Monkey测试框架这种方案就是希望能够模拟Android Monkey的测试方法，不过博主并没有来得及对这方面进行深入的研究，可以参考这篇文章Android Monkey源码解析 【参考资料】：1、Android模拟产生事件2、Android 模拟键盘鼠标事件（Socket+Instrumentation实现）3、Android Monkey源码解析","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【MySQL】查询保持IN中的顺序","slug":"【MySQL】查询保持IN中的顺序","date":"2016-04-29T07:36:00.000Z","updated":"2016-10-18T04:57:07.725Z","comments":true,"path":"2016/04/29/【MySQL】查询保持IN中的顺序/","link":"","permalink":"http://github.com/2016/04/29/【MySQL】查询保持IN中的顺序/","excerpt":"select * from table_name where id in ()的时候，MySQL会自动按主键自增排序，要是按IN中给定的顺序来取，如何实现呢？ 比如下面这个查询结果，mysql会默认使用主键id的ASC自增排序结果集：","text":"select * from table_name where id in ()的时候，MySQL会自动按主键自增排序，要是按IN中给定的顺序来取，如何实现呢？ 比如下面这个查询结果，mysql会默认使用主键id的ASC自增排序结果集： 那么，如果我们想维持查询语句中IN(26613,26612,26611,26610,26609,26608,26607)的顺序可以么？当然可以，像下面这样，使用Order by field()： 1SELECT * from `models` where `id` in (26612,26611,26610) order by field(id,26612,26611,26610); 这样读取出来的顺序就是IN（）语句中的顺序。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/tags/MySQL/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/categories/MySQL/"}]},{"title":"【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决","slug":"【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决","date":"2016-04-29T03:37:09.000Z","updated":"2016-10-18T04:56:53.039Z","comments":true,"path":"2016/04/29/【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决/","link":"","permalink":"http://github.com/2016/04/29/【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决/","excerpt":"在Linux中执行.sh脚本，异常/bin/bash^M: bad interpreter: No such file or directory. 一、分析这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 二、解决1）在windows下转换：利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。","text":"在Linux中执行.sh脚本，异常/bin/bash^M: bad interpreter: No such file or directory. 一、分析这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 二、解决1）在windows下转换：利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。 2）直接在Linux中转换（推荐做法）： 首先要确保文件有可执行权限 1#sh&gt; chmod a+x filename 然后修改文件格式 1#sh&gt; vi filename 利用如下命令查看文件格式 1:set ff 或 :set fileformat 可以看到如下信息 fileformat=dos 或 fileformat=unix 利用如下命令修改文件格式 12:set ff=unix 或 :set fileformat=unix :wq (存盘退出) 最后再执行文件 1#sh&gt;./filename","categories":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}]},{"title":"”二分查找“算法的时间复杂度","slug":"”二分查找“算法的时间复杂度","date":"2016-04-06T06:03:00.000Z","updated":"2016-10-18T04:54:36.739Z","comments":true,"path":"2016/04/06/”二分查找“算法的时间复杂度/","link":"","permalink":"http://github.com/2016/04/06/”二分查找“算法的时间复杂度/","excerpt":"算法的时间复杂度无非就是for、while等包含起来的基本运算单元的循环次数 1、二分查找二分查找（binary search），也称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！","text":"算法的时间复杂度无非就是for、while等包含起来的基本运算单元的循环次数 1、二分查找二分查找（binary search），也称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！ 123456789101112131415161718//二分查找 Java 实现public static int binarySearch(Integer[] srcArray, int des) &#123; int low = 0; int high = srcArray.length - 1; while ((low &lt;= high) &amp;&amp; (low &lt;= srcArray.length - 1) &amp;&amp; (high &lt;= srcArray.length - 1)) &#123; int middle = (high + low) &gt;&gt; 1; if (des == srcArray[middle]) &#123; return middle; &#125; else if (des &lt; srcArray[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; return -1;&#125; 2、时间复杂度比如：总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。由于n/2^k取整后&gt;=1，即令n/2^k=1，可得k=log2n,（是以2为底，n的对数），所以时间复杂度可以表示O()=O(logn)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"给大家推荐一款Sublime Text的主题”brogrammer-theme“","slug":"给大家推荐一款Sublime Text的主题”brogrammer-theme“","date":"2016-03-30T08:46:00.000Z","updated":"2016-10-18T04:51:49.926Z","comments":true,"path":"2016/03/30/给大家推荐一款Sublime Text的主题”brogrammer-theme“/","link":"","permalink":"http://github.com/2016/03/30/给大家推荐一款Sublime Text的主题”brogrammer-theme“/","excerpt":"先给大家看一下这个主题的颜值：","text":"先给大家看一下这个主题的颜值： 快看安装方法：1、下载：https://github.com/kenwheeler/brogrammer-theme/archive/master.zip 2、解压后将文件夹改名成Theme - Brogrammer，然后打开sublime text3，找到里面的 Preferences -&gt; Browse Packages，将改名后的文件夹copy到弹出的文件夹中 3、然后首选项-&gt;设置用户（Preferences -&gt; setting uer），将下列代码拷进去： 1234&#123; &quot;color_scheme&quot;: &quot;Packages/brogrammer-theme-master/brogrammer.tmTheme&quot;, &quot;font_size&quot;: 10&#125; 【官方文档】： brogrammer-theme on Github Theme - Brogrammer on Package Control","categories":[],"tags":[],"keywords":[]},{"title":"【Android】Picasso加载本地图片如何清理缓存cache？","slug":"【Android】Picasso加载本地图片如何清理缓存cache？","date":"2016-03-08T07:03:00.000Z","updated":"2016-10-28T02:23:43.007Z","comments":true,"path":"2016/03/08/【Android】Picasso加载本地图片如何清理缓存cache？/","link":"","permalink":"http://github.com/2016/03/08/【Android】Picasso加载本地图片如何清理缓存cache？/","excerpt":"","text":"使用Picasso加载SD卡图片的时候，Picasso也会对该图片进行缓存。所以如果该图片即使已经变了，Picasso在加载时会仍然使用缓存，而不更新图片。 1、Picasso缓存策略我们都知道图片缓存使用的是Map键值对存储的，这里的Key就是加载的图片的Url，所以如果我们使用相同的ImageUrl去加载图片的话，如果使用了缓存，Picasso会直接读取缓存的内容，而不是从SD卡、或者网络Http中重新加载。 2、Picasso如何跳过缓存试了很多网上推荐的方法均不见起效，最后使用了下面这种策略，也就是加载图片时直接跳过缓存 1Picasso.with(getContext()).load(imageUrl).memoryPolicy(MemoryPolicy.NO_CACHE).into(image); 注意其中的.memoryPolicy(MemoryPolicy.NO_CACHE)即是关键代码，其中 MemoryPolicy.NO_CACHE：是指图片加载时放弃在内存缓存中查找。 MemoryPolicy.NO_STORE：是指图片加载完不缓存在内存中。 ps：此处的方法并不是真正的清理缓存，而是跳过缓存直接从源头获取。 网上有几种错误的方法如下，经验证均不起效： 1、Picasso.with(getActivity()).invalidate(file);2、Picasso.with(getActivity()).load(url).skipMemoryCache().into(image); 最后还是在StackOverFlow的Clear Cache memory of Picasso查到了如上的解决办法。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"如何生成100个1-100以内的不重复的随机数","slug":"如何生成100个1-100以内的不重复的随机数","date":"2016-01-22T03:55:00.000Z","updated":"2016-10-18T04:58:09.102Z","comments":true,"path":"2016/01/22/如何生成100个1-100以内的不重复的随机数/","link":"","permalink":"http://github.com/2016/01/22/如何生成100个1-100以内的不重复的随机数/","excerpt":"这是个经典的面试题目：生成长度为100的数组，插入1-100以内的但均不重复的随机数 一、简单实现思路:(1) 把N个数放入Hashtable 或者arrayList 中. (2) 从上面的集合中随机抽取一个数放入int数组中. (3) 把取出的这个数从上面的集合中删除. (4) 循环 (2),(3) 步骤,直到int数组取满为止.","text":"这是个经典的面试题目：生成长度为100的数组，插入1-100以内的但均不重复的随机数 一、简单实现思路:(1) 把N个数放入Hashtable 或者arrayList 中. (2) 从上面的集合中随机抽取一个数放入int数组中. (3) 把取出的这个数从上面的集合中删除. (4) 循环 (2),(3) 步骤,直到int数组取满为止. 这是一种比较简单的实现思路，实现代码如下： 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collections;import java.util.Random;public class Main &#123; private static int range = 100; private static ArrayList&lt;Integer&gt; originalList = new ArrayList&lt;Integer&gt;(); private static ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); static &#123; for (int i = 1; i &lt;= range; i++) &#123; originalList.add(i); &#125; &#125; public static void main(String args[]) &#123; for (int i = 0; i &lt; range; i++) &#123; int j = range - i; int r = (int) (new Random().nextInt(j)); result.add(originalList.get(r)); System.out.print(originalList.get(r) + \", \"); originalList.remove(r); &#125; Collections.sort(result); System.out.println(\"\\n\\n生成的数组大小是：\" + result.size() + \"------以下是排序结果，看是否有重复的随机数\"); for (Integer i : result) &#123; System.out.print(i + \", \"); &#125; &#125;&#125; 执行结果如下： 123474, 75, 47, 76, 59, 94, 2, 33, 23, 66, 60, 13, 44, 34, 7, 92, 11, 86, 4, 38, 26, 55, 64, 99, 1, 54, 30, 72, 80, 87, 15, 24, 25, 37, 83, 49, 28, 81, 79, 35, 18, 68, 61, 46, 98, 58, 85, 29, 39, 48, 53, 14, 8, 91, 42, 36, 65, 62, 6, 52, 21, 78, 63, 73, 16, 88, 5, 69, 19, 51, 50, 43, 40, 70, 89, 10, 12, 71, 96, 45, 93, 9, 31, 22, 95, 20, 17, 3, 67, 90, 41, 82, 57, 84, 100, 32, 77, 27, 97, 56, 生成的数组大小是：100------以下是排序结果，看是否有重复的随机数1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 二、改进算法我们一般都会想到这种做法,但是当Hashtable或者ArrayList中放几千万,几亿数据时,这时从集合中删除元素将严重影响性能,如果突破此瓶颈? 网上找到一种更好的方法. (1) 把N个数放到容器A(int数组)中.(2) 从N个数中随机取出1个数放入容器B(int数组)中.(3) 把容器A中最后一个数与随机抽取的数对调 或者 把容器A中最后一个数覆盖随机抽取出来的数.(4) 这时从容器A(假设N个数,索引0 到 索引N-2)之间随机取一个数.再放入容器B中,重复此步骤. 说明：也就是第二次是从容器A中 第一个元素到倒数第二个元素 中随机取一个数.这种好处是,随机数所取范围逐步缩小,而且杜绝了大数据时集合执行删除操作时产生的瓶颈. 所以，向下面这样实现会更好： 1234567891011121314151617181920212223242526272829public class Main &#123; private static int range = 100; private static int[] result; public static void main(String args[]) &#123; result = getNumber(range); for (int i = 0; i &lt; range; i++) &#123; System.out.print(result[i] + \", \"); &#125; &#125; public static int[] getNumber(int total)&#123; int[] NumberBox = new int[total]; //容器A int[] rtnNumber = new int[total]; //容器B for (int i = 0; i &lt; total; i++)&#123; NumberBox[i] = i; //先把N个数放入容器A中 &#125; int end = total - 1; for (int j = 0; j &lt; total; j++)&#123; int num = new Random().nextInt(end + 1); //取随机数 rtnNumber[j] = NumberBox[num]; //把随机数放入容器B NumberBox[num] = NumberBox[end]; //把容器A中最后一个数覆盖所取的随机数 end--; //缩小随机数所取范围 &#125; return rtnNumber; //返回int型数组 &#125;&#125; 执行结果如下： 180, 9, 70, 22, 3, 63, 12, 81, 73, 41, 90, 83, 27, 71, 88, 5, 40, 18, 25, 37, 55, 60, 93, 87, 17, 89, 99, 84, 32, 96, 62, 98, 77, 30, 23, 35, 47, 24, 21, 53, 95, 7, 85, 2, 65, 1, 39, 43, 76, 46, 42, 91, 4, 26, 52, 86, 34, 54, 38, 78, 31, 11, 66, 36, 50, 75, 16, 68, 56, 33, 48, 15, 74, 69, 49, 6, 58, 10, 29, 92, 64, 59, 28, 61, 45, 19, 14, 13, 44, 72, 94, 20, 97, 51, 67, 79, 0, 82, 8, 57,","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】如何查看Activity Task栈的情况","slug":"【Android】如何查看Activity Task栈的情况","date":"2016-01-19T03:48:00.000Z","updated":"2016-10-18T04:55:43.216Z","comments":true,"path":"2016/01/19/【Android】如何查看Activity Task栈的情况/","link":"","permalink":"http://github.com/2016/01/19/【Android】如何查看Activity Task栈的情况/","excerpt":"我们都知道，每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。 如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一、查看task栈情况 在cmd命令行里或者Android Studio中的Terminal里敲入如下命令：1adb shell dumpsys activity 然后会出现很长一段详细信息，滚到中间的地方，会看到Task栈的状态如下：","text":"我们都知道，每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。 如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一、查看task栈情况 在cmd命令行里或者Android Studio中的Terminal里敲入如下命令：1adb shell dumpsys activity 然后会出现很长一段详细信息，滚到中间的地方，会看到Task栈的状态如下： 此外，这些信息的最底部还可以看到当前显示在前台的Activity是哪一个，还有使用设备的分辨率等信息","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Java中的封装、继承与多态","slug":"Java中的封装、继承与多态","date":"2016-01-15T07:43:20.000Z","updated":"2016-10-18T04:57:38.022Z","comments":true,"path":"2016/01/15/Java中的封装、继承与多态/","link":"","permalink":"http://github.com/2016/01/15/Java中的封装、继承与多态/","excerpt":"这次我们来了解一下面向对象的三大基石封装，继承、多态，然后大致对比一下继承和多态的区别。 一、封装： 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。","text":"这次我们来了解一下面向对象的三大基石封装，继承、多态，然后大致对比一下继承和多态的区别。 一、封装： 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。 Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 下面用表格的形式来展示四种访问权限之间的异同点，这样会更加形象。注意其中protected和default的区别，表格如下所示： 权限修饰符 同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ 二、继承 通过继承可以实现代码的复用，使子类可以拥有父类的一些属性和方法。继承应该符合下列规则： 继承是可传递的。如果C从B中派生，B又从A中派生，那么C不仅继承了B中声明的成员，同样也继承了A中的成员。Object类作为所有类的基类。 派生类应当是对基类的扩展。派生类可以添加新的成员，但不能除去已经继承的成员的定义。构造函数和析构函数不能被继承。除此之外的其它成员，不论对它们定义了怎样的访问方式，都能被继承。基类中成员的访问方式只能决定派生类能否访问它们。 派生类如果定义了与继承而来的成员同名的新成员，就可以覆盖已继承的成员。但这并不因为这派生类删除了这些成员，只是不能再访问这些成员。 类可以定义为abstract抽象类，它的派生类就能够重载这些成员，从而实现类可以展示出多态性。 三、多态 多态就是指父类的某个方法被子类重写时，可以各自产生自己的功能行为。同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。 可以这么说：编译时看父类，运行时看子类。运行时的多态性就是指直到系统运行时，才根据实际情况决定实现何种操作。C#中，运行时的多态性通过虚成员实现。 父类A a = new 父类的子类B();a.方法();//这就是多态 实现多态的方式： 接口多态性。 继承多态性。 通过抽象类实现的多态性。 四、继承与多态的区别 网上看到一个有趣的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。 继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。可以这么说：编译时看父类，运行时看子类。 【参考资料】：1、java类的访问权限2、继承、封装、多态3、java中继承和多态区别.4、重载，继承，重写和多态的区别","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"Java访问权限修饰符的区别","slug":"Java访问权限修饰符的区别","date":"2016-01-15T07:07:20.000Z","updated":"2016-10-18T04:57:34.963Z","comments":true,"path":"2016/01/15/Java访问权限修饰符的区别/","link":"","permalink":"http://github.com/2016/01/15/Java访问权限修饰符的区别/","excerpt":"Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。","text":"Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 下面用表格的形式来展示四种访问权限之间的异同点，这样会更加形象。注意其中protected和default的区别，表格如下所示： 权限修饰符 同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ 【参考资料】：1、java类的访问权限","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？","slug":"【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？","date":"2016-01-05T07:31:00.000Z","updated":"2016-10-18T04:57:17.588Z","comments":true,"path":"2016/01/05/【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？/","link":"","permalink":"http://github.com/2016/01/05/【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？/","excerpt":"走台阶算法（本质上是斐波那契数列）在面试中常会遇到，描述就如题目那样：总共100级台阶（任意级都行），小明每次可选择走1步、2步或者3步，问走完这100级台阶总共有多少种走法？ 一、 题目分析这个问题本质上是斐波那契数列，假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。将上面的斐波那契数列代码稍微改一下就是本题的答案。我们来看一下代码的实现。 二、斐波那契数列法1234567891011121314151617181920public class Test &#123; static final int s = 100; //自定义的台阶数 static int compute(int stair)&#123; if ( stair &lt;= 0)&#123; return 0; &#125; if (stair == 1)&#123; return 1; &#125; if (stair == 2)&#123; return 2; &#125; return compute(stair-1) + compute(stair-2); &#125; public static void main(String args[]) &#123; System.out.println(\"共有\" + compute(s) + \"种走法\"); &#125;&#125;","text":"走台阶算法（本质上是斐波那契数列）在面试中常会遇到，描述就如题目那样：总共100级台阶（任意级都行），小明每次可选择走1步、2步或者3步，问走完这100级台阶总共有多少种走法？ 一、 题目分析这个问题本质上是斐波那契数列，假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。将上面的斐波那契数列代码稍微改一下就是本题的答案。我们来看一下代码的实现。 二、斐波那契数列法1234567891011121314151617181920public class Test &#123; static final int s = 100; //自定义的台阶数 static int compute(int stair)&#123; if ( stair &lt;= 0)&#123; return 0; &#125; if (stair == 1)&#123; return 1; &#125; if (stair == 2)&#123; return 2; &#125; return compute(stair-1) + compute(stair-2); &#125; public static void main(String args[]) &#123; System.out.println(\"共有\" + compute(s) + \"种走法\"); &#125;&#125; 三、 走台阶问题的简单解决算法但我自己对于这个题目最早的想法是使用树（多叉树）的方式，100为根节点，每次选择的分支有两种（1、2），然后生成深度为1的树，再从每个2级节点延伸出1、2两个分支，直到所有节点的值&lt;=0，最后统计出所有值为0的叶子节点的数目，就是结果。 不过自己想法实际上把问题复杂化了，下面这种使用递归方式实现的算法本质上和我的思想差不多，但是很明显下面这个算法会简单很多。接下来我们来看看这个算法的实现方式。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test &#123; static final int s = 100; //自定义的台阶数 static int len = 0, sum = 0; //最多也只有走100步就到了 static int step[] = new int[s]; static void compute(final int stair) &#123; if (stair &lt; 0) return; //表示已经走完了 if (stair == 0) &#123; printSum(); sum++; return; &#125; //每次到下一步选择时都可以走1-2步 for (int i = 1; i &lt;= 2; i++) &#123; step[len] = i; len++; //进行下一步的迭代，迭代完之后将每后加上的一步去掉，换成其它的步数(如从1换成2) compute(stair - i); len--; &#125; &#125; static void printSum() &#123; System.out.print(\"走法:\"); for (int i = 0; i &lt; len; i++) System.out.print(step[i] + \" \"); System.out.println(); &#125; public static void main(String args[]) &#123; compute(s); System.out.println(\"共有\" + sum + \"种走法\"); &#125; &#125; 【参考资料】： 面试题9:斐波那契数列 - xwdreamer - 博客园 PHP上台阶问题（斐波纳契数列应用）","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"新主题酝酿中...","slug":"新主题酝酿中","date":"2016-01-04T07:08:00.000Z","updated":"2016-11-09T10:16:15.037Z","comments":true,"path":"2016/01/04/新主题酝酿中/","link":"","permalink":"http://github.com/2016/01/04/新主题酝酿中/","excerpt":"人们对于“美”，都有着超乎自己想象的执念。 图集 from Dribbble","text":"人们对于“美”，都有着超乎自己想象的执念。 图集 from Dribbble from Dribbble from Dribbble from Dribbble Website New York Times Akina theme 淡腾 louie iacool EndSkin Wordpress主题 HERO 主题（黑白） （报纸黑白）FASHIONISTA 漂亮的蒙层","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}]},{"title":"【Java】内部类（Inner Class）如何创建（new）","slug":"【Java】内部类（Inner Class）如何创建（new）","date":"2016-01-02T13:13:20.000Z","updated":"2016-10-18T04:56:45.206Z","comments":true,"path":"2016/01/02/【Java】内部类（Inner Class）如何创建（new）/","link":"","permalink":"http://github.com/2016/01/02/【Java】内部类（Inner Class）如何创建（new）/","excerpt":"简单来说，内部类（inner class）指那些类定义代码被置于其它类定义中的类；而对于一般的、类定义代码不嵌套在其它类定义中的类，称为顶层（top-level）类。对于一个内部类，包含其定义代码的类称为它的外部（outer）类。 那么对于内部类，该如何去使用呢？ 下面给出静态成员类（Static Member Class）和普通成员类（Member Class）使用的方式。 12345678910111213141516package cuc;import cuc.TestClass.Inner1;public class Main &#123; public static void main(String args[]) &#123; //静态的内部类 TestClass.Inner1 inner1 = new Inner1(); //和普通的顶层类new的方法一样 inner1.report(); //普通内部成员类 TestClass tc = new TestClass(); TestClass.Inner2 inner2 = tc.new Inner2(); //注意这里的使用方式 inner2.report(); &#125;&#125;","text":"简单来说，内部类（inner class）指那些类定义代码被置于其它类定义中的类；而对于一般的、类定义代码不嵌套在其它类定义中的类，称为顶层（top-level）类。对于一个内部类，包含其定义代码的类称为它的外部（outer）类。 那么对于内部类，该如何去使用呢？ 下面给出静态成员类（Static Member Class）和普通成员类（Member Class）使用的方式。 12345678910111213141516package cuc;import cuc.TestClass.Inner1;public class Main &#123; public static void main(String args[]) &#123; //静态的内部类 TestClass.Inner1 inner1 = new Inner1(); //和普通的顶层类new的方法一样 inner1.report(); //普通内部成员类 TestClass tc = new TestClass(); TestClass.Inner2 inner2 = tc.new Inner2(); //注意这里的使用方式 inner2.report(); &#125;&#125; 两种内部类的定义如下： 123456789101112131415161718package cuc;public class TestClass &#123; //静态成员类 public static class Inner1&#123; public void report()&#123; System.out.println(\"This is a inner class. (NOT static)\"); &#125; &#125; //普通内部成员类 public class Inner2&#123; public void report()&#123; System.out.println(\"This is a static inner class.\"); &#125; &#125;&#125; 【参考资料】：1、java - 内部类(Inner Class)详解","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】 加解密算法 HMAC 的使用","slug":"【Android】 加解密算法 HMAC 的使用","date":"2015-12-31T07:30:00.000Z","updated":"2016-10-18T04:54:48.598Z","comments":true,"path":"2015/12/31/【Android】 加解密算法 HMAC 的使用/","link":"","permalink":"http://github.com/2015/12/31/【Android】 加解密算法 HMAC 的使用/","excerpt":"1、HMAC算法 &nbsp;&nbsp; HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 &nbsp;&nbsp;简而言之，HMAC就是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。关于hmac算法的详情可以参看RFC 2104(http://www.ietf.org/rfc/rfc2104.txt)，这里包含了HmacMD5算法的C语言实现。","text":"1、HMAC算法 &nbsp;&nbsp; HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 &nbsp;&nbsp;简而言之，HMAC就是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。关于hmac算法的详情可以参看RFC 2104(http://www.ietf.org/rfc/rfc2104.txt)，这里包含了HmacMD5算法的C语言实现。 2、代码实现（Android）12345678910111213141516171819202122232425262728293031323334//这是HMAC的Android代码//之所以不是Java是因为代码中的Base64使用的是android.util包下的Base64类，而不是Java自带的Base64类。public class HMACTest &#123; private static final String LOG_TAG = \"HMACTest\"; private static final String REGISTER_HMAC_KEY = \"12a9cc3f-1fd9-48a3-1fd9-1fd9d027ac2\"; private String stringToSign(String data) &#123; try &#123; Mac mac = Mac.getInstance(\"HmacSHA1\"); SecretKeySpec secret = new SecretKeySpec( REGISTER_HMAC_KEY.getBytes(\"UTF-8\"), mac.getAlgorithm()); mac.init(secret); return Base64.encodeToString(mac.doFinal(data.getBytes()), Base64.NO_WRAP); &#125; catch (NoSuchAlgorithmException e) &#123; Log.e(LOG_TAG, \"Hash algorithm SHA-1 is not supported\", e); &#125; catch (UnsupportedEncodingException e) &#123; Log.e(LOG_TAG, \"Encoding UTF-8 is not supported\", e); &#125; catch (InvalidKeyException e) &#123; Log.e(LOG_TAG, \"Invalid key\", e); &#125; return \"\"; &#125; /* * 测试函数 */ public static void test() &#123; HMACTest hmac = new HMACTest(); String str = \"Bello, Miss.Seven\"; System.out.println(\"加密前：\" + str); System.out.println(\"加密后：\" + hmac.stringToSign(str)); &#125;&#125; 【参考资料】：1、消息摘要算法-HMAC算法2、Java 加解密技术系列之 HMAC","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息","slug":"【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息","date":"2015-12-25T02:57:55.000Z","updated":"2016-10-18T04:54:56.856Z","comments":true,"path":"2015/12/25/【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息/","link":"","permalink":"http://github.com/2015/12/25/【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息/","excerpt":"Android App打包成Apk后，其实是一个压缩文件，可以将后缀名apk改为zip然后用winrar打开也能看到里面的文件结构。还能看到AndroidManifest.xml。但是里面的内容经过编码显示为乱码，不方便查看。 — aapt工具： &nbsp;&nbsp;这里我们可以使用aapt工具来查看。aapt.exe工具即Android Asset Packaging Tool，在SDK的build-tools目录下。 &nbsp;&nbsp;该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE插件会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。","text":"Android App打包成Apk后，其实是一个压缩文件，可以将后缀名apk改为zip然后用winrar打开也能看到里面的文件结构。还能看到AndroidManifest.xml。但是里面的内容经过编码显示为乱码，不方便查看。 — aapt工具： &nbsp;&nbsp;这里我们可以使用aapt工具来查看。aapt.exe工具即Android Asset Packaging Tool，在SDK的build-tools目录下。 &nbsp;&nbsp;该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE插件会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。 &nbsp;&nbsp;也就是说平时我们不会用这个东西，但是打包成Apk的时候其实是用到了的，只不过IDE替我们做了这一步，那么我们就用这个工具来查看VersionCode和VersionName。 — 操作流程： 1、首先找到aapt工具，在Android SDK文件夹下的build-tools包里，如下： 1cd D:\\Android\\SDK\\build-tools\\23.0.0_rc3 2、然后使用aapt dump bading XXX.apk就能看到VersionCode等信息 1aapt dump badging C:\\Users\\kuguan\\Desktop\\app-release_1.0.9.apk","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】不用循环语句如何输入打印数组元素","slug":"【Java】不用循环语句如何输入打印数组元素","date":"2015-12-09T05:58:20.000Z","updated":"2016-10-18T04:56:25.580Z","comments":true,"path":"2015/12/09/【Java】不用循环语句如何输入打印数组元素/","link":"","permalink":"http://github.com/2015/12/09/【Java】不用循环语句如何输入打印数组元素/","excerpt":"","text":"Java中可以使用Arrays.toString()来输出数组，免了使用各种循环来挨个print的痛苦。 123456789package javacc.test;import java.util.Arrays; public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;0,1,4,7,2,5,8,3,6,9&#125;; System.out.println(Arrays.toString(array)); //注意这里的 Arrays.toString() &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】Activity与Fragment的生命周期的关系","slug":"【Android】Activity与Fragment的生命周期的关系","date":"2015-11-25T06:31:55.000Z","updated":"2016-10-18T04:54:53.001Z","comments":true,"path":"2015/11/25/【Android】Activity与Fragment的生命周期的关系/","link":"","permalink":"http://github.com/2015/11/25/【Android】Activity与Fragment的生命周期的关系/","excerpt":"一、问题描述： 假设有两个Activity（1和2）,每个Activity拥有一个Fragment，并分别有一个Button，点击Button1可以start Activity2，然后点击Button2可以finish掉自己（即Activity2）,然后返回到Activity1。根据这个简单模型描述一下Activity和Fragment的生命周期之间的依赖关系？","text":"一、问题描述： 假设有两个Activity（1和2）,每个Activity拥有一个Fragment，并分别有一个Button，点击Button1可以start Activity2，然后点击Button2可以finish掉自己（即Activity2）,然后返回到Activity1。根据这个简单模型描述一下Activity和Fragment的生命周期之间的依赖关系？ 二、生命周期知识 Activity和Fragment的生命周期图谱可以参考我的另外一篇博客：【Android】Fragment的生命周期详解，他们的关系大致如下图： 三、代码验证 MainActivity和SecondActivity的布局是这样的，里面各添加了一个Fragment： 12345678910111213141516171819202122232425/** * MainActivity布局xml文件 */&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:text=&quot;开启第二个Activity&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;/Button&gt; &lt;LinearLayout android:id=&quot;@+id/linearlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#339999&quot;&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * MainActivity.java代码，SecondActivity的代码与之类似，这里就不贴那么多了 */public class MainActivity extends Activity &#123; private static final String LOG_TAG = &quot;MainActivity&quot;; private Button mButton; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.w(LOG_TAG, &quot;==============onCreate()&quot;); FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); FirstFragment firstFragment = new FirstFragment(); fragmentTransaction.add(R.id.linearlayout, firstFragment); fragmentTransaction.commit(); mButton = (Button) findViewById(R.id.button); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.w(LOG_TAG, &quot;------------------mButton onClick-------------------&quot;); startActivity(new Intent(MainActivity.this, SecondActivity.class)); &#125; &#125;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.w(LOG_TAG, &quot;==============onStart()&quot;); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.w(LOG_TAG, &quot;==============onRestart()&quot;); &#125; @Override protected void onResume() &#123; super.onResume(); Log.w(LOG_TAG, &quot;==============onResume()&quot;); &#125; @Override protected void onPause() &#123; super.onPause(); Log.w(LOG_TAG, &quot;==============onPause()&quot;); &#125; @Override protected void onStop() &#123; super.onStop(); Log.w(LOG_TAG, &quot;==============onStop()&quot;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.w(LOG_TAG, &quot;==============onDestroy()&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * FirstFragment.java代码， SecondFragment和它差不多一样 */public class FirstFragment extends Fragment &#123; private static final String LOG_TAG = &quot;FirstFragment&quot;; private static final String ARG_PARAM1 = &quot;param1&quot;; private static final String ARG_PARAM2 = &quot;param2&quot;; private String mParam1; private String mParam2; public FirstFragment() &#123; &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); Log.w(LOG_TAG, &quot;onAttach...&quot;); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.w(LOG_TAG, &quot;onCreate...&quot;); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.w(LOG_TAG, &quot;onCreateView...&quot;); return inflater.inflate(R.layout.fragment_first, container, false); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.w(LOG_TAG, &quot;onActivityCreated...&quot;); &#125; @Override public void onStart() &#123; super.onStart(); Log.w(LOG_TAG, &quot;onStart...&quot;); &#125; @Override public void onResume() &#123; super.onResume(); Log.w(LOG_TAG, &quot;onResume...&quot;); &#125; @Override public void onPause() &#123; super.onPause(); Log.w(LOG_TAG, &quot;onPause...&quot;); &#125; @Override public void onStop() &#123; super.onStop(); Log.w(LOG_TAG, &quot;onStop...&quot;); &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); Log.w(LOG_TAG, &quot;onDestroyView...&quot;); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(LOG_TAG, &quot;onDestroy...&quot;); &#125; @Override public void onDetach() &#123; super.onDetach(); Log.w(LOG_TAG, &quot;onDetach...&quot;); &#125;&#125; 四、运行结果 1、第一次打开以后： 123456789com.example.kuguan.anlearning W/MainActivity﹕ ==============onCreate()com.example.kuguan.anlearning W/FirstFragment﹕ onAttach...com.example.kuguan.anlearning W/FirstFragment﹕ onCreate...com.example.kuguan.anlearning W/FirstFragment﹕ onCreateView...com.example.kuguan.anlearning W/FirstFragment﹕ onActivityCreated...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume... 2、点击MainActivity中的按钮“打开第二个Activity”以后： 12345678910111213com.example.kuguan.anlearning W/MainActivity﹕ ----------------mButton onClick-----------------com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/SecondFragment﹕ onAttach...com.example.kuguan.anlearning W/SecondFragment﹕ onCreate...com.example.kuguan.anlearning W/SecondFragment﹕ onCreateView...com.example.kuguan.anlearning W/SecondFragment﹕ onActivityCreated...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onStart()com.example.kuguan.anlearning W/SecondFragment﹕ onStart...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onResume()com.example.kuguan.anlearning W/SecondFragment﹕ onResume...com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop() 3、点击SecondActivity的按钮“finish”之后： 1234567891011121314com.example.kuguan.anlearning W/SecondActivity﹕ -----------------mButton onClick------------------com.example.kuguan.anlearning W/SecondFragment﹕ onPause...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onPause()com.example.kuguan.anlearning W/MainActivity﹕ ==============onRestart()com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume...com.example.kuguan.anlearning W/SecondFragment﹕ onStop...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onStop()com.example.kuguan.anlearning W/SecondFragment﹕ onDestroyView...com.example.kuguan.anlearning W/SecondFragment﹕ onDestroy...com.example.kuguan.anlearning W/SecondFragment﹕ onDetach...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onDestroy() 4、点击back键使MainActivity退到后台： 12345678com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop()com.example.kuguan.anlearning W/FirstFragment﹕ onDestroyView...com.example.kuguan.anlearning W/FirstFragment﹕ onDestroy...com.example.kuguan.anlearning W/FirstFragment﹕ onDetach...com.example.kuguan.anlearning W/MainActivity﹕ ==============onDestroy() 5、在MianActivity显示的时候，按HOME键： 1234com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop() 6、然后再点击Icon打开： 12345com.example.kuguan.anlearning W/MainActivity﹕ ==============onRestart()com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume... 【参考资料】：1、Fragment和Activity","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Fragment的生命周期详解","slug":"【Android】Fragment的生命周期详解","date":"2015-11-25T03:43:55.000Z","updated":"2016-10-18T04:55:08.663Z","comments":true,"path":"2015/11/25/【Android】Fragment的生命周期详解/","link":"","permalink":"http://github.com/2015/11/25/【Android】Fragment的生命周期详解/","excerpt":"作为Android开发的基础知识，大家可能都了解Activity的生命周期，但是Fragment的生命周期和Activity生命周期之间的关系到底是怎么样的呢？相互调用机制又如何呢？ 一、我们首先观察一下Activity的生命周期：","text":"作为Android开发的基础知识，大家可能都了解Activity的生命周期，但是Fragment的生命周期和Activity生命周期之间的关系到底是怎么样的呢？相互调用机制又如何呢？ 一、我们首先观察一下Activity的生命周期： Fragment生命周期： Activity和Fragment生命周期的对比图：【参考资料】：1、Android Fragment源代码2、API Doc for fragments (Fragments | Android Developers)3、Fragment生命周期","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】长按连续触发事件的实现方法","slug":"【Android】长按连续触发事件的实现方法","date":"2015-11-19T06:35:55.000Z","updated":"2016-10-18T04:56:01.785Z","comments":true,"path":"2015/11/19/【Android】长按连续触发事件的实现方法/","link":"","permalink":"http://github.com/2015/11/19/【Android】长按连续触发事件的实现方法/","excerpt":"项目中需要实现一个类似购物车数量的小组件，需要单击时增加数量，长按时可以连续增大，之前的代码实现效果不理想，google后得到一个解决方法,测试可以完美实现。 实现效果大致如图： 【原理说明】 大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。","text":"项目中需要实现一个类似购物车数量的小组件，需要单击时增加数量，长按时可以连续增大，之前的代码实现效果不理想，google后得到一个解决方法,测试可以完美实现。 实现效果大致如图： 【原理说明】 大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。 【实现】 1、首先,让对应的View设置一个OnTouchListener，在手指按下时触发不停的发送消息,手指抬起时停止发送。 1234567891011subtractButton.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; updateAddOrSubtract(v.getId()); //手指按下时触发不停的发送消息 &#125;else if(event.getAction() == MotionEvent.ACTION_UP)&#123; stopAddOrSubtract(); //手指抬起时停止发送 &#125; return true; &#125; &#125;); 2、发送消息与终止方法：先定义一个ScheduledExecutorService对象，然后调用scheduleWithFixedDelay()方法 1234567891011121314151617181920private ScheduledExecutorService scheduledExecutor;private void updateAddOrSubtract(int viewId) &#123; final int vid = viewId; scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); scheduledExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.what = vid; handler.sendMessage(msg); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); //每间隔100ms发送Message &#125; private void stopAddOrSubtract() &#123; if (scheduledExecutor != null) &#123; scheduledExecutor.shutdownNow(); scheduledExecutor = null; &#125; &#125; 3、用来处理Touch事件的Handler定义如下：1234567891011121314private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; int viewId = msg.what; switch (viewId)&#123; case R.id.custom_number_picker_subtract_button: setValue(value - rangeability); //减小操作 break; case R.id.custom_number_picker_add_button: setValue(value + rangeability); //增大操作 break; &#125; &#125; &#125;;","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】HashMap 和 HashTable 的区别到底是什么？","slug":"【Java】HashMap 和 HashTable 的区别到底是什么？","date":"2015-11-10T03:55:00.000Z","updated":"2016-10-18T04:56:18.669Z","comments":true,"path":"2015/11/10/【Java】HashMap 和 HashTable 的区别到底是什么？/","link":"","permalink":"http://github.com/2015/11/10/【Java】HashMap 和 HashTable 的区别到底是什么？/","excerpt":"第一、继承不同第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 12public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;...&#125;public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;...&#125; 而HashMap继承的抽象类AbstractMap实现了Map接口： 1public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;...&#125;","text":"第一、继承不同第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 12public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;...&#125;public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;...&#125; 而HashMap继承的抽象类AbstractMap实现了Map接口： 1public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;...&#125; 第二、线程安全不一样Hashtable 中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 12345678910111213141516171819202122232425262728293031323334//这是Hashtable的put()方法:/** * Associate the specified value with the specified key in this * &#123;@code Hashtable&#125;. If the key already exists, the old value is replaced. * The key and value cannot be null. * * @param key * the key to add. * @param value * the value to add. * @return the old value associated with the specified key, or &#123;@code null&#125; * if the key did not exist. * @see #elements * @see #get * @see #keys * @see java.lang.Object#equals */ public synchronized V put(K key, V value) &#123; if (key == null) &#123; throw new NullPointerException(\"key == null\"); &#125; else if (value == null) &#123; throw new NullPointerException(\"value == null\"); &#125; int hash = Collections.secondaryHash(key); HashtableEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashtableEntry&lt;K, V&gt; first = tab[index]; for (HashtableEntry&lt;K, V&gt; e = first; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; 123456789101112131415161718192021222324252627//这是HashMap的put()方法:/** * Maps the specified key to the specified value. * * @param key * the key. * @param value * the value. * @return the value of any previous mapping with the specified key or * &#123;@code null&#125; if there was no such mapping. */ @Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; 从上面的源代码可以看到Hashtable的put()方法是synchronized的，而HashMap的put()方法却不是。 第三、允不允许null值从上面的put()方法源码可以看到，Hashtable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。而在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 第四、遍历方式的内部实现上不同Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 第五、哈希值的使用不同HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 第六、内部实现方式的数组的初始大小和扩容的方式不一样HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 【总结】： HashMap 线程不安全 允许有null的键和值 效率高一点、 方法不是Synchronize的要提供外同步 有containsvalue和containsKey方法 HashMap 是Java1.2 引进的Map interface 的一个实现 HashMap是Hashtable的轻量级实现 Hashtable 线程安全 不允许有null的键和值 效率稍低、 方法是是Synchronize的 有contains方法方法 Hashtable 继承于Dictionary 类 Hashtable 比HashMap 要旧 【建议】： 一些资料建议，当需要同步时，用Hashtable，反之用HashMap。但是，因为在需要时，HashMap可以被同步，HashMap的功能比Hashtable的功能更多，而且它不是基于一个陈旧的类的，所以有人认为，在各种情况下，HashMap都优先于Hashtable。 【参考资料】： 1、Hashtable、HashMap源代码 2、Java的HashMap和HashTable 3、HashMap与HashTable的区别","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"各种排序算法时间复杂度和空间复杂度表","slug":"各种排序算法时间复杂度和空间复杂度表","date":"2015-11-03T03:55:00.000Z","updated":"2016-10-18T04:57:49.647Z","comments":true,"path":"2015/11/03/各种排序算法时间复杂度和空间复杂度表/","link":"","permalink":"http://github.com/2015/11/03/各种排序算法时间复杂度和空间复杂度表/","excerpt":"各种排序算法时间复杂度和空间复杂度表: 比较时间复杂度函数的情况如下图： 对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法： 接下来博主抽时间要整理一下各经典算法思想和心得，敬请期待","text":"各种排序算法时间复杂度和空间复杂度表: 比较时间复杂度函数的情况如下图： 对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法： 接下来博主抽时间要整理一下各经典算法思想和心得，敬请期待 一、快速排序（Quicksort）12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Arrays;public class MySort &#123; public static void main(String args[])&#123; int[] array = &#123;5,3,9,1,6,4,10,2,8,7&#125;; System.out.println(&quot;Before: &quot; + Arrays.toString(array)); new MySort().quickSort(array, 0, array.length-1); System.out.println(&quot;After: &quot; + Arrays.toString(array)); &#125; /** * 快速排序： 递归实现的挖坑填数法 * @param array * @param left * @param right */ private void quickSort(int[] array, int left, int right)&#123; if(left &gt;= right)&#123; return; &#125; int i = left; int j = right; int key = array[left]; while(i&lt;j)&#123; while(array[j] &gt;= key &amp;&amp; i&lt;j)&#123; //从后向前搜索，比key小的值就挖出来填到i处的坑 j--; &#125; array[i] = array[j]; while(array[i] &lt;= key &amp;&amp; i&lt;j)&#123; //从前向后搜索，找出比key大的值填到刚才j处空缺的坑 i++; &#125; array[j] = array[i]; &#125; array[i] = key; //把key回填到数组的空缺处 System.out.println(&quot;Sort: &quot; + Arrays.toString(array)); quickSort(array, left, i-1); quickSort(array, i+1, right); &#125;&#125; 1234567891011快速排序的测试代码输出结果如下：Before: [5, 3, 9, 1, 6, 4, 10, 2, 8, 7]Sort: [2, 3, 4, 1, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 4, 3, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]Sort: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]Sort: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]After: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 【参考资料】： 白话经典算法系列之六 快速排序 快速搞定","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Java】函数中的参数传递是“引用传递”还是“值传递”？","slug":"【Java】函数中的参数传递是“引用传递”还是“值传递”？","date":"2015-11-02T07:33:20.000Z","updated":"2016-10-18T04:56:41.696Z","comments":true,"path":"2015/11/02/【Java】函数中的参数传递是“引用传递”还是“值传递”？/","link":"","permalink":"http://github.com/2015/11/02/【Java】函数中的参数传递是“引用传递”还是“值传递”？/","excerpt":"问题引入：在一个快速排序的函数 private void quickSort(List intList, int left, int right) 中，传进去的参数intList是对象传递还是引用传递呢？ 先抛出结论： 将对象（对象的引用）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的对象。 当将基本类型或基本类型的包装集作为参数传递时，传递的是值。也就是说函数内对参数所做的修改不会影响原来的变量。 数组(数组引用)）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的数组。 String类型(引用)作为参数传递时传递的是引用，只是对String做出任何修改时有一个新的String对象会产生，原来的String对象的值不会做任何修改。(但是可以将新的对象的 引用赋给原来的引用,这样给人的表面现象就是原来的对象变了，其实没有变，只是原来指向它的引用指向了新的对象)。","text":"问题引入：在一个快速排序的函数 private void quickSort(List intList, int left, int right) 中，传进去的参数intList是对象传递还是引用传递呢？ 先抛出结论： 将对象（对象的引用）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的对象。 当将基本类型或基本类型的包装集作为参数传递时，传递的是值。也就是说函数内对参数所做的修改不会影响原来的变量。 数组(数组引用)）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的数组。 String类型(引用)作为参数传递时传递的是引用，只是对String做出任何修改时有一个新的String对象会产生，原来的String对象的值不会做任何修改。(但是可以将新的对象的 引用赋给原来的引用,这样给人的表面现象就是原来的对象变了，其实没有变，只是原来指向它的引用指向了新的对象)。 举例一：123456789101112131415161718192021222324252627282930313233343536373839404142public class Mainjava &#123; String str=new String(&quot;good&quot;); char[] ch=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;; Integer i = 0; int x = 0; Test t1 = new Test(); Test t2 = new Test(); public static void main(String args[])&#123; Mainjava ex=new Mainjava(); ex.change(ex.str,ex.ch, ex.x, ex.i, ex.t1, ex.t2); System.out.print(ex.str + &quot; and &quot;); System.out.print(String.valueOf(ex.ch) + &quot; and &quot;); System.out.print(ex.x + &quot;,&quot; + ex.i + &quot;,&quot; + ex.t1.getA() + &quot;,&quot; + ex.t2.getA()); &#125; public void change(String str, char ch[], int x, Integer i, Test t1, Test t2)&#123; str=&quot;test ok&quot;; ch[0]=&apos;g&apos;; x = 2; i = 5; Test newT = new Test(); newT.setA(99); t1 = newT; t2.setA(33); &#125;&#125;//Test类public class Test &#123; private int a = 0; public void setA(int a)&#123; this.a = a; &#125; public int getA()&#123; return a; &#125;&#125; 输出结果是多少呢？ good and gbc and 0,0,0,33 为什么不是”test ok and gbc and 2,5,99,33”呢？ 因为str是引用数据类型String,而字符数组是基本数据类型,二者存放在内存中的机制是不一样的!12345public void change(String str, char ch[], int x)&#123; str = &quot;test ok&quot;; ch[0] = &apos;g&apos;; x = 2;&#125; change()方法传入str,虽然把”test ok”强行赋给str,但是这里的str存放在新的栈内存中,和原来的str存放的地址不一样,所以你System.out.print(ex.str+”and”);这里的输出还是调用原来内存中的str;字符数组不一样,你声明一个字符数组之后,那个数组的位置就定死了,你调用change()之后,把原来的字符数组的第1个元素改为了g.这就是引用数据类型和基本数据类型的区别。 举例二： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.ArrayList;import java.util.List;public class Mainjava &#123; public static void main(String args[])&#123; List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;(); integerList.add(7); integerList.add(1); integerList.add(3); integerList.add(8); integerList.add(9); integerList.add(2); integerList.add(5); integerList.add(4); integerList.add(10); integerList.add(6); print(integerList); quickSort(integerList, 0, integerList.size()-1); print(integerList); /*对比排序前后的integerList中的值，如果发生改变，说明是引用传递，即传递的是对象地址值*/ &#125; private static void quickSort(List&lt;Integer&gt; intList, int left, int right)&#123; if(left &gt;= right) &#123; return; &#125; int i = left; int j = right; int key = intList.get(i); System.out.println(&quot;key:&quot;+&quot;intList.get(&quot;+i+&quot;)=&quot;+key); while(i &lt; j)&#123; while(i &lt; j &amp;&amp; intList.get(j) &gt;= key)&#123; j--; &#125; intList.set(i, intList.get(j)); while(i &lt; j &amp;&amp; intList.get(i) &lt;= key)&#123; i++; &#125; intList.set(j, intList.get(i)); &#125; intList.set(i, key); quickSort(intList, left, i - 1); quickSort(intList, i + 1, right); &#125; private static void print(List&lt;Integer&gt; intList)&#123; for (int i = 0; i &lt; intList.size(); i++) &#123; System.out.print(intList.get(i)+&quot;, &quot;); &#125; System.out.println(&quot;&quot;); &#125;&#125; 运行输出结果如下： 7, 1, 3, 8, 9, 2, 5, 4, 10, 6,key:intList.get(0)=7key:intList.get(0)=6key:intList.get(0)=2key:intList.get(2)=3key:intList.get(3)=4key:intList.get(7)=91, 2, 3, 4, 5, 6, 7, 8, 9, 10, 结论： 实验证明，Java中函数传递对象时，传递的是该对象的地址值，即引用传递。函数传递基本类型数据时，传递的是值，也就是说函数返回之后不会改变这个值。","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】onActivityResult()和onResume()的调用顺序问题","slug":"【Android】onActivityResult()和onResume()的调用顺序问题","date":"2015-09-18T09:16:55.000Z","updated":"2016-10-18T04:55:17.484Z","comments":true,"path":"2015/09/18/【Android】onActivityResult()和onResume()的调用顺序问题/","link":"","permalink":"http://github.com/2015/09/18/【Android】onActivityResult()和onResume()的调用顺序问题/","excerpt":"在Android生命周期中，如果使用到startActivityForResult()，则在新Activity被finish掉之后，onActivityResult()和onResume()到底是哪一个先调用的呢？ 我们来看官方源码： /** * Called when an activity you launched exits, giving you the requestCode * you started it with, the resultCode it returned, and any additional * data from it. The &lt;var&gt;resultCode&lt;/var&gt; will be * {@link #RESULT_CANCELED} if the activity explicitly returned that, * didn't return any result, or crashed during its operation. * * &lt;p&gt;You will receive this call immediately before onResume() when your * activity is re-starting. * * &lt;p&gt;This method is never invoked if your activity sets * {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to * &lt;code&gt;true&lt;/code&gt;. * * @param requestCode The integer request code originally supplied to * startActivityForResult(), allowing you to identify who this * result came from. * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \"extras\"). * * @see #startActivityForResult * @see #createPendingResult * @see #setResult(int) */ protected void onActivityResult(int requestCode, int resultCode, Intent data) { }","text":"在Android生命周期中，如果使用到startActivityForResult()，则在新Activity被finish掉之后，onActivityResult()和onResume()到底是哪一个先调用的呢？ 我们来看官方源码： /** * Called when an activity you launched exits, giving you the requestCode * you started it with, the resultCode it returned, and any additional * data from it. The &lt;var&gt;resultCode&lt;/var&gt; will be * {@link #RESULT_CANCELED} if the activity explicitly returned that, * didn't return any result, or crashed during its operation. * * &lt;p&gt;You will receive this call immediately before onResume() when your * activity is re-starting. * * &lt;p&gt;This method is never invoked if your activity sets * {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to * &lt;code&gt;true&lt;/code&gt;. * * @param requestCode The integer request code originally supplied to * startActivityForResult(), allowing you to identify who this * result came from. * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \"extras\"). * * @see #startActivityForResult * @see #createPendingResult * @see #setResult(int) */ protected void onActivityResult(int requestCode, int resultCode, Intent data) { } &#160; &#160; &#160; &#160;从上面的源码注释第二段可以看到：You will receive this call immediately before onResume() when your activity is re-starting. 所以很明显，在activity重新恢复启动的时候，onActivityResult()会在onResume()之前调用完毕。 &#160; &#160; &#160; &#160;而且，onActivityResult()还会在onStart()之前调用完毕。经过断点调试，发现它们三者的调用顺序如下： onActivityResult() -&gt; onStart() -&gt; onResume()","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】如何启动调用其他app中的Activity","slug":"【Android】如何启动调用其他app中的Activity","date":"2015-09-15T03:06:00.000Z","updated":"2016-10-18T04:55:55.045Z","comments":true,"path":"2015/09/15/【Android】如何启动调用其他app中的Activity/","link":"","permalink":"http://github.com/2015/09/15/【Android】如何启动调用其他app中的Activity/","excerpt":"最近项目正在将原系统拆分为小型App，所以需要在原Project中启动另一个新的App中的Activity。这样的话启动要用到ComponentName ，它就是用来打开其他应用程序中的Activity或服务的。 用法其实很简单，像下面这样： 123456//第一个参数是Activity所在的package包名，第二个参数是完整的Class类名（包括包路径）ComponentName componetName = new ComponentName(\"com.cybo3d.cybox.miya\", \"com.cybo3d.cybox.miya.MainActivity\");Intent intent = new Intent();intent.setComponent(componetName);startActivity(intent);","text":"最近项目正在将原系统拆分为小型App，所以需要在原Project中启动另一个新的App中的Activity。这样的话启动要用到ComponentName ，它就是用来打开其他应用程序中的Activity或服务的。 用法其实很简单，像下面这样： 123456//第一个参数是Activity所在的package包名，第二个参数是完整的Class类名（包括包路径）ComponentName componetName = new ComponentName(\"com.cybo3d.cybox.miya\", \"com.cybo3d.cybox.miya.MainActivity\");Intent intent = new Intent();intent.setComponent(componetName);startActivity(intent); 我们来看源码中ComponentName的参数信息，pkg和cls均不能为null。此处特别注意第二个参数cls必须为 完整的Class类名。 1234567891011121314/** * Create a new component identifier. * * @param pkg The name of the package that the component exists in. Can * not be null. * @param cls The name of the class inside of &lt;var&gt;pkg&lt;/var&gt; that * implements the component. Can not be null. */ public ComponentName(String pkg, String cls) &#123; if (pkg == null) throw new NullPointerException(\"package name is null\"); if (cls == null) throw new NullPointerException(\"class name is null\"); mPackage = pkg; mClass = cls; &#125; 另外，在调用的时候一定要保证在Manifest.xml中设置被启动Activity的exported=true，否则会报错Activity is not found.","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】保存图片到系统图库, 并立即显示在图库中","slug":"【Android】保存图片到系统图库, 并立即显示在图库中","date":"2014-09-12T03:55:00.000Z","updated":"2016-10-18T04:55:26.176Z","comments":true,"path":"2014/09/12/【Android】保存图片到系统图库, 并立即显示在图库中/","link":"","permalink":"http://github.com/2014/09/12/【Android】保存图片到系统图库, 并立即显示在图库中/","excerpt":"搬运原链接：http://stormzhang.github.io/android/2014/07/24/android-save-image-to-gallery 正文最近有些用户反映保存图片之后在系统图库找不到保存的图片，遂决定彻底查看并解决下。 Android中保存图片的方法可能有如下两种： 第一种是自己写方法，如下代码： 123456789101112131415161718public static File saveImage(Bitmap bmp) &#123; File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","text":"搬运原链接：http://stormzhang.github.io/android/2014/07/24/android-save-image-to-gallery 正文最近有些用户反映保存图片之后在系统图库找不到保存的图片，遂决定彻底查看并解决下。 Android中保存图片的方法可能有如下两种： 第一种是自己写方法，如下代码： 123456789101112131415161718public static File saveImage(Bitmap bmp) &#123; File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 以上代码便是将Bitmap保存图片到指定的路径/sdcard/Boohee/下，文件名以当前系统时间命名,但是这种方法保存的图片没有加入到系统图库中 第二种是调用系统提供的插入图库的方法： 1MediaStore.Images.Media.insertImage(getContentResolver(), bitmap, \"title\", \"description\"); 调用以上系统自带的方法会把bitmap对象保存到系统图库中，但是这种方法无法指定保存的路径和名称，上述方法的title、description参数只是插入数据库中的字段，真实的图片名称系统会自动分配。 看似上述第二种方法就是我们要用到的方法，但是可惜的调用上述第二种插入图库的方法图片并没有立刻显示在图库中，而我们需要立刻更新系统图库以便让用户可以立刻查看到这张图片。 更新系统图库的方法1sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(\"file://\"+ Environment.getExternalStorageDirectory()))); 上面那条广播是扫描整个sd卡的广播，如果你sd卡里面东西很多会扫描很久，在扫描当中我们是不能访问sd卡，所以这样子用户体现很不好，所以下面我们还有如下的方法： 1sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(\"/sdcard/Boohee/image.jpg\")));); 或者还有如下方法： 123456789final MediaScannerConnection msc = new MediaScannerConnection(mContext, new MediaScannerConnectionClient() &#123; public void onMediaScannerConnected() &#123; msc.scanFile(\"/sdcard/Boohee/image.jpg\", \"image/jpeg\"); &#125; public void onScanCompleted(String path, Uri uri) &#123; Log.v(TAG, \"scan completed\"); msc.disconnect(); &#125; &#125;); 上面代码的图片路径不管是通过自己写方法还是系统插入图库的方法都可以很容易的获取到。 终极完美解决方案那么到这里可能有人又会问了，如果我想把图片保存到指定的文件夹，同时又需要图片出现在图库里呢？答案是可以的，sdk还提供了这样一个方法: 1MediaStore.Images.Media.insertImage(getContentResolver(), \"image path\", \"title\", \"description\"); 上述方法的第二个参数是image path，这样的话就有思路了，首先自己写方法把图片指定到指定的文件夹，然后调用上述方法把刚保存的图片路径传入进去，最后通知图库更新。 所以写了一个方法，完整的代码如下： 1234567891011121314151617181920212223242526272829public static void saveImageToGallery(Context context, Bitmap bmp) &#123; // 首先保存图片 File appDir = new File(Environment.getExternalStorageDirectory(), &quot;Boohee&quot;); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + &quot;.jpg&quot;; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 其次把文件插入到系统图库 try &#123; MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), fileName, null); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; // 最后通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot; + path)));&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"如何删除多行首字母，Sublime Text多行编辑运用","slug":"如何删除多行首字母，Sublime Text多行编辑运用","date":"2014-05-15T03:55:00.000Z","updated":"2016-10-18T04:58:04.697Z","comments":true,"path":"2014/05/15/如何删除多行首字母，Sublime Text多行编辑运用/","link":"","permalink":"http://github.com/2014/05/15/如何删除多行首字母，Sublime Text多行编辑运用/","excerpt":"一、问题描述：问答区有个问题是这样问的：如何在eclipse中删除多行首字母？ 题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？我们在进行代码重用的时候时常会出现行号同时被复制的情况，比如下面的这点代码： 12345678910111213141516171819202122232425262728155. @Override 156. public boolean onKeyDown(int keyCode, KeyEvent event) 157. &#123; 158. Log.d(\"onKeyDown:\", \" keyCode=\" + keyCode + \" KeyEvent=\" + event); 159. switch (keyCode) 160. &#123; 161. case KeyEvent.KEYCODE_DPAD_UP: 162. 163. break; 164. case KeyEvent.KEYCODE_DPAD_DOWN: 165. 166. break; 167. case KeyEvent.KEYCODE_DPAD_LEFT: 168. //右左按键可以控制第一进度的增减 169. pb.setProgress( pb.getProgress()-5 ); 170. break; 171. case KeyEvent.KEYCODE_DPAD_RIGHT: 172. pb.setProgress( pb.getProgress()+5 ); 173. break; 174. case KeyEvent.KEYCODE_DPAD_CENTER: 175. 176. break; 177. case KeyEvent.KEYCODE_0: 178. break; 179. &#125; 180. return super.onKeyDown(keyCode, event); 181. &#125; 182. &#125;","text":"一、问题描述：问答区有个问题是这样问的：如何在eclipse中删除多行首字母？ 题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？我们在进行代码重用的时候时常会出现行号同时被复制的情况，比如下面的这点代码： 12345678910111213141516171819202122232425262728155. @Override 156. public boolean onKeyDown(int keyCode, KeyEvent event) 157. &#123; 158. Log.d(\"onKeyDown:\", \" keyCode=\" + keyCode + \" KeyEvent=\" + event); 159. switch (keyCode) 160. &#123; 161. case KeyEvent.KEYCODE_DPAD_UP: 162. 163. break; 164. case KeyEvent.KEYCODE_DPAD_DOWN: 165. 166. break; 167. case KeyEvent.KEYCODE_DPAD_LEFT: 168. //右左按键可以控制第一进度的增减 169. pb.setProgress( pb.getProgress()-5 ); 170. break; 171. case KeyEvent.KEYCODE_DPAD_RIGHT: 172. pb.setProgress( pb.getProgress()+5 ); 173. break; 174. case KeyEvent.KEYCODE_DPAD_CENTER: 175. 176. break; 177. case KeyEvent.KEYCODE_0: 178. break; 179. &#125; 180. return super.onKeyDown(keyCode, event); 181. &#125; 182. &#125; 这是博主从别处摘来的代码粘贴在Eclipse中的，很明显行号也被复制了进来。 对于这样的问题，如果代码行数真的多到可以用来数绵羊了，还用Delete键一行一行地解决可真就轻而易举地抑郁了哭 #其实我有特别的患抑郁症技巧# 二、解决办法：解决办法就是利用Sublime Text的多行编辑功能删除掉行首的序号。在Sublime Text中打开或者粘贴你想清理的代码，然后选中所有行 选中需要清理的所有行 按下Ctrl + Shift + L（Command + Shift + L）——— 可以同时编辑这些行 用左右方向键把光标移动到行首，然后按下 Delete键 或者 Backspace退格键 来删除行号。","categories":[],"tags":[],"keywords":[]},{"title":"Ubuntu上Eclipse识别不了Android手机的解决方法","slug":"Ubuntu上Eclipse识别不了Android手机的解决方法","date":"2013-10-20T08:46:00.000Z","updated":"2016-10-18T04:57:41.236Z","comments":true,"path":"2013/10/20/Ubuntu上Eclipse识别不了Android手机的解决方法/","link":"","permalink":"http://github.com/2013/10/20/Ubuntu上Eclipse识别不了Android手机的解决方法/","excerpt":"转载链接： http://www.cnblogs.com/AndroidManifest/archive/2011/12/09/2281635.html google官方开发向导里对Android手机已经设置了允许安装非market程序，并且处于usb调试模式，但是仍然在usb连接电脑后无法被识别的问题作了解释。官方网址：http://developer.android.com/guide/developing/device.html 操作步骤：如果是windows平台下，需要安装一个为adb准备的usb驱动。如果是Ubuntu Linux需要添加一个rules文件，里面包含了每一个想要调试的设备的usb配置信息。以HTC手机为例实现步骤如下： 1、在终端输入 : 1sudo gedit /etc/udev/rules.d/51-android.rules","text":"转载链接： http://www.cnblogs.com/AndroidManifest/archive/2011/12/09/2281635.html google官方开发向导里对Android手机已经设置了允许安装非market程序，并且处于usb调试模式，但是仍然在usb连接电脑后无法被识别的问题作了解释。官方网址：http://developer.android.com/guide/developing/device.html 操作步骤：如果是windows平台下，需要安装一个为adb准备的usb驱动。如果是Ubuntu Linux需要添加一个rules文件，里面包含了每一个想要调试的设备的usb配置信息。以HTC手机为例实现步骤如下： 1、在终端输入 : 1sudo gedit /etc/udev/rules.d/51-android.rules 2、在打开的文件里加入 SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0bb4&quot;, MODE=&quot;0666&quot; 3、保存退出后在终端执行 : 1sudo chmod a+r /etc/udev/rules.d/51-android.rules 重新将手机连接到电脑后HTC手机就可以被正常识别了。注意：如果按步骤操作仍不能识别的，检查 ATTR{idVendor} 值里的字母是否是小写。 如果是别的厂家的手机，需要在步骤2更改ATTR{idVendor}的值。如果要添加多个厂家的手机，重复步骤2。其他usb供应商的ID如下： Company USB Vendor ID Acer 0502 ASUS 0B05 Dell 413C Foxconn 0489 Garmin-Asus 091E Google 18D1 HTC 0BB4 Huawei 12D1 K-Touch 24E3 KT Tech 2116 Kyocera 0482 Lenevo 17EF LG 1004 Motorola 22B8 NEC 0409 Nook 2080 Nvidia 0955 OTGV 2257 Pantech 10A9 Pegatron 1D4D Philips 0471 PMC-Sierra 04DA Qualcomm 05C6 SK Telesys 1F53 Samsung 04E8 Sharp 04DD Sony Ericsson 0FCE Toshiba 0930 ZTE 19D2 注意：如果按步骤操作仍不能识别的，检查 ATTR{idVendor} 值里的字母是否是小写。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】操作excel表，包括创建、读取、以及修改","slug":"【Java】操作excel表，包括创建、读取、以及修改","date":"2013-08-01T04:31:20.000Z","updated":"2016-10-18T04:56:35.699Z","comments":true,"path":"2013/08/01/【Java】操作excel表，包括创建、读取、以及修改/","link":"","permalink":"http://github.com/2013/08/01/【Java】操作excel表，包括创建、读取、以及修改/","excerpt":"作者的网站上对它的特征有如下描述： 支持Excel 95-2000的所有版本 生成Excel 2000标准格式 支持字体、数字、日期操作 能够修饰单元格属性 支持图像和图表 应该说以上功能已经能够大致满足我们的需要。最关键的是这套API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 搭建环境下载jxl.jar（可以点击这里进行下载），放入classpath，安装就完成了。","text":"作者的网站上对它的特征有如下描述： 支持Excel 95-2000的所有版本 生成Excel 2000标准格式 支持字体、数字、日期操作 能够修饰单元格属性 支持图像和图表 应该说以上功能已经能够大致满足我们的需要。最关键的是这套API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 搭建环境下载jxl.jar（可以点击这里进行下载），放入classpath，安装就完成了。 基本操作一、创建文件拟生成一个名为“测试数据.xls”的Excel文件，其中第一个工作表被命名为“第一页”。代码（CreateXLS.java）： 12345678910111213141516171819202122232425262728293031323334//生成Excel的类 import java.io. * ;import jxl. * ;import jxl.write. * ;public class CreateXLS &#123; public static void main(String args[]) &#123; try &#123; //打开文件 WritableWorkbook book = Workbook.createWorkbook(new File(“测试.xls”)); //生成名为“第一页”的工作表，参数0表示这是第一页 WritableSheet sheet = book.createSheet(“第一页”, 0); //在Label对象的构造子中指名单元格位置是第一列第一行(0,0) //以及单元格内容为test Label label = new Label(0, 0, ”test”); //将定义好的单元格添加到工作表中 sheet.addCell(label); /*生成一个保存数字的单元格, 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123*/ jxl.write.Number number = new jxl.write.Number(1, 0, 789.123); sheet.addCell(number); //写入数据并关闭文件 book.write(); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 编译执行后，会在当前位置产生一个Excel文件。 二、读取文件以刚才我们创建的Excel文件为例，做一个简单的读取操作，程序代码如下： 1234567891011121314151617181920//读取Excel的类 import java.io. * ;import jxl. * ;public class ReadXLS &#123; public static void main(String args[]) &#123; try &#123; Workbook book = Workbook.getWorkbook(new File(“测试.xls”)); //获得第一个工作表对象 Sheet sheet = book.getSheet(0); //得到第一列第一行的单元格 Cell cell1 = sheet.getCell(0, 0); String result = cell1.getContents(); System.out.println(result); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 三、修改文件利用jExcelAPI可以修改已有的Excel文件，修改Excel文件的时候，除了打开文件的方式不同之外，其他操作和创建Excel是一样的。下面的例子是在我们已经生成的Excel文件中添加一个工作表： 12345678910111213141516171819202122//修改Excel的类，添加一个工作表 import java.io.*;import jxl.*;import jxl.write.*;public class UpdateXLS &#123; public static void main(String args[]) &#123; try &#123; //Excel获得文件 Workbook wb = Workbook.getWorkbook(new File(“测试.xls”)); //打开一个文件的副本，并且指定数据写回到原文件 WritableWorkbook book = Workbook.createWorkbook(new File(“测试.xls”), wb); //添加一个工作表 WritableSheet sheet = book.createSheet(“第二页”, 1); sheet.addCell(new Label(0, 0, ”第二页的测试数据”)); book.write(); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 高级操作一、 数据格式化在Excel中不涉及复杂的数据类型，能够比较好的处理字串、数字和日期已经能够满足一般的应用。 1、 字串格式化字符串的格式化涉及到的是字体、粗细、字号等元素，这些功能主要由WritableFont和WritableCellFormat类来负责。假设我们在生成一个含有字串的单元格时，使用如下语句，为方便叙述，我们为每一行命令加了编号： WritableFont font1=new WritableFont(WritableFont.TIMES,16,WritableFont.BOLD); 或//设置字体格式为excel支持的格式 WritableFont font3=new WritableFont(WritableFont.createFont(“楷体 _GB2312”),12,WritableFont.NO_BOLD );① WritableCellFormat format1=new WritableCellFormat(font1); ② Label label=new Label(0,0,”data 4 test”,format1) ③ 其中①指定了字串格式：字体为TIMES，字号16，加粗显示。WritableFont有非常丰富的构造子，供不同情况下使用，jExcelAPI的 java-doc中有详细列表，这里不再列出。 ②处代码使用了WritableCellFormat类，这个类非常重要，通过它可以指定单元格的各种属性，后面的单元格格式化中会有更多描述。 ③处使用了Label类的构造子，指定了字串被赋予那种格式。 在WritableCellFormat类中，还有一个很重要的方法是指定数据的对齐方式，比如针对我们上面的实例，可以指定： 12345678//把水平对齐方式指定为居中 format1.setAlignment(jxl.format.Alignment.CENTRE); //把垂直对齐方式指定为居中 format1.setVerticalAlignment(jxl.format.VerticalAlignment.CENTRE);//设置自动换行format1.setWrap(true); 二、单元格操作Excel中很重要的一部分是对单元格的操作，比如行高、列宽、单元格合并等，所幸jExcelAPI提供了这些支持。这些操作相对比较简单，下面只介绍一下相关的API。 1、 合并单元格 WritableSheet.mergeCells(int m,int n,int p,int q);作用是从(m,n)到(p,q)的单元格全部合并，比如： 123WritableSheet sheet=book.createSheet(“第一页”,0); //合并第一列第一行到第六列第一行的所有单元格 sheet.mergeCells(0,0,5,0); 合并既可以是横向的，也可以是纵向的。合并后的单元格不能再次进行合并，否则会触发异常。 2、 行高和列宽 WritableSheet.setRowView(int i,int height);作用是指定第i+1行的高度，比如： 12//将第一行的高度设为200 sheet.setRowView(0,200); WritableSheet.setColumnView(int i,int width);作用是指定第i+1列的宽度，比如： 12//将第一列的宽度设为30 sheet.setColumnView(0,30); 三、操作图片123456789public static void write() throws Exception &#123; WritableWorkbook wwb = Workbook.createWorkbook(new File(\"c:/1.xls\")); WritableSheet ws = wwb.createSheet(\"Test Sheet 1\", 0); File file = new File(\"C:\\\\jbproject\\\\PVS\\\\WebRoot\\\\weekhit\\\\1109496996281.png\"); WritableImage image = new WritableImage(1, 4, 6, 18, file); ws.addImage(image); wwb.write(); wwb.close();&#125; 很简单和插入单元格的方式一样，不过就是参数多了些，WritableImage这个类继承了Draw，上面只是他构造方法的一种，最后一个参数不用了说 了，前面四个参数的类型都是double，依次是 x, y, width, height,注意，这里的宽和高可不是图片的宽和高，而是图片所要占的单位格的个数，因为继承的Draw所以他的类型必须是double，具体里面怎么 实现的我还没细看：）因为着急赶活，先完成功能，其他的以后有时间慢慢研究。以后会继续写出在使用中的心得给大家。 总结1、读 读的时候是这样的一个思路,先用一个输入流(InputStream)得到Excel文件,然后用jxl中的Workbook得到工作薄,用Sheet从工作薄中得到工作表,用Cell得到工作表中得某个单元格.InputStream-&gt;Workbook-&gt;Sheet-&gt;Cell,就得到了excel文件中的单元格 12345678String path = \"c:\\\\excel.xls\"; //Excel文件URLInputStream is = new FileInputStream(path); //写入到FileInputStreamjxl.Workbook wb = Workbook.getWorkbook(is); //得到工作薄 jxl.Sheet st = wb.getSheet(0); //得到工作薄中的第一个工作表Cell cell = st.getCell(0, 0); //得到工作表的第一个单元格,即A1String content = cell.getContents(); //getContents()将Cell中的字符转为字符串wb.close(); //关闭工作薄is.close(); //关闭输入流 我们可以通过Sheet的getCell(x,y)方法得到任意一个单元格,x,y和excel中的坐标对应.例如A1对应(0,0),A2对应(0,1),D3对应(3,2).Excel中坐标从A,1开始,jxl中全部是从0开始.还可以通过Sheet的getRows(),getColumns()方法得到行数列数,并用于循环控制,输出一个sheet中的所有内容. 2、写 往Excel中写入内容主要是用jxl.write包中的类.思路是这样的:OutputStream&lt;-WritableWorkbook&lt;-WritableSheet&lt;-Label这里面Label代表的是写入Sheet的Cell位置及内容. 123456789101112131415OutputStream os = new FileOutputStream(\"c:\\\\test.xls\"); WritableWorkbook wwb = Workbook.createWorkbook(os); WritableSheet ws = wwb.createSheet(\"sheet1\", 0); //创建可写工作表Label labelCF = new Label(0, 0, \"hello\"); //创建写入位置和内容ws.addCell(labelCF); //将Label写入sheet中//Label的构造函数Label(int x, int y,String aString)xy意同读的时候的xy,aString是写入的内容.WritableFont wf = new WritableFont(WritableFont.TIMES, 12, WritableFont.BOLD, false); //设置写入字体WritableCellFormat wcfF = new WritableCellFormat(wf); //设置CellFormatLabel labelCF = new Label(0, 0, \"hello\"); //创建写入位置,内容和格式//Label的另一构造函数Label(int c, int r, String cont, CellFormat st)可以对写入内容进行格式化,设置字体及其它的属性. wwb.write();wwb.close();os.close; OK,只要把读和写结合起来,就可以在N个Excel中读取数据写入你希望的Excel新表中,还是比较方便的. 下面是程序代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243sql = \"select * from tablename\";rs = stmt.executeQuery(sql);//新建Excel文件String filePath = request.getRealPath(\"aaa.xls\");File myFilePath = new File(filePath);if (!myFilePath.exists()) myFilePath.createNewFile();FileWriter resultFile = new FileWriter(myFilePath);PrintWriter myFile = new PrintWriter(resultFile);resultFile.close();//用JXL向新建的文件中添加内容OutputStream outf = new FileOutputStream(filePath);jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(outf);jxl.write.WritableSheet ws = wwb.createSheet(\"sheettest\", 0);int i = 0;int j = 0;for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123; ws.addCell(new Label(k, 0, rs.getMetaData().getColumnName(k + 1)));&#125;while (rs.next()) &#123; out.println(rs.getMetaData().getColumnCount()); for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123; ws.addCell(new Label(k, j + i + 1, rs.getString(k + 1))); &#125; i++;&#125;wwb.write();wwb.close();&#125; catch(Exception e) &#123; e.printStackTrace();&#125; finally &#123; rs.close(); conn.close();&#125;response.sendRedirect(\"aaa.xls\");","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]}]}