{"meta":{"title":"iTimeTraveler","subtitle":null,"description":"Someone knock at the door.","author":"Mr.Seven","url":"http://github.com"},"pages":[{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2016-12-23T07:06:52.141Z","comments":true,"path":"about/index.html","permalink":"http://github.com/about/index.html","excerpt":"","text":"That maybe happiness is something that we can only pursue. And maybe we can actually never have it….no matter what. Be stupid is a part in my life. This part of my life is called “happiness“. Profile Bello, guys. I am ： iTimeTraveler I’m an Android Developer + prefer Python &amp; Golang + interest in AI(Artificial Intelligence) + Google radicals（Golang+Docker+Kubernetes+AngularJS) ContactYou can reach me by Email: iTime Github: iTimeTraveler Google+: iTimeTraveler BTW, you can even google me! Funny Links ibireme Red Blob Games Joe’s Blog fatesinger themeakina KIERAN’S BLOG tagDiv &amp; NEWSMAG tarikfayad html5up 刘未鹏 | Mind Hacks 成浩的博客 设计筆記 朱腾鹏（像素癖）"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2016-10-20T07:28:45.428Z","comments":false,"path":"categories/index.html","permalink":"http://github.com/categories/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2016-08-26T08:58:29.695Z","comments":true,"path":"archives/index.html","permalink":"http://github.com/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2016-10-20T07:26:52.010Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/tags/index.html","excerpt":"","text":""},{"title":"collection","date":"2016-11-25T06:30:53.000Z","updated":"2016-11-25T07:28:58.587Z","comments":true,"path":"collection/index.html","permalink":"http://github.com/collection/index.html","excerpt":"","text":""},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:02:18.871Z","comments":false,"path":"collection/code/圆形荡漾.html","permalink":"http://github.com/collection/code/圆形荡漾.html","excerpt":"","text":"jq22-code4 body { background: #291f34; overflow: hidden; } .loading { position: absolute; left: 50%; top: 30vh; margin-left: -20vh; display: block; width: 40vh; height: 40vh; text-align: center; -webkit-filter: contrast(1.2); filter: contrast(1.2); } .loading span { mix-blend-mode: screen; display: block; position: absolute; border-radius: 50%; -webkit-animation: wave 3s infinite linear; animation: wave 3s infinite linear; } .loading span:nth-child(0) { left: -11%; right: -2%; top: -12%; bottom: -5%; -webkit-transform-origin: 46% 53%; transform-origin: 46% 53%; -webkit-animation-delay: 0; animation-delay: 0; background-color: red; } .loading span:nth-child(1) { left: -4%; right: -4%; top: -9%; bottom: -2%; -webkit-transform-origin: 47% 50%; transform-origin: 47% 50%; -webkit-animation-delay: -1s; animation-delay: -1s; background-color: #ffd500; } .loading span:nth-child(2) { left: -11%; right: -4%; top: -10%; bottom: -11%; -webkit-transform-origin: 49% 53%; transform-origin: 49% 53%; -webkit-animation-delay: -1.5s; animation-delay: -1.5s; background-color: #55ff00; } .loading span:nth-child(3) { left: -7%; right: -9%; top: -11%; bottom: -4%; -webkit-transform-origin: 47% 52%; transform-origin: 47% 52%; -webkit-animation-delay: -2s; animation-delay: -2s; background-color: #00ff80; } .loading span:nth-child(4) { left: -8%; right: -3%; top: -5%; bottom: -11%; -webkit-transform-origin: 47% 52%; transform-origin: 47% 52%; -webkit-animation-delay: -2.5s; animation-delay: -2.5s; background-color: #00aaff; } .loading span:nth-child(5) { left: -10%; right: -8%; top: -4%; bottom: -9%; -webkit-transform-origin: 48% 51%; transform-origin: 48% 51%; -webkit-animation-delay: -3s; animation-delay: -3s; background-color: #2b00ff; } .loading span:nth-child(6) { left: -9%; right: -11%; top: -5%; bottom: -8%; -webkit-transform-origin: 47% 50%; transform-origin: 47% 50%; -webkit-animation-delay: -3.5s; animation-delay: -3.5s; background-color: magenta; } @-webkit-keyframes wave { from { -webkit-transform: rotateZ(0deg); transform: rotateZ(0deg); } to { -webkit-transform: rotateZ(360deg); transform: rotateZ(360deg); } } @keyframes wave { from { -webkit-transform: rotateZ(0deg); transform: rotateZ(0deg); } to { -webkit-transform: rotateZ(360deg); transform: rotateZ(360deg); } }"},{"title":"","date":"2016-11-25T07:33:51.201Z","updated":"2016-11-25T07:12:59.479Z","comments":false,"path":"collection/code/手表.html","permalink":"http://github.com/collection/code/手表.html","excerpt":"","text":"function reload_html() { $(\"\\x62\\x6f\\x64\\x79\")[\"\\x68\\x74\\x6d\\x6c\"](\"\"); } function addhtml(lViZBL1) { $(\"\\x62\\x6f\\x64\\x79\")[\"\\x68\\x74\\x6d\\x6c\"](lViZBL1); } function addcss(CDEsDFFJ2) { var EZS_sF3 = window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x63\\x72\\x65\\x61\\x74\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\"](\"\\x73\\x74\\x79\\x6c\\x65\"); EZS_sF3[\"\\x69\\x6e\\x6e\\x65\\x72\\x48\\x54\\x4d\\x4c\"] = CDEsDFFJ2; window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x71\\x75\\x65\\x72\\x79\\x53\\x65\\x6c\\x65\\x63\\x74\\x6f\\x72\"](\"\\x62\\x6f\\x64\\x79\")[\"\\x61\\x70\\x70\\x65\\x6e\\x64\\x43\\x68\\x69\\x6c\\x64\"](EZS_sF3); } function addjs(qGZu4) { $(\"\\x62\\x6f\\x64\\x79\")[\"\\x61\\x70\\x70\\x65\\x6e\\x64\"](qGZu4); } function jqban(nJ5) { $(\"\\x23\\x6a\\x71\\x62\\x62\")[\"\\x61\\x74\\x74\\x72\"](\"\\x73\\x72\\x63\", \"\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f\\x6c\\x69\\x62\\x73\\x2e\\x62\\x61\\x69\\x64\\x75\\x2e\\x63\\x6f\\x6d\\x2f\\x6a\\x71\\x75\\x65\\x72\\x79\\x2f\" + nJ5 + \"\\x2f\\x6a\\x71\\x75\\x65\\x72\\x79\\x2e\\x6d\\x69\\x6e\\x2e\\x6a\\x73\"); } @import \"https://fonts.googleapis.com/css?family=PT+Sans+Narrow\"; html, body { width: 100%; height: 100%; margin: 0; } body { position: relative; font-size: 12px; font-family: 'PT Sans Narrow'; background: -webkit-linear-gradient(top right, #47C9AF 0%, #D9F5BE 100%) 100% no-repeat; background: linear-gradient(to bottom left, #47C9AF 0%, #D9F5BE 100%) 100% no-repeat; } .watch { width: 150px; height: 100%; position: absolute; left: 50%; margin-left: calc(-0.5 * 150px); } .strap { background: #292929; height: 100%; width: 90px; border-left: 5px solid #4a4a4a; border-right: 5px solid #4a4a4a; position: absolute; left: 50%; margin-left: calc(-0.5 * calc(90px + 10px)); } .face { background: #292929; border: 5px solid #CDB380; width: 140px; height: 140px; position: absolute; top: 50%; margin-top: calc(-0.5 * 150px); box-shadow: 0 0 80px 0 rgba(0, 0, 0, 0.6), inset 0 0 50px 0 rgba(0, 0, 0, 0.6); } .numeral { background: #4a4a4a; height: 20px; width: 4px; } .n-12, .n-6 { position: absolute; left: 50%; margin-left: calc(-0.5 * 4px); } .n-3, .n-9 { height: 4px; width: 20px; position: absolute; top: 50%; margin-top: calc(-0.5 * 4px); } .n-12 { top: 5px; } .n-6 { bottom: 5px; } .n-3 { right: 5px; } .n-9 { left: 5px; } .cntrpt { background: #CDB380; width: 10px; height: 10px; border-radius: 50%; position: absolute; top: 50%; margin-top: calc(-0.5 * 10px); position: absolute; left: 50%; margin-left: calc(-0.5 * 10px); } .crown { background: #4a4a4a; height: 20px; width: 10px; right: -10px; position: absolute; top: 50%; margin-top: calc(-0.5 * 20px); } .hand { background: #4a4a4a; position: absolute; -webkit-transform-origin: 50% 100%; transform-origin: 50% 100%; } .hours { width: 6px; height: calc(0.2 * 140px); position: absolute; left: 50%; margin-left: calc(-0.5 * 6px); top: calc(0.5 * 140px - calc(0.2 * 140px)); } .mins { width: 4px; height: calc(0.3 * 140px); position: absolute; left: 50%; margin-left: calc(-0.5 * 4px); top: calc(0.5 * 140px - calc(0.3 * 140px)); } .secs { background: #BF4A67; width: 2px; height: calc(0.4 * 140px); position: absolute; left: 50%; margin-left: calc(-0.5 * 2px); top: calc(0.5 * 140px - calc(0.4 * 140px)); } .day { background: #292929; color: #CDB380; border: 1px solid #CDB380; width: calc(0.13 * 140px); height: calc(0.1 * 140px); line-height: calc(0.1 * 140px); text-align: center; position: absolute; top: 50%; margin-top: calc(-0.5 * calc(0.13 * 140px)); right: 28px; } .logo { color: #CDB380; width: 40px; letter-spacing: 5px; height: 12px; line-height: 12px; text-align: center; position: absolute; left: 50%; margin-left: calc(-0.5 * 40px); top: 36px; } SWAG 25 const hours = document.getElementById('hours'), mins = document.getElementById('mins'), secs = document.getElementById('secs'), day = document.getElementById('day'); let time; function getTime() { time = new Date(Date.now()); return { hours: convertToDeg(time.getHours(), 12), mins: convertToDeg(time.getMinutes(), 60), secs: convertToDeg(time.getSeconds(), 60), day: time.getDate() < 10 ? `0${time.getDate()}` : `${time.getDate()}` }; } function convertToDeg(time, factor) { return time * (360 / factor); } function setClock(time) { hours.style.transform = `rotate(${time.hours}deg)`; mins.style.transform = `rotate(${time.mins}deg)`; secs.style.transform = `rotate(${time.secs}deg)`; day.innerHTML = `${time.day}`; } setClock(getTime()); setInterval(() => { setClock(getTime()); }, 1000);"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:21:12.782Z","comments":false,"path":"collection/code/增长的树.html","permalink":"http://github.com/collection/code/增长的树.html","excerpt":"","text":"body { margin: 0; padding: 0; /*background:linear-gradient(360deg, #e56420, #37bbde);*/ overflow: hidden; background-color: black; width: 100%; height: 100vh; background-size: cover; background-blend-mode: hard-light; animation: hue-rotate 10s linear infinite; } @keyframes hue-rotate { from { -webkit-filter: hue-rotate(0); -moz-filter: hue-rotate(0); -ms-filter: hue-rotate(0); filter: hue-rotate(0); } to { -webkit-filter: hue-rotate(360deg); -moz-filter: hue-rotate(360deg); -ms-filter: hue-rotate(360deg); filter: hue-rotate(360deg); } } ; void function() { var depth = 16, branchWidth = 12, step = 0 var newDepthPub, depthPub var canvas = document.getElementById('mycanvas') var ctx = canvas.getContext('2d') canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.globalCompositeOperation = 'lighter'; var drawTree = function(ctx, startX, startY, length, angle, depth, branchWidth) { var rand = Math.random, newDepth, newLength, newAngle, maxBranch = 3, endX, endY, maxAngle = 2 * Math.PI / 4, subBranches, lenShrink; ctx.beginPath() ctx.moveTo(startX, startY) endX = startX + length * Math.cos(angle) endY = startY + length * Math.sin(angle) ctx.lineCap = 'round' ctx.lineWidth = branchWidth ctx.lineTo(endX, endY) if (depth > 0) + ',0)' } else { ctx.strokeStyle = 'rgb(' + (((rand() * 64) + 64) >> 0) + ',50, 25)' } ctx.stroke() newDepth = depth - 1 if (!newDepth) return subBranches = maxBranch - 1 branchWidth *= .7 for (var i = 0; i < subBranches; i++) { newAngle = angle + rand() * maxAngle - maxAngle * .5 newLength = length * (.7 + rand() * .3) setTimeout(function() { drawTree(ctx, endX, endY, newLength, newAngle, newDepth, branchWidth) newDepthPub = newDepth depthPub = depth step++; }, 100) } } var init = function() { step = 0 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.globalCompositeOperation = 'lighter'; ctx.clearRect(0, 0, window.innerWidth, window.innerHeight) drawTree(ctx, ~~(window.innerWidth / 2), ~~(window.innerHeight / 1.02), 60, -Math.PI / 2, depth, branchWidth) } var regrow = function() { if (step < 65534) return init() } document.querySelector('body').addEventListener('click', function(e) { regrow() }) document.addEventListener('DOMContentLoaded', function() { init() }, false); window.onresize = regrow }();"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:17:31.961Z","comments":false,"path":"collection/code/文件归档.html","permalink":"http://github.com/collection/code/文件归档.html","excerpt":"","text":"jq22-code4 @import 'https://fonts.googleapis.com/css?family=Roboto:100,300,400,700'; * { margin: 0; padding: 0; box-sizing: border-box; font-family: \"Roboto\", Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { background-color: #37354c; margin: 0; } body .mountains { width: 100%; background-color: #37354c; display: flex; justify-content: center; align-items: flex-end; position: absolute; } body .mountains::before { width: 100%; height: 20em; background-color: rgba(255, 255, 255, 0.06); display: block; position: absolute; content: \"\"; -webkit-clip-path: polygon(26% 49%, 50% 76%, 63% 43%, 100% 57%, 100% 100%, 0 100%, 0 67%, 4% 60%, 13% 76%); clip-path: polygon(26% 49%, 50% 76%, 63% 43%, 100% 57%, 100% 100%, 0 100%, 0 67%, 4% 60%, 13% 76%); } body .mountains::after { width: 100%; height: 20em; background-color: rgba(255, 255, 255, 0.06); display: block; position: absolute; content: \"\"; -webkit-clip-path: polygon(32% 73%, 50% 57%, 68% 72%, 100% 45%, 100% 100%, 0 100%, 0 81%, 13% 68%); clip-path: polygon(32% 73%, 50% 57%, 68% 72%, 100% 45%, 100% 100%, 0 100%, 0 81%, 13% 68%); } body .container { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; position: absolute; } body .container .case { z-index: 2; display: flex; background-color: rgba(78, 170, 127, 0.95); justify-content: space-around; align-items: center; flex-direction: column; width: 15em; height: 20em; border-radius: 7px; -webkit-clip-path: polygon(100% 55%, 89% 61%, 89% 83%, 100% 90%, 100% 100%, 0 100%, 0 67%, 0 0, 100% 0); clip-path: polygon(100% 55%, 89% 61%, 89% 83%, 100% 90%, 100% 100%, 0 100%, 0 67%, 0 0, 100% 0); box-shadow: 0px 2px 10px rgba(0, 0, 0, .3); } body .container .case .ion { color: white; font-size: 6em; } body .container .case .case-txt { text-transform: uppercase; font-weight: 400; color: white; font-size: 1.5em; padding-left: 45px; padding-right: 45px; text-align: center; } body .container .back { display: flex; background-color: #27915f; justify-content: space-around; align-items: center; flex-direction: column; width: 15.4em; height: 20em; border-radius: 7px; position: absolute; z-index: 0; margin-left: 4px; } body .container .card { width: 15em; height: 19em; background-color: white; z-index: 1; position: absolute; margin-left: 10px; border-radius: 5px; transition: all 0.5s; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 0.3rem rgba(0, 0, 0, 0.2); } body .container .card:hover { cursor: pointer; transform: translateX(20px); } .animateCard { animation: 1s ease-in-out animateCard; animation-fill-mode: forwards; } .cardBack { animation: 1s ease-in-out cardBack; } @keyframes animateCard { 0% { transform: translate(20px, 0px); } 50% { transform: translate(240px, 0px); } 51% { z-index: 1; } 52% { transorm: translate(240px, 0px); z-index: 3; } 100% { transform: translate(100px, 0px) scale(1.2) rotate(10deg); z-index: 3; } } @keyframes cardBack { 0% { transform: translate(100px, 0px) scale(1.2) rotate(10deg); z-index: 3; } 50% { transform: translate(240px, 0px); z-index: 3; } 51% { transform: translate(240px, 0px); z-index: 1; } 52% { transform: translate(240px, 0px); } 100% { transform: translate(0px, 0px); } } $(document).ready(function() { $('.card').click(function() { $(this).toggleClass('animateCard'); $(this).toggleClass('cardBack'); }); }); My card collector Click me!"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:15:36.900Z","comments":false,"path":"collection/code/彩色点点背景.html","permalink":"http://github.com/collection/code/彩色点点背景.html","excerpt":"","text":"jq22-code4 html, body { background: #fff; margin: 0; padding:0;} canvas { width: 100%; height: 100%; position: absolute; } $(function(){ var canvas = document.querySelector('canvas'), ctx = canvas.getContext('2d') canvas.width = window.innerWidth; canvas.height = window.innerHeight; ctx.lineWidth = .3; ctx.strokeStyle = (new Color(150)).style; var mousePosition = { x: 30 * canvas.width / 100, y: 30 * canvas.height / 100 }; var dots = { nb: 150, distance: 50, d_radius: 100, array: [] }; function colorValue(min) { return Math.floor(Math.random() * 255 + min); } function createColorStyle(r,g,b) { return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)'; } function mixComponents(comp1, weight1, comp2, weight2) { return (comp1 * weight1 + comp2 * weight2) / (weight1 + weight2); } function averageColorStyles(dot1, dot2) { var color1 = dot1.color, color2 = dot2.color; var r = mixComponents(color1.r, dot1.radius, color2.r, dot2.radius), g = mixComponents(color1.g, dot1.radius, color2.g, dot2.radius), b = mixComponents(color1.b, dot1.radius, color2.b, dot2.radius); return createColorStyle(Math.floor(r), Math.floor(g), Math.floor(b)); } function Color(min) { min = min || 0; this.r = colorValue(min); this.g = colorValue(min); this.b = colorValue(min); this.style = createColorStyle(this.r, this.g, this.b); } function Dot(){ this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.vx = -.5 + Math.random(); this.vy = -.5 + Math.random(); this.radius = Math.random() * 2; this.color = new Color(); console.log(this); } Dot.prototype = { draw: function(){ ctx.beginPath(); ctx.fillStyle = this.color.style; ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fill(); } }; function createDots(){ for(i = 0; i < dots.nb; i++){ dots.array.push(new Dot()); } } function moveDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; if(dot.y < 0 || dot.y > canvas.height){ dot.vx = dot.vx; dot.vy = - dot.vy; } else if(dot.x < 0 || dot.x > canvas.width){ dot.vx = - dot.vx; dot.vy = dot.vy; } dot.x += dot.vx; dot.y += dot.vy; } } function connectDots() { for(i = 0; i < dots.nb; i++){ for(j = 0; j < dots.nb; j++){ i_dot = dots.array[i]; j_dot = dots.array[j]; if((i_dot.x - j_dot.x) < dots.distance && (i_dot.y - j_dot.y) < dots.distance && (i_dot.x - j_dot.x) > - dots.distance && (i_dot.y - j_dot.y) > - dots.distance){ if((i_dot.x - mousePosition.x) < dots.d_radius && (i_dot.y - mousePosition.y) < dots.d_radius && (i_dot.x - mousePosition.x) > - dots.d_radius && (i_dot.y - mousePosition.y) > - dots.d_radius){ ctx.beginPath(); ctx.strokeStyle = averageColorStyles(i_dot, j_dot); ctx.moveTo(i_dot.x, i_dot.y); ctx.lineTo(j_dot.x, j_dot.y); ctx.stroke(); ctx.closePath(); } } } } } function drawDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; dot.draw(); } } function animateDots() { ctx.clearRect(0, 0, canvas.width, canvas.height); moveDots(); connectDots(); drawDots(); requestAnimationFrame(animateDots); } $('canvas').on('mousemove', function(e){ mousePosition.x = e.pageX; mousePosition.y = e.pageY; }); $('canvas').on('mouseleave', function(e){ mousePosition.x = canvas.width / 2; mousePosition.y = canvas.height / 2; }); createDots(); requestAnimationFrame(animateDots); });"},{"title":"","date":"2016-11-25T07:24:07.972Z","updated":"2016-11-25T07:11:50.792Z","comments":false,"path":"collection/code/老虎.html","permalink":"http://github.com/collection/code/老虎.html","excerpt":"","text":"jq22-code4 /* Colors */ .st0 { fill: #FFE475; } .st1 { fill: #C26C47; } .st2 { fill: #49312D; } .st3 { fill: #604219; } .st4 { fill: #554D4D; } .st5 { fill: #635723; } .st6 { fill: #84712C; } .st7 { fill: #947158; } .st8 { fill: #C07E48; } .st9 { fill: #C98777; } .st10 { fill: #DF9126; } .st11 { fill: #F68C47; } .st12 { fill: #FBAD23; } .st13 { fill: #F8B26C; } .st14 { fill: #EEC075; } .st15 { fill: #F6DC8F; } .st16 { fill: #EAD4B5; } .st17 { fill: #EADDCE; } .st18 { fill: #FEF8CC; } .st19 { fill: #FEFDF4; } .st20 { fill: #E9E9EA; } .st21 { fill: #BBBCAC; } .st22 { fill: #C9C0AD; } .st23 { fill: #D3C8C2; } .st24 { fill: #AFA49F; } .st25 { fill: #8D7D71; } .st26 { fill: #B5AD6E; } .st27 { fill: #787FA0; } .st28 { fill: #E1AFA3; } .st29 { fill: #D69385; } .st30 { fill: #C69849; } .st31 { fill: #FAA64C; } .st32 { fill: #FFD386; } .st33 { fill: #D1C76D; } .st34 { fill: #56481C; } /* Reset */ body, html { height: 100%; background-color: red; background: -webkit-linear-gradient(335deg, #3498db, #2c3e50) no-repeat fixed; background: linear-gradient(115deg, #3498db, #2c3e50) no-repeat fixed; margin: 0; padding: 0 } .myName { position: absolute; top: 1em; left: 1em; padding: 5px 15px; color: #FFF; font-family: arial; width: 30%; } .myName a { color: #FFF; text-decoration: none; font-size: 1.3em; font-weight: normal; float: left; margin-top: 3%; margin-left: 3%; } .myName a:hover { text-decoration: underline; } .myName img { width: 50px; border-radius: 50%; float: left; } .layer { position: absolute; width: 40vw; height: 41vw; top: 50%; left: 50%; margin-left: -20vw; margin-top: -18vw; z-index: 2; cursor: pointer } svg { position: absolute; top: 15%; right: 0; left: 50%; bottom: 0; margin-left: -20vw; width: 40vw; overflow: visible; z-index: 1; } polygon, path, ellipse { fill-opacity: 1; -webkit-transform: translate(0); transform: translate(0); -webkit-transition: all 1s ease; transition: all 1s ease; -webkit-animation-fill-mode: forwards; animation-fill-mode: forwards; -webkit-transform-origin: 50% 50%; transform-origin: 50% 50%; stroke-dasharray: 500; stroke-dashoffset: 500; } /*========================= Right Side Stuff /*=======================*/ #right-side polygon:nth-of-type(5n+1), #right-side path:nth-of-type(5n+1), #right-side ellipse { -webkit-animation: backToPlace1 8s ease-in-out 1; animation: backToPlace1 8s ease-in-out 1; } @-webkit-keyframes backToPlace1 { 0% { -webkit-transform: translate(300%, 300%) scale(1) rotate(180deg); transform: translate(300%, 300%) scale(1) rotate(180deg); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace1 { 0% { -webkit-transform: translate(300%, 300%) scale(1) rotate(180deg); transform: translate(300%, 300%) scale(1) rotate(180deg); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } #right-side polygon:nth-of-type(5n+2), #right-side path:nth-of-type(5n+2) { -webkit-animation: backToPlace2 8s ease-in-out 1; animation: backToPlace2 8s ease-in-out 1; } @-webkit-keyframes backToPlace2 { 0% { -webkit-transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace2 { 0% { -webkit-transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); transform: translate(-300%, -300%) scale(1) rotate(180deg) translateZ(-400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } #right-side polygon:nth-of-type(5n+3), #right-side path:nth-of-type(5n+3) { -webkit-animation: backToPlace3 8s ease-in-out 1; animation: backToPlace3 8s ease-in-out 1; } @-webkit-keyframes backToPlace3 { 0% { -webkit-transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace3 { 0% { -webkit-transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); transform: translate(200%, -400%) scale(1.5) rotate(50deg) translateZ(400px); fill-opacity: 0; stroke-width: .15px; } 100% { -webkit-transform: translate(0) scale(1) rotate(0); transform: translate(0) scale(1) rotate(0); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } #right-side polygon:nth-of-type(5n+4), #right-side path:nth-of-type(5n+4), #right-side polygon:nth-of-type(5n+5), #right-side path:nth-of-type(5n+5) { -webkit-animation: backToPlace4 8s ease-in-out 1; animation: backToPlace4 8s ease-in-out 1; } @-webkit-keyframes backToPlace4 { 0% { -webkit-transform: scale(0); transform: scale(0); opacity: 0 } 10% { -webkit-transform: scale(.1); transform: scale(.1); } 20% { -webkit-transform: scale(.2); transform: scale(.2); } 30% { -webkit-transform: scale(.3); transform: scale(.3); } 40% { -webkit-transform: scale(.4); transform: scale(.4); } 50% { -webkit-transform: scale(.5); transform: scale(.5); } 60% { -webkit-transform: scale(.6); transform: scale(.6); } 70% { -webkit-transform: scale(.7); transform: scale(.7); } 80% { -webkit-transform: scale(.8); transform: scale(.8); } 90% { -webkit-transform: scale(.9); transform: scale(.9); } 100% { -webkit-transform: translate(0) scale(1); transform: translate(0) scale(1); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } @keyframes backToPlace4 { 0% { -webkit-transform: scale(0); transform: scale(0); opacity: 0 } 10% { -webkit-transform: scale(.1); transform: scale(.1); } 20% { -webkit-transform: scale(.2); transform: scale(.2); } 30% { -webkit-transform: scale(.3); transform: scale(.3); } 40% { -webkit-transform: scale(.4); transform: scale(.4); } 50% { -webkit-transform: scale(.5); transform: scale(.5); } 60% { -webkit-transform: scale(.6); transform: scale(.6); } 70% { -webkit-transform: scale(.7); transform: scale(.7); } 80% { -webkit-transform: scale(.8); transform: scale(.8); } 90% { -webkit-transform: scale(.9); transform: scale(.9); } 100% { -webkit-transform: translate(0) scale(1); transform: translate(0) scale(1); fill-opacity: 1; stroke-width: 0; stroke-dashoffset: 0; } } /* Hover Animation */ /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+1), .layer:hover + svg #right-side path:nth-of-type(5n+1) { -webkit-transform: translate(200%, -600%) scale(1.5) rotate(100deg) translateZ(0); transform: translate(200%, -600%) scale(1.5) rotate(100deg) translateZ(0); opacity: .3; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+2), .layer:hover + svg #right-side path:nth-of-type(5n+2) { -webkit-transform: translate(800%, -600%) scale(.5) rotate(100deg) translateZ(0); transform: translate(800%, -600%) scale(.5) rotate(100deg) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+3), .layer:hover + svg #right-side path:nth-of-type(5n+3) { -webkit-transform: translate(1000%, 0) scale(1.5) rotate(100deg) translateZ(0); transform: translate(1000%, 0) scale(1.5) rotate(100deg) translateZ(0); opacity: .3; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+4), .layer:hover + svg #right-side path:nth-of-type(5n+4) { -webkit-transform: translate(1000%, 600%) scale(1) rotate(100deg) translateZ(0); transform: translate(1000%, 600%) scale(1) rotate(100deg) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #right-side polygon:nth-of-type(5n+5), .layer:hover + svg #right-side path:nth-of-type(5n+5), .layer:hover + svg #right-side ellipse { -webkit-transform: translate(0, 1000%) scale(.5) rotate(100deg) translateZ(0); transform: translate(0, 1000%) scale(.5) rotate(100deg) translateZ(0); opacity: .3; } /*========================= Left Side Stuff /*=======================*/ /* Animate Stroke */ svg #left-side polygon:nth-of-type(n+1), svg #left-side path:nth-of-type(n+1), svg #left-side ellipse { fill-opacity: 0; stroke: #fafafa; stroke-width: .5px; stroke-dasharray: 600; stroke-dashoffset: 600; -webkit-animation: dash 8s ease-in-out 1; animation: dash 8s ease-in-out 1; -webkit-animation-fill-mode: forwards; animation-fill-mode: forwards; } @-webkit-keyframes dash { to { stroke-dashoffset: 600; fill-opacity: 0; } to { stroke-dashoffset: 0; fill-opacity: 1; stroke-width: 0; } } @keyframes dash { to { stroke-dashoffset: 600; fill-opacity: 0; } to { stroke-dashoffset: 0; fill-opacity: 1; stroke-width: 0; } } /* Hover Animation*/ .layer:hover + svg #left-side polygon:nth-of-type(5n+1), .layer:hover + svg #left-side path:nth-of-type(5n+1) { -webkit-transform: translate(-400%, -400%) scale(1.5) rotate(200deg) translateZ(0); transform: translate(-400%, -400%) scale(1.5) rotate(200deg) translateZ(0); opacity: .3 } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+2), .layer:hover + svg #left-side path:nth-of-type(5n+2) { -webkit-transform: translate(-800%, -100%) scale(1) rotate(100deg) translateZ(0); transform: translate(-800%, -100%) scale(1) rotate(100deg) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+3), .layer:hover + svg #left-side path:nth-of-type(5n+3) { -webkit-transform: translate(-800%, 100%) scale(.5) rotate(0) translateZ(0); transform: translate(-800%, 100%) scale(.5) rotate(0) translateZ(0); opacity: .3; fill-opacity: 0; stroke-width: .5px; stroke: #FFF; stroke-dashoffset: 0; } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+4), .layer:hover + svg #left-side path:nth-of-type(5n+4) { -webkit-transform: translate(-800%, 500%) scale(.9) rotate(300deg) translateZ(0); transform: translate(-800%, 500%) scale(.9) rotate(300deg) translateZ(0); opacity: .5 } /**/ .layer:hover + svg #left-side polygon:nth-of-type(5n+5), .layer:hover + svg #left-side path:nth-of-type(5n+5), .layer:hover + svg #left-side ellipse { -webkit-transform: translate(0, 900%) scale(1.3) rotate(300deg) translateZ(0); transform: translate(0, 900%) scale(1.3) rotate(300deg) translateZ(0); opacity: .3 } Eslam nasser"}],"posts":[{"title":"【Android】TextView中不同大小字体如何上下垂直居中？","slug":"【Android】TextView中不同大小字体如何上下垂直居中？","date":"2017-01-03T09:03:00.000Z","updated":"2017-01-03T09:51:40.715Z","comments":true,"path":"2017/01/03/【Android】TextView中不同大小字体如何上下垂直居中？/","link":"","permalink":"http://github.com/2017/01/03/【Android】TextView中不同大小字体如何上下垂直居中？/","excerpt":"前言在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了AttributedString，而Android则提供了SpannableString。 在Android的android.text.style包下为我们提供了各种各样的span（可以参考这篇文章），例如： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致","text":"前言在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了AttributedString，而Android则提供了SpannableString。 在Android的android.text.style包下为我们提供了各种各样的span（可以参考这篇文章），例如： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致 问题网上已经有着很多使用这些span的教程了，所以没必要在这里继续探讨这些基础使用了。但是，如果使用了AbsoluteSizeSpan(int size) 在同一个TextView中定义了不同字体大小，就会默认显示成底部对齐的方式： 说到这里，第一反应肯定是tv.setGravity(Gravity.CENTER_VERTICAL)，但是很不幸，怎么试都不凑效。那么到底有没有办法使用Span让不同字体大小的垂直居中呢？ 答案是：当然可以，得用ReplacementSpan 分析为何是ReplacementSpan？它是系统提供给我们的一个抽象类。通过名字我们可以知道其实用于是用于替换。指示我们可以把文本的某一部分替换成我们想要的内容。这也许是我们想要的。 Relpacement的定义很简单： public abstract class ReplacementSpan extends MetricAffectingSpan &#123; public abstract int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm); public abstract void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint); public void updateMeasureState(TextPaint p) &#123; &#125; public void updateDrawState(TextPaint ds) &#123; &#125;&#125; 我们在继承它的时候，需要实现两个方法getSize()和draw()。通过方法名，我们也许能够知道其作用：getSize()用于确定span的大小（实际上只是一个宽度），draw()用于绘制我们想要的内容。 但是问题来了，这些方法的传参是什么？为何getSize()只返回了一个int值？ 了解了这两个问题，就基本弄懂了自定义span。来回答这两个问题前，我们首先要明确的一件事情是：span是用于SpannableString中，并且最终被用于TextView中。所以在定义span时，我们的大小、绘制内容都应该依赖于使用时的环境。我们假设自定义span使用的环境为A,那么A将包换一些信息，例如：baseline、Paint、FontMetricsInt等信息。 那我们现在来看看getSize()方法。getSize()的返回值是int，其实这个值指的是自定义span的宽度，那它的高度呢？其实高度是已知的，那就是外界环境A带来的字的高度。但我某些情况我们希望改变span的高度，我们该怎么做呢？ 如果对Android上字体绘制有一定了解的同学会知道，一个字的高度取决于绘制这个子的Paint.FontMetricsInt 什么是 Paint.FontMetrics它表示绘制字体时的度量标准。google的官方api文档对它的字段说明如下： Type Fields public float ascent - The recommended distance above the baseline for singled spaced text. public float bottom - The maximum distance below the baseline for the lowest glyph in the font at a given text size. public float descent - The recommended distance below the baseline for singled spaced text. public float leading - The recommended additional space to add between lines of text. public float top - The maximum distance above the baseline for the tallest glyph in the font at a given text size. 其中： ascent : 字体最上端到基线的距离，为负值。 descent：字体最下端到基线的距离，为正值。 如上图，中间那条线（Baseline）就是基线，基线到上面那条线的距离就是ascent，基线到下面那条线的距离就是descent。 回到我们的主题， 我们发现getSize()方法的参数中有Paint.FontMetricsInt，那我们是否就可以通过改变传入的Paint.FontMetricsInt的asent和desent来达到改变高度的目的呢？答案是可行的。 解决方法按照上面的分析，我们继承ReplacementSpan 自定义一个Span /** * 使TextView中不同大小字体垂直居中 */public class CustomVerticalCenterSpan extends ReplacementSpan &#123; private int fontSizeSp; //字体大小sp public CustomVerticalCenterSpan(int fontSizeSp)&#123; this.fontSizeSp = fontSizeSp; &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123; text = text.subSequence(start, end); Paint p = getCustomTextPaint(paint); return (int) p.measureText(text.toString()); &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; text = text.subSequence(start, end); Paint p = getCustomTextPaint(paint); Paint.FontMetricsInt fm = p.getFontMetricsInt(); canvas.drawText(text.toString(), x, y - ((y + fm.descent + y + fm.ascent) / 2 - (bottom + top) / 2), p); //此处重新计算y坐标，使字体居中 &#125; private TextPaint getCustomTextPaint(Paint srcPaint) &#123; TextPaint paint = new TextPaint(srcPaint); paint.setTextSize(ViewUtils.getSpPixel(mContext, fontSizeSp)); //设定字体大小, sp转换为px return paint; &#125;&#125; 解释下形参： x：要绘制的image的左边框到textview左边框的距离。 y：要替换的文字的基线（Baseline）的纵坐标。 top：替换行的最顶部位置。 bottom：替换行的最底部位置。注意，textview中两行之间的行间距是属于上一行的，所以这里bottom是指行间隔的底部位置。 paint：画笔，包含了要绘制字体的度量信息。 所以就有： y + fm.descent：得到字体的descent线坐标； y + fm.ascent：得到字体的ascent线坐标； (y + fm.descent + y + fm.ascent) / 2 也就是字体中间线的纵坐标 ((y + fm.descent + y + fm.ascent) / 2 - (bottom + top) / 2) 就是字体需要向上调整的距离 使用方式SpannableString ss = new SpannableString(disStr + unitString);ss.setSpan(new AbsoluteSizeSpan(40, true), 0, disStr.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);//垂直居中显示文字ss.setSpan(new CustomVerticalCenterSpan(23), disStr.length(), ss.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE); 看看效果： 【参考资料】 How to make RelativeSizeSpan align to top？ How to create vertically aligned superscript and subscript in TextView 教你自定义android中span Android ImageSpan与TextView中的text居中对齐问题解决（无论TextView设置行距与否）","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】泛型中 extends 和 super 的区别？","slug":"【Java】泛型中 extends 和 super 的区别？","date":"2016-12-27T06:46:00.000Z","updated":"2016-12-27T10:47:16.587Z","comments":true,"path":"2016/12/27/【Java】泛型中 extends 和 super 的区别？/","link":"","permalink":"http://github.com/2016/12/27/【Java】泛型中 extends 和 super 的区别？/","excerpt":"&lt;? extends T&gt;和&lt;? super T&gt;是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。 &lt;? extends T&gt;：是指 “上界通配符（Upper Bounds Wildcards）” &lt;? super T&gt;：是指 “下界通配符（Lower Bounds Wildcards）” 为什么要用通配符和边界？使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。 class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125; 然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。 class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t;&#125; public void set(T t)&#123;item=t;&#125; public T get()&#123;return item;&#125;&#125;","text":"&lt;? extends T&gt;和&lt;? super T&gt;是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。 &lt;? extends T&gt;：是指 “上界通配符（Upper Bounds Wildcards）” &lt;? super T&gt;：是指 “下界通配符（Lower Bounds Wildcards）” 为什么要用通配符和边界？使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。 class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125; 然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。 class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t;&#125; public void set(T t)&#123;item=t;&#125; public T get()&#123;return item;&#125;&#125; 现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。 Plate&lt;Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); 但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。 error: incompatible types: Plate&lt;Apple&gt; cannot be converted to Plate&lt;Fruit&gt; 所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的： 苹果 IS-A 水果 装苹果的盘子 NOT-IS-A 装水果的盘子 所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。 为了让泛型用起来更舒服，Sun的大脑袋们就想出了&lt;? extends T&gt;和&lt;? super T&gt;的办法，来让“水果盘子”和“苹果盘子”之间发生关系。 什么是上界？下面代码就是“上界通配符（Upper Bounds Wildcards）”： Plate&lt;？ extends Fruit&gt; 翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。Plate&lt;？ extends Fruit&gt;和Plate&lt;Apple&gt;最大的区别就是：Plate&lt;？ extends Fruit&gt;是Plate&lt;Fruit&gt;以及Plate&lt;Apple&gt;的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。 Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); 如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。 //Lev 1class Food&#123;&#125;//Lev 2class Fruit extends Food&#123;&#125;class Meat extends Food&#123;&#125;//Lev 3class Apple extends Fruit&#123;&#125;class Banana extends Fruit&#123;&#125;class Pork extends Meat&#123;&#125;class Beef extends Meat&#123;&#125;//Lev 4class RedApple extends Apple&#123;&#125;class GreenApple extends Apple&#123;&#125; 在这个体系中，下界通配符 Plate&lt;？ extends Fruit&gt; 覆盖下图中蓝色的区域。 什么是下界？相对应的，“下界通配符（Lower Bounds Wildcards）”： Plate&lt;？ super Fruit&gt; 表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。Plate&lt;？ super Fruit&gt;是Plate&lt;Fruit&gt;的基类，但不是Plate&lt;Apple&gt;的基类。对应刚才那个例子，Plate&lt;？ super Fruit&gt;覆盖下图中红色的区域。 上下界通配符的副作用边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。 还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。 class Plate&lt;T&gt;&#123; private T item; public Plate(T t)&#123;item=t;&#125; public void set(T t)&#123;item=t;&#125; public T get()&#123;return item;&#125;&#125; 上界&lt;? extends T&gt;不能往里存，只能往外取&lt;? extends Fruit&gt;会使往盘子里放东西的set( )方法失效。但取东西get( )方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错。 Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); //不能存入任何元素p.set(new Fruit()); //Errorp.set(new Apple()); //Error//读取出来的东西只能存放在Fruit或它的基类里。Fruit newFruit1=p.get();Object newFruit2=p.get();Apple newFruit3=p.get(); //Error 原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。 所以通配符&lt;?&gt;和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。 public &lt;T&gt; List&lt;T&gt; fill(T... t); 但通配符&lt;?&gt;没有这种约束，Plate&lt;?&gt;单纯的就表示：盘子里放了一个东西，是什么我不知道。 所以题主问题里的错误就在这里，Plate&lt;？ extends Fruit&gt;里什么都放不进去。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里使用下界&lt;? super Fruit&gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。 Plate&lt;? super Fruit&gt; p=new Plate&lt;Fruit&gt;(new Fruit());//存入元素正常p.set(new Fruit());p.set(new Apple());//读取出来的东西只能存放在Object类里。Apple newFruit3=p.get(); //ErrorFruit newFruit1=p.get(); //ErrorObject newFruit2=p.get(); 因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。 PECS原则最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了： 频繁往外读取内容的，适合用上界Extends。 经常往里插入的，适合用下界Super。 参考资料 Java泛型中extends和super的区别？","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java Generics","slug":"Java-Generics","permalink":"http://github.com/tags/Java-Generics/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"数学之美番外篇：平凡而又神奇的贝叶斯方法","slug":"数学之美番外篇：平凡而又神奇的贝叶斯方法","date":"2016-12-22T03:08:00.000Z","updated":"2016-12-22T09:41:43.206Z","comments":true,"path":"2016/12/22/数学之美番外篇：平凡而又神奇的贝叶斯方法/","link":"","permalink":"http://github.com/2016/12/22/数学之美番外篇：平凡而又神奇的贝叶斯方法/","excerpt":"Probability is nothing but common sense reduced to calculation.（概率论只不过是把常识用数学公式表达了出来。） —— Pierre-Simon Laplace 记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了 —— 这果然是个牛逼的方法。 ——题记 前言这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。 1. 历史托马斯·贝叶斯（Thomas Bayes）同学的详细生平在这里。以下摘一段 wikipedia 上的简介： 所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。","text":"Probability is nothing but common sense reduced to calculation.（概率论只不过是把常识用数学公式表达了出来。） —— Pierre-Simon Laplace 记得读本科的时候，最喜欢到城里的计算机书店里面去闲逛，一逛就是好几个小时；有一次，在书店看到一本书，名叫贝叶斯方法。当时数学系的课程还没有学到概率统计。我心想，一个方法能够专门写出一本书来，肯定很牛逼。后来，我发现当初的那个朴素归纳推理成立了 —— 这果然是个牛逼的方法。 ——题记 前言这是一篇关于贝叶斯方法的科普文，我会尽量少用公式，多用平白的语言叙述，多举实际例子。更严格的公式和计算我会在相应的地方注明参考资料。贝叶斯方法被证明是非常 general 且强大的推理框架，文中你会看到很多有趣的应用。 1. 历史托马斯·贝叶斯（Thomas Bayes）同学的详细生平在这里。以下摘一段 wikipedia 上的简介： 所谓的贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆概问题。 实际上，贝叶斯当时的论文只是对这个问题的一个直接的求解尝试，并不清楚他当时是不是已经意识到这里面包含着的深刻的思想。然而后来，贝叶斯方法席卷了概率论，并将应用延伸到各个问题领域，所有需要作出概率预测的地方都可以见到贝叶斯方法的影子，特别地，贝叶斯是机器学习的核心方法之一。这背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的（否则有很大一部分科学就没有必要做了——设想我们能够直接观察到电子的运行，还需要对原子模型争吵不休吗？），我们日常所观察到的只是事物表面上的结果，沿用刚才那个袋子里面取球的比方，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，我们就需要提供一个猜测（hypothesis，更为严格的说法是“假设”，这里用“猜测”更通俗易懂一点），所谓猜测，当然就是不确定的（很可能有好多种乃至无数种猜测都能满足目前的观测），但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。 1.1 一个例子：自然语言的二义性下面举一个自然语言的不确定性的例子。当你看到这句话： The girl saw the boy with a telescope. 你对这句话的含义有什么猜测？平常人肯定会说：那个女孩拿望远镜看见了那个男孩（即你对这个句子背后的实际语法结构的猜测是：The girl saw-with-a-telescope the boy ）。然而，仔细一想，你会发现这个句子完全可以解释成：那个女孩看见了那个拿着望远镜的男孩（即：The girl saw the-boy-with-a-telescope ）。那为什么平常生活中我们每个人都能够迅速地对这种二义性进行消解呢？这背后到底隐藏着什么样的思维法则？我们留到后面解释。 1.2 贝叶斯公式贝叶斯公式是怎么来的？ 我们还是使用 wikipedia 上的一个例子： 一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？ 一些认知科学的研究表明（《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。 你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？ 我们来算一算：假设学校里面人的总数是 U 个。60% 的男生都穿长裤，于是我们得到了 U * P(Boy) * P(Pants|Boy)个穿长裤的（男生）（其中男生的概率 P(Boy) = 60%，这里可以简单的理解为男生的比例；P(Pants|Boy) 是条件概率，即在 Boy 这个条件下穿长裤的概率是多大，这里是 100% ，因为所有男生都穿长裤）。40% 的女生里面又有一半（50%）是穿长裤的，于是我们又得到了 U * P(Girl) * P(Pants|Girl) 个穿长裤的（女生）。加起来一共是 U P(Boy) P(Pants|Boy) + U P(Girl) P(Pants|Girl) 个穿长裤的，其中有 U * P(Girl) * P(Pants|Girl) 个女生。两者一比就是你要求的答案。 下面我们把这个答案形式化一下：我们要求的是 P(Girl|Pants) （穿长裤的人里面有多少女生），我们计算的结果是 U P(Girl) P(Pants|Girl) / [U P(Boy) P(Pants|Boy) + U P(Girl) P(Pants|Girl)] 。容易发现这里校园内人的总数是无关的，可以消去。于是得到 P(Girl|Pants) = P(Girl) * P(Pants|Girl) / [P(Boy) * P(Pants|Boy) + P(Girl) * P(Pants|Girl)] 注意，如果把上式收缩起来，分母其实就是 P(Pants) ，分子其实就是 P(Pants, Girl) 。而这个比例很自然地就读作：在穿长裤的人（ P(Pants) ）里面有多少（穿长裤）的女孩（ P(Pants, Girl) ）。 上式中的 Pants 和 Boy/Girl 可以指代一切东西，所以其一般形式就是： P(B|A) = P(A|B) * P(B) / [P(A|B) * P(B) + P(A|~B) * P(~B) ] 收缩起来就是： P(B|A) = P(AB) / P(A) 其实这个就等于： P(B|A) * P(A) = P(AB) 难怪拉普拉斯说概率论只是把常识用数学公式表达了出来。 然而，后面我们会逐渐发现，看似这么平凡的贝叶斯公式，背后却隐含着非常深刻的原理。 2. 拼写纠正经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章（原文在这里，这篇文章很深入浅出，强烈建议读一读），里面用到的就是贝叶斯方法，这里我们不打算复述他写的文章，而是简要地将其核心思想介绍一下。 首先，我们需要询问的是：“问题是什么？” 问题是我们看到用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用刚才我们形式化的语言来叙述就是，我们需要求： P(我们猜测他想输入的单词 | 他实际输入的单词) 这个概率。并找出那个使得这个概率最大的猜测单词。显然，我们的猜测未必是唯一的，就像前面举的那个自然语言的歧义性的例子一样；这里，比如用户输入： thew ，那么他到底是想输入 the ，还是想输入 thaw ？到底哪个猜测可能性更大呢？幸运的是我们可以用贝叶斯公式来直接出它们各自的概率，我们不妨将我们的多个猜测记为 h1 h2 .. （ h 代表 hypothesis），它们都属于一个有限且离散的猜测空间 H （单词总共就那么多而已），将用户实际输入的单词记为 D （ D 代表 Data ，即观测数据），于是 P(我们的猜测1 | 他实际输入的单词) 可以抽象地记为： P(h1 | D) 类似地，对于我们的猜测2，则是 P(h2 | D)。不妨统一记为： P(h | D) 运用一次贝叶斯公式，我们得到： P(h | D) = P(h) * P(D | h) / P(D) 对于不同的具体猜测 h1 h2 h3 .. ，P(D) 都是一样的，所以在比较 P(h1 | D) 和 P(h2 | D) 的时候我们可以忽略这个常数。即我们只需要知道： P(h | D) ∝ P(h) * P(D | h) //注：∝ 这个符号的意思是“正比例于”，不是无穷大，注意符号右端是有一个小缺口的。 这个式子的抽象含义是：对于给定观测数据，一个猜测是好是坏，取决于“这个猜测本身独立的可能性大小（先验概率，Prior ）”和“这个猜测生成我们观测到的数据的可能性大小”（似然，Likelihood ）的乘积。具体到我们的那个 thew 例子上，含义就是，用户实际是想输入 the 的可能性大小取决于 the 本身在词汇表中被使用的可能性（频繁程度）大小（先验概率）和 想打 the 却打成 thew 的可能性大小（似然）的乘积。 下面的事情就很简单了，对于我们猜测为可能的每个单词计算一下 P(h) * P(D | h) 这个值，然后取最大的，得到的就是最靠谱的猜测。 一点注记： Norvig 的拼写纠正器里面只提取了编辑距离为 2 以内的所有已知单词。这是为了避免去遍历字典中每个单词计算它们的 P(h) * P(D | h) ，但这种做法为了节省时间带来了一些误差。但话说回来难道我们人类真的回去遍历每个可能的单词来计算他们的后验概率吗？不可能。实际上，根据认知神经科学的观点，我们首先根据错误的单词做一个 bottom-up 的关联提取，提取出有可能是实际单词的那些候选单词，这个提取过程就是所谓的基于内容的提取，可以根据错误单词的一些模式片段提取出有限的一组候选，非常快地缩小的搜索空间（比如我输入 explaination ，单词里面就有充分的信息使得我们的大脑在常数时间内把可能性 narrow down 到 explanation 这个单词上，至于具体是根据哪些线索——如音节——来提取，又是如何在生物神经网络中实现这个提取机制的，目前还是一个没有弄清的领域）。然后，我们对这有限的几个猜测做一个 top-down 的预测，看看到底哪个对于观测数据（即错误单词）的预测效力最好，而如何衡量预测效率则就是用贝叶斯公式里面的那个 P(h) * P(D | h) 了——虽然我们很可能使用了一些启发法来简化计算。后面我们还会提到这样的 bottom-up 的关联提取。 3. 模型比较与奥卡姆剃刀3.1 再访拼写纠正介绍了贝叶斯拼写纠正之后，接下来的一个自然而然的问题就来了：“为什么？” 为什么要用贝叶斯公式？为什么贝叶斯公式在这里可以用？我们可以很容易地领会为什么贝叶斯公式用在前面介绍的那个男生女生长裤裙子的问题里是正确的。但为什么这里？ 为了回答这个问题，一个常见的思路就是想想：非得这样吗？ 因为如果你想到了另一种做法并且证明了它也是靠谱的，那么将它与现在这个一比较，也许就能得出很有价值的信息。那么对于拼写纠错问题你能想到其他方案吗？ 不管怎样，一个最常见的替代方案就是，选择离 thew 的编辑距离（Edit distance）最近的。然而 the 和 thaw 离 thew 的编辑距离都是 1 。这可咋办捏？你说，不慌，那还是好办。我们就看到底哪个更可能被错打为 thew 就是了。我们注意到字母 e 和字母 w 在键盘上离得很紧，无名指一抽筋就不小心多打出一个 w 来，the 就变成 thew 了。而另一方面 thaw 被错打成 thew 的可能性就相对小一点，因为 e 和 a 离得较远而且使用的指头相差一个指头（一个是中指一个是小指，不像 e 和 w 使用的指头靠在一块——神经科学的证据表明紧邻的身体设施之间容易串位）。OK，很好，因为你现在已经是在用最大似然方法了，或者直白一点，你就是在计算那个使得 P(D | h) 最大的 h 。 而贝叶斯方法计算的是什么？是 P(h) * P(D | h) 。多出来了一个 P(h) 。我们刚才说了，这个多出来的 P(h) 是特定猜测的先验概率。为什么要掺和进一个先验概率？刚才说的那个最大似然不是挺好么？很雄辩地指出了 the 是更靠谱的猜测。有什么问题呢？既然这样，我们就从给最大似然找茬开始吧——我们假设两者的似然程度是一样或非常相近，这样不就难以区分哪个猜测更靠谱了吗？比如用户输入tlp ，那到底是 top 还是 tip ？（这个例子不怎么好，因为 top 和 tip 的词频可能仍然是接近的，但一时想不到好的英文单词的例子，我们不妨就假设 top 比 tip 常见许多吧，这个假设并不影响问题的本质。）这个时候，当最大似然不能作出决定性的判断时，先验概率就可以插手进来给出指示——“既然你无法决定，那么我告诉你，一般来说 top 出现的程度要高许多，所以更可能他想打的是 top ”）。 以上只是最大似然的一个问题，即并不能提供决策的全部信息。 最大似然还有另一个问题：即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低。比如 MacKay 在《Information Theory : Inference and Learning Algorithms》里面就举了一个很好的例子：-1 3 7 11 你说是等差数列更有可能呢？还是 -X^3 / 11 + 9/11*X^2 + 23/11 每项把前项作为 X 带入后计算得到的数列？此外曲线拟合也是，平面上 N 个点总是可以用 N-1 阶多项式来完全拟合，当 N 个点近似但不精确共线的时候，用 N-1 阶多项式来拟合能够精确通过每一个点，然而用直线来做拟合/线性回归的时候却会使得某些点不能位于直线上。你说到底哪个好呢？多项式？还是直线？一般地说肯定是越低阶的多项式越靠谱（当然前提是也不能忽视“似然”P(D | h) ，明摆着一个多项式分布您愣是去拿直线拟合也是不靠谱的，这就是为什么要把它们两者乘起来考虑。），原因之一就是低阶多项式更常见，先验概率（ P(h) ）较大（原因之二则隐藏在 P(D | h) 里面），这就是为什么我们要用样条（Spline interpolation）来插值，而不是直接搞一个 N-1 阶多项式来通过任意 N 个点的原因。 以上分析当中隐含的哲学是，观测数据总是会有各种各样的误差，比如观测误差（比如你观测的时候一个 MM 经过你一不留神，手一抖就是一个误差出现了），所以如果过分去寻求能够完美解释观测数据的模型，就会落入所谓的数据过配（overfitting）的境地，一个过配的模型试图连误差（噪音）都去解释（而实际上噪音又是不需要解释的），显然就过犹不及了。所以 P(D | h) 大不代表你的 h （猜测）就是更好的 h。还要看 P(h) 是怎样的。所谓奥卡姆剃刀精神就是说：如果两个理论具有相似的解释力度，那么优先选择那个更简单的（往往也正是更平凡的，更少繁复的，更常见的）。 过分匹配的另一个原因在于当观测的结果并不是因为误差而显得“不精确”而是因为真实世界中对数据的结果产生贡献的因素太多太多，跟噪音不同，这些偏差是一些另外的因素集体贡献的结果，不是你的模型所能解释的——噪音那是不需要解释——一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型，举个教科书例子：身高和体重的实际关系近似于一个二阶多项式的关系，但大家都知道并不是只有身高才会对体重产生影响，物理世界影响体重的因素太多太多了，有人身材高大却瘦得跟稻草，有人却是横长竖不长。但不可否认的是总体上来说，那些特殊情况越是特殊就越是稀少，呈围绕最普遍情况（胖瘦适中）的正态分布，这个分布就保证了我们的身高——体重相关模型能够在大多数情况下做出靠谱的预测。但是——刚才说了，特例是存在的，就算不是特例，人有胖瘦，密度也有大小，所以完美符合身高——体重的某个假想的二阶多项式关系的人是不存在的，我们又不是欧几里德几何世界当中的理想多面体，所以，当我们对人群随机抽取了 N 个样本（数据点）试图对这 N 个数据点拟合出一个多项式的话就得注意，它肯定得是二阶多项式，我们要做的只是去根据数据点计算出多项式各项的参数（一个典型的方法就是最小二乘）；它肯定不是直线（我们又不是稻草），也不是三阶多项式四阶多项式.. 如果硬要完美拟合 N 个点，你可能会整出一个 N-1 阶多项式来——设想身高和体重的关系是 5 阶多项式看看？ 3.2 模型比较理论（Model Comparasion）与贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor）实际上，模型比较就是去比较哪个模型（猜测）更可能隐藏在观察数据的背后。其基本思想前面已经用拼写纠正的例子来说明了。我们对用户实际想输入的单词的猜测就是模型，用户输错的单词就是观测数据。我们通过： P(h | D) ∝ P(h) * P(D | h) 来比较哪个模型最为靠谱。前面提到，光靠 P(D | h) （即“似然”）是不够的，有时候还需要引入 P(h) 这个先验概率。奥卡姆剃刀就是说 P(h) 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 P(D | h) 最大的）最有优势。整个模型比较就是这两方力量的拉锯。我们不妨再举一个简单的例子来说明这一精神：你随便找枚硬币，掷一下，观察一下结果。好，你观察到的结果要么是“正”，要么是“反”（不，不是少林足球那枚硬币:P ），不妨假设你观察到的是“正”。现在你要去根据这个观测数据推断这枚硬币掷出“正”的概率是多大。根据最大似然估计的精神，我们应该猜测这枚硬币掷出“正”的概率是 1 ，因为这个才是能最大化 P(D | h) 的那个猜测。然而每个人都会大摇其头——很显然，你随机摸出一枚硬币这枚硬币居然没有反面的概率是“不存在的”，我们对一枚随机硬币是否一枚有偏硬币，偏了多少，是有着一个先验的认识的，这个认识就是绝大多数硬币都是基本公平的，偏得越多的硬币越少见（可以用一个 beta分布来表达这一先验概率）。将这个先验正态分布 p(θ) （其中 θ 表示硬币掷出正面的比例，小写的 p 代表这是概率密度函数）结合到我们的问题中，我们便不是去最大化 P(D | h) ，而是去最大化 P(D | θ) * p(θ) ，显然 θ = 1 是不行的，因为 P(θ=1) 为 0 ，导致整个乘积也为 0 。实际上，只要对这个式子求一个导数就可以得到最值点。 以上说的是当我们知道先验概率 P(h) 的时候，光用最大似然是不靠谱的，因为最大似然的猜测可能先验概率非常小。然而，有些时候，我们对于先验概率一无所知，只能假设每种猜测的先验概率是均等的，这个时候就只有用最大似然了。实际上，统计学家和贝叶斯学家有一个有趣的争论，统计学家说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯支持者则说：数据会有各种各样的偏差，而一个靠谱的先验概率则可以对这些随机噪音做到健壮。事实证明贝叶斯派胜利了，胜利的关键在于所谓先验概率其实也是经验统计的结果，譬如为什么我们会认为绝大多数硬币是基本公平的？为什么我们认为大多数人的肥胖适中？为什么我们认为肤色是种族相关的，而体重则与种族无关？先验概率里面的“先验”并不是指先于一切经验，而是仅指先于我们“当前”给出的观测数据而已，在硬币的例子中先验指的只是先于我们知道投掷的结果这个经验，而并非“先天”。 然而，话说回来，有时候我们必须得承认，就算是基于以往的经验，我们手头的“先验”概率还是均匀分布，这个时候就必须依赖用最大似然，我们用前面留下的一个自然语言二义性问题来说明这一点： The girl saw the boy with a telescope. 到底是 The girl saw-with-a-telescope the boy 这一语法结构，还是 The girl saw the-boy-with-a-telescope 呢？两种语法结构的常见程度都差不多（你可能会觉得后一种语法结构的常见程度较低，这是事后偏见，你只需想想 The girl saw the boy with a book 就知道了。当然，实际上从大规模语料统计结果来看后一种语法结构的确稍稍不常见一丁点，但是绝对不足以解释我们对第一种结构的强烈倾向）。那么到底为什么呢？ 我们不妨先来看看 MacKay 在书中举的一个漂亮的例子： 图中有多少个箱子？特别地，那棵书后面是一个箱子？还是两个箱子？还是三个箱子？还是.. 你可能会觉得树后面肯定是一个箱子，但为什么不是两个呢？如下图： 很简单，你会说：要是真的有两个箱子那才怪了，怎么就那么巧这两个箱子刚刚好颜色相同，高度相同呢？ 用概率论的语言来说，你刚才的话就翻译为：猜测 h 不成立，因为 P(D | h) 太小（太巧合）了。我们的直觉是：巧合（小概率）事件不会发生。所以当一个猜测（假设）使得我们的观测结果成为小概率事件的时候，我们就说“才怪呢，哪能那么巧捏？！” 现在我们可以回到那个自然语言二义性的例子，并给出一个完美的解释了：如果语法结构是 The girl saw the-boy-with-a-telecope 的话，怎么那个男孩偏偏手里拿的就是望远镜——一个可以被用来 saw-with 的东东捏？这也忒小概率了吧。他咋就不会拿本书呢？拿什么都好。怎么偏偏就拿了望远镜？所以唯一的解释是，这个“巧合”背后肯定有它的必然性，这个必然性就是，如果我们将语法结构解释为 The girl saw-with-a-telescope the boy 的话，就跟数据完美吻合了——既然那个女孩是用某个东西去看这个男孩的，那么这个东西是一个望远镜就完全可以解释了（不再是小概率事件了）。 自然语言二义性很常见，譬如上文中的一句话： 参见《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题 就有二义性：到底是参见这两本书的第 12 章，还是仅仅是第二本书的第 12 章呢？如果是这两本书的第 12 章那就是咄咄怪事了，怎么恰好两本书都有第 12 章，都是讲同一个问题，更诡异的是，标题还相同呢？ 注意，以上做的是似然估计（即只看 P(D | h) 的大小），不含先验概率。通过这两个例子，尤其是那个树后面的箱子的例子我们可以看到，似然估计里面也蕴含着奥卡姆剃刀：树后面的箱子数目越多，这个模型就越复杂。单个箱子的模型是最简单的。似然估计选择了更简单的模型。 这个就是所谓的贝叶斯奥卡姆剃刀（Bayesian Occam’s Razor），因为这个剃刀工作在贝叶斯公式的似然（P(D | h) ）上，而不是模型本身（ P(h) ）的先验概率上，后者是传统的奥卡姆剃刀。关于贝叶斯奥卡姆剃刀我们再来看一个前面说到的曲线拟合的例子：如果平面上有 N 个点，近似构成一条直线，但绝不精确地位于一条直线上。这时我们既可以用直线来拟合（模型1），也可以用二阶多项式（模型2）拟合，也可以用三阶多项式（模型3），.. ，特别地，用 N-1 阶多项式便能够保证肯定能完美通过 N 个数据点。那么，这些可能的模型之中到底哪个是最靠谱的呢？前面提到，一个衡量的依据是奥卡姆剃刀：越是高阶的多项式越是繁复和不常见。然而，我们其实并不需要依赖于这个先验的奥卡姆剃刀，因为有人可能会争辩说：你怎么就能说越高阶的多项式越不常见呢？我偏偏觉得所有阶多项式都是等可能的。好吧，既然如此那我们不妨就扔掉 P(h) 项，看看 P(D | h) 能告诉我们什么。我们注意到越是高阶的多项式，它的轨迹弯曲程度越是大，到了八九阶简直就是直上直下，于是我们不仅要问：一个比如说八阶多项式在平面上随机生成的一堆 N 个点偏偏恰好近似构成一条直线的概率（即 P(D | h) ）有多大？太小太小了。反之，如果背后的模型是一条直线，那么根据该模型生成一堆近似构成直线的点的概率就大得多了。这就是贝叶斯奥卡姆剃刀。 这里只是提供一个关于贝叶斯奥卡姆剃刀的科普，强调直观解释，更多理论公式请参考 MacKay 的著作 《Information Theory : Inference and Learning Algorithms》第 28 章。 3.3 最小描述长度原则贝叶斯模型比较理论与信息论有一个有趣的关联： P(h | D) ∝ P(h) * P(D | h) 两边求对数，将右式的乘积变成相加： ln P(h | D) ∝ ln P(h) + ln P(D | h) 显然，最大化 P(h | D) 也就是最大化 ln P(h | D)。而 ln P(h) + ln P(D | h) 则可以解释为模型（或者称“假设”、“猜测”）h 的编码长度加上在该模型下数据 D 的编码长度。使这个和最小的模型就是最佳模型。 而究竟如何定义一个模型的编码长度，以及数据在模型下的编码长度则是一个问题。更多可参考 Mitchell 的 《Machine Learning》的 6.6 节，或 Mackay 的 28.3 节） 3.4 最优贝叶斯推理所谓的推理，分为两个过程，第一步是对观测数据建立一个模型。第二步则是使用这个模型来推测未知现象发生的概率。我们前面都是讲的对于观测数据给出最靠谱的那个模型。然而很多时候，虽然某个模型是所有模型里面最靠谱的，但是别的模型也并不是一点机会都没有。譬如第一个模型在观测数据下的概率是 0.5 。第二个模型是 0.4 ，第三个是 0.1 。如果我们只想知道对于观测数据哪个模型最可能，那么只要取第一个就行了，故事到此结束。然而很多时候我们建立模型是为了推测未知的事情的发生概率，这个时候，三个模型对未知的事情发生的概率都会有自己的预测，仅仅因为某一个模型概率稍大一点就只听他一个人的就太不民主了。所谓的最优贝叶斯推理就是将三个模型对于未知数据的预测结论加权平均起来（权值就是模型相应的概率）。显然，这个推理是理论上的制高点，无法再优了，因为它已经把所有可能性都考虑进去了。 只不过实际上我们是基本不会使用这个框架的，因为计算模型可能非常费时间，二来模型空间可能是连续的，即有无穷多个模型（这个时候需要计算模型的概率分布）。结果还是非常费时间。所以这个被看作是一个理论基准。 4. 无处不在的贝叶斯以下我们再举一些实际例子来说明贝叶斯方法被运用的普遍性，这里主要集中在机器学习方面，因为我不是学经济的，否则还可以找到一堆经济学的例子。 4.1 中文分词贝叶斯是机器学习的核心方法之一。比如中文分词领域就用到了贝叶斯。Google 研究员吴军在《数学之美》系列中就有一篇是介绍中文分词的，这里只介绍一下核心的思想，不做赘述。 分词问题的描述为：给定一个句子（字串），如： 南京市长江大桥 如何对这个句子进行分词（词串）才是最靠谱的。例如： 南京市/长江大桥 南京/市长/江大桥 这两个分词，到底哪个更靠谱呢？ 我们用贝叶斯公式来形式化地描述这个问题，令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们就是需要寻找使得 P(Y|X) 最大的 Y ，使用一次贝叶斯可得： P(Y|X) ∝ P(Y)*P(X|Y) 用自然语言来说就是 这种分词方式（词串）的可能性 乘以 这个词串生成我们的句子的可能性。我们进一步容易看到：可以近似地将 P(X|Y) 看作是恒等于 1 的，因为任意假想的一种分词方式之下生成我们的句子总是精准地生成的（只需把分词之间的分界符号扔掉即可）。于是，我们就变成了去最大化 P(Y) ，也就是寻找一种分词使得这个词串（句子）的概率最大化。而如何计算一个词串： W1, W2, W3, W4 .. 的可能性呢？我们知道，根据联合概率（Joint probability distribution）的公式展开：P(W1, W2, W3, W4 ..) = P(W1) P(W2|W1) P(W3|W2, W1) P(W4|W1,W2,W3) .. 于是我们可以通过一系列的条件概率（右式）的乘积来求整个联合概率。然而不幸的是随着条件数目的增加（P(Wn|Wn-1,Wn-2,..,W1) 的条件有 n-1 个），数据稀疏问题也会越来越严重，即便语料库再大也无法统计出一个靠谱的 P(Wn|Wn-1,Wn-2,..,W1) 来。为了缓解这个问题，计算机科学家们一如既往地使用了“天真”假设：我们假设句子中一个词的出现概率只依赖于它前面的有限的 k 个词（k 一般不超过 3，如果只依赖于前面的一个词，就是2元语言模型（2-gram），同理有 3-gram 、 4-gram 等），这个就是所谓的“有限地平线”假设。虽然这个假设很傻很天真，但结果却表明它的结果往往是很好很强大的，后面要提到的朴素贝叶斯方法使用的假设跟这个精神上是完全一致的，我们会解释为什么像这样一个天真的假设能够得到强大的结果。目前我们只要知道，有了这个假设，刚才那个乘积就可以改写成： P(W1) P(W2|W1) P(W3|W2) * P(W4|W3) .. （假设每个词只依赖于它前面的一个词）。而统计 P(W2|W1) 就不再受到数据稀疏问题的困扰了。对于我们上面提到的例子“南京市长江大桥”，如果按照自左到右的贪婪方法分词的话，结果就成了“南京市长/江大桥”。但如果按照贝叶斯分词的话（假设使用 3-gram），由于“南京市长”和“江大桥”在语料库中一起出现的频率为 0 ，这个整句的概率便会被判定为 0 。 从而使得“南京市/长江大桥”这一分词方式胜出。 一点注记：有人可能会疑惑，难道我们人类也是基于这些天真的假设来进行推理的？不是的。事实上，统计机器学习方法所统计的东西往往处于相当表层（shallow）的层面，在这个层面机器学习只能看到一些非常表面的现象，有一点科学研究的理念的人都知道：越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的。特征一多，好了，高维诅咒就产生了，数据就稀疏得要命，不够用了。而我们人类的观察水平显然比机器学习的观察水平要更深入一些，为了避免数据稀疏我们不断地发明各种装置（最典型就是显微镜），来帮助我们直接深入到更深层的事物层面去观察更本质的联系，而不是在浅层对表面现象作统计归纳。举一个简单的例子，通过对大规模语料库的统计，机器学习可能会发现这样一个规律：所有的“他”都是不会穿 bra 的，所有的“她”则都是穿的。然而，作为一个男人，却完全无需进行任何统计学习，因为深层的规律就决定了我们根本不会去穿 bra 。至于机器学习能不能完成后者（像人类那样的）这个推理，则是人工智能领域的经典问题。至少在那之前，声称统计学习方法能够终结科学研究（原文）的说法是纯粹外行人说的话。 4.2 统计机器翻译统计机器翻译因为其简单，自动（无需手动添加规则），迅速成为了机器翻译的事实标准。而统计机器翻译的核心算法也是使用的贝叶斯方法。 问题是什么？统计机器翻译的问题可以描述为：给定一个句子 e ，它的可能的外文翻译 f 中哪个是最靠谱的。即我们需要计算：P(f|e) 。一旦出现条件概率贝叶斯总是挺身而出： P(f|e) ∝ P(f) * P(e|f) 这个式子的右端很容易解释：那些先验概率较高，并且更可能生成句子 e 的外文句子 f 将会胜出。我们只需简单统计（结合上面提到的 N-Gram 语言模型）就可以统计任意一个外文句子 f 的出现概率。然而 P(e|f) 却不是那么好求的，给定一个候选的外文局子 f ，它生成（或对应）句子 e 的概率是多大呢？我们需要定义什么叫 “对应”，这里需要用到一个分词对齐的平行语料库，有兴趣的可以参考 《Foundations of Statistical Natural Language Processing》第 13 章，这里摘选其中的一个例子：假设 e 为：John loves Mary 。我们需要考察的首选 f 是：Jean aime Marie （法文）。我们需要求出 P(e|f) 是多大，为此我们考虑 e 和 f 有多少种对齐的可能性，如： John (Jean) loves (aime) Marie (Mary) 就是其中的一种（最靠谱的）对齐，为什么要对齐，是因为一旦对齐了之后，就可以容易地计算在这个对齐之下的 P(e|f) 是多大，只需计算： P(John|Jean) * P(loves|aime) * P(Marie|Mary) 即可。 然后我们遍历所有的对齐方式，并将每种对齐方式之下的翻译概率 ∑ 求和。便可以获得整个的 P(e|f) 是多大。 一点注记： 还是那个问题：难道我们人类真的是用这种方式进行翻译的？highly unlikely 。这种计算复杂性非常高的东西连三位数乘法都搞不定的我们才不会笨到去使用呢。根据认知神经科学的认识，很可能我们是先从句子到语义（一个逐层往上（bottom-up）抽象的 folding 过程），然后从语义根据另一门语言的语法展开为另一门语言（一个逐层往下（top-down）的具体化 unfolding 过程）。如何可计算地实现这个过程，目前仍然是个难题。（我们看到很多地方都有 bottom-up/top-down 这样一个对称的过程，实际上有人猜测这正是生物神经网络原则上的运作方式，对视觉神经系统的研究尤其证明了这一点，Hawkins 在 《On Intelligence》 里面提出了一种 HTM （Hierarchical Temporal Memory）模型正是使用了这个原则。） 4.3 贝叶斯图像识别(Analysis by Synthesis)贝叶斯方法是一个非常 general 的推理框架。其核心理念可以描述成：Analysis by Synthesis （通过合成来分析）。06 年的认知科学新进展上有一篇 paper 就是讲用贝叶斯推理来解释视觉识别的，一图胜千言，下图就是摘自这篇 paper ： 首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念（比如是 E 还是 F 还是等号），然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像。 4.4 EM 算法与基于模型的聚类聚类（Cluster analysis）是一种无监督的机器学习问题，问题描述：给你一堆数据点，让你将它们最靠谱地分成一堆一堆的。聚类算法很多，不同的算法适应于不同的问题，这里仅介绍一个基于模型的聚类，该聚类算法对数据点的假设是，这些数据点分别是围绕 K 个核心的 K 个正态分布源所随机生成的，使用 Han JiaWei 的《Data Ming： Concepts and Techniques》中的图： 图中有两个正态分布核心，生成了大致两堆点。我们的聚类算法就是需要根据给出来的那些点，算出这两个正态分布的核心在什么位置，以及分布的参数是多少。这很明显又是一个贝叶斯问题，但这次不同的是，答案是连续的且有无穷多种可能性，更糟的是，只有当我们知道了哪些点属于同一个正态分布圈的时候才能够对这个分布的参数作出靠谱的预测，现在两堆点混在一块我们又不知道哪些点属于第一个正态分布，哪些属于第二个。反过来，只有当我们对分布的参数作出了靠谱的预测时候，才能知道到底哪些点属于第一个分布，那些点属于第二个分布。这就成了一个先有鸡还是先有蛋的问题了。为了解决这个循环依赖，总有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终收敛到一个解。这就是 EM 算法。 EM 的意思是“Expectation-Maximazation”，在这个聚类问题里面，我们是先随便猜一下这两个正态分布的参数：如核心在什么地方，方差是多少。然后计算出每个数据点更可能属于第一个还是第二个正态分布圈，这个是属于 Expectation 一步。有了每个数据点的归属，我们就可以根据属于第一个分布的数据点来重新评估第一个分布的参数（从蛋再回到鸡），这个是 Maximazation 。如此往复，直到参数基本不再发生变化为止。这个迭代收敛过程中的贝叶斯方法在第二步，根据数据点求分布的参数上面。 4.5 最大似然与最小二乘 学过线性代数的大概都知道经典的最小二乘方法来做线性回归。问题描述是：给定平面上 N 个点，（这里不妨假设我们想用一条直线来拟合这些点——回归可以看作是拟合的特例，即允许误差的拟合），找出一条最佳描述了这些点的直线。 一个接踵而来的问题就是，我们如何定义最佳？我们设每个点的坐标为 (Xi, Yi) 。如果直线为 y = f(x) 。那么 (Xi, Yi) 跟直线对这个点的“预测”：(Xi, f(Xi)) 就相差了一个 ΔYi = |Yi – f(Xi)| 。最小二乘就是说寻找直线使得 (ΔY1)^2 + (ΔY2)^2 + .. （即误差的平方和）最小，至于为什么是误差的平方和而不是误差的绝对值和，统计学上也没有什么好的解释。然而贝叶斯方法却能对此提供一个完美的解释。 我们假设直线对于坐标 Xi 给出的预测 f(Xi) 是最靠谱的预测，所有纵坐标偏离 f(Xi) 的那些数据点都含有噪音，是噪音使得它们偏离了完美的一条直线，一个合理的假设就是偏离路线越远的概率越小，具体小多少，可以用一个正态分布曲线来模拟，这个分布曲线以直线对 Xi 给出的预测 f(Xi) 为中心，实际纵坐标为 Yi 的点 (Xi, Yi) 发生的概率就正比于 EXP[-(ΔYi)^2]。（EXP(..) 代表以常数 e 为底的多少次方）。 现在我们回到问题的贝叶斯方面，我们要想最大化的后验概率是： P(h|D) ∝ P(h) * P(D|h) 又见贝叶斯！这里 h 就是指一条特定的直线，D 就是指这 N 个数据点。我们需要寻找一条直线 h 使得 P(h) P(D|h) 最大。很显然，P(h) 这个先验概率是均匀的，因为哪条直线也不比另一条更优越。所以我们只需要看 P(D|h) 这一项，这一项是指这条直线生成这些数据点的概率，刚才说过了，生成数据点 (Xi, Yi) 的概率为 EXP[-(ΔYi)^2] 乘以一个常数。而 P(D|h) = P(d1|h) P(d2|h) .. 即假设各个数据点是独立生成的，所以可以把每个概率乘起来。于是生成 N 个数据点的概率为 EXP[-(ΔY1)^2] EXP[-(ΔY2)^2] EXP[-(ΔY3)^2] .. = EXP{-[(ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + ..]} 最大化这个概率就是要最小化 (ΔY1)^2 + (ΔY2)^2 + (ΔY3)^2 + .. 。 熟悉这个式子吗？ 5. 朴素贝叶斯方法朴素贝叶斯方法是一个很特别的方法，所以值得介绍一下。我们用朴素贝叶斯在垃圾邮件过滤中的应用来举例说明。 5.1 贝叶斯垃圾邮件过滤器问题是什么？问题是，给定一封邮件，判定它是否属于垃圾邮件。按照先例，我们还是用 D 来表示这封邮件，注意 D 由 N 个单词组成。我们用 h+ 来表示垃圾邮件，h- 表示正常邮件。问题可以形式化地描述为求： P(h+|D) = P(h+) * P(D|h+) / P(D)P(h-|D) = P(h-) * P(D|h-) / P(D) 其中 P(h+) 和 P(h-) 这两个先验概率都是很容易求出来的，只需要计算一个邮件库里面垃圾邮件和正常邮件的比例就行了。然而 P(D|h+) 却不容易求，因为 D 里面含有 N 个单词 d1, d2, d3, .. ，所以P(D|h+) = P(d1,d2,..,dn|h+) 。我们又一次遇到了数据稀疏性，为什么这么说呢？P(d1,d2,..,dn|h+) 就是说在垃圾邮件当中出现跟我们目前这封邮件一模一样的一封邮件的概率是多大！开玩笑，每封邮件都是不同的，世界上有无穷多封邮件。瞧，这就是数据稀疏性，因为可以肯定地说，你收集的训练数据库不管里面含了多少封邮件，也不可能找出一封跟目前这封一模一样的。结果呢？我们又该如何来计算 P(d1,d2,..,dn|h+) 呢？ 我们将 P(d1,d2,..,dn|h+) 扩展为： P(d1|h+) P(d2|d1, h+) P(d3|d2,d1, h+) .. 。熟悉这个式子吗？这里我们会使用一个更激进的假设，我们假设 di 与 di-1 是完全条件无关的，于是式子就简化为 P(d1|h+) P(d2|h+) P(d3|h+) .. 。这个就是所谓的条件独立假设，也正是朴素贝叶斯方法的朴素之处。而计算 P(d1|h+) P(d2|h+) P(d3|h+) * .. 就太简单了，只要统计 di 这个单词在垃圾邮件中出现的频率即可。关于贝叶斯垃圾邮件过滤更多的内容可以参考这个条目，注意其中提到的其他资料。 一点注记：这里，为什么有这个数据稀疏问题，还是因为统计学习方法工作在浅层面，世界上的单词就算不再变多也是非常之多的，单词之间组成的句子也是变化多端，更不用说一篇文章了，文章数目则是无穷的，所以在这个层面作统计，肯定要被数据稀疏性困扰。我们要注意，虽然句子和文章的数目是无限的，然而就拿邮件来说，如果我们只关心邮件中句子的语义（进而更高抽象层面的“意图”（语义，意图如何可计算地定义出来是一个人工智能问题），在这个层面上可能性便大大缩减了，我们关心的抽象层面越高，可能性越小。单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。神经科学的发现也表明大脑的皮层大致有一种层级结构，对应着越来越抽象的各个层面，至于如何具体实现一个可放在计算机内的大脑皮层，仍然是一个未解决问题，以上只是一个原则（principle）上的认识，只有当 computational 的 cortex 模型被建立起来了之后才可能将其放入电脑。 5.2 为什么朴素贝叶斯方法令人诧异地好——一个理论解释朴素贝叶斯方法的条件独立假设看上去很傻很天真，为什么结果却很好很强大呢？就拿一个句子来说，我们怎么能鲁莽地声称其中任意一个单词出现的概率只受到它前面的 3 个或 4 个单词的影响呢？别说 3 个，有时候一个单词的概率受到上一句话的影响都是绝对可能的。那么为什么这个假设在实际中的表现却不比决策树差呢？有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考这篇 paper（The Optimality of Naive Bayes） 。 6. 层级贝叶斯模型 层级贝叶斯模型是现代贝叶斯方法的标志性建筑之一。前面讲的贝叶斯，都是在同一个事物层次上的各个因素之间进行统计推理，然而层次贝叶斯模型在哲学上更深入了一层，将这些因素背后的因素（原因的原因，原因的原因，以此类推）囊括进来。一个教科书例子是：如果你手头有 N 枚硬币，它们是同一个工厂铸出来的，你把每一枚硬币掷出一个结果，然后基于这 N 个结果对这 N 个硬币的 θ （出现正面的比例）进行推理。如果根据最大似然，每个硬币的 θ 不是 1 就是 0 （这个前面提到过的），然而我们又知道每个硬币的 p(θ) 是有一个先验概率的，也许是一个 beta 分布。也就是说，每个硬币的实际投掷结果 Xi 服从以 θ 为中心的正态分布，而 θ 又服从另一个以 Ψ 为中心的 beta 分布。层层因果关系就体现出来了。进而 Ψ 还可能依赖于因果链上更上层的因素，以此类推。 6.1 隐马可夫模型（HMM） 吴军在数学之美系列里面介绍的隐马可夫模型（Hidden Markov model）就是一个简单的层级贝叶斯模型： 那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做“隐含马尔可夫模型”（Hidden Markov Model）来解决这些问题。以语音识别为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,… 吴军的文章中这里省掉没说的是，s1, s2, s3, .. 这个句子的生成概率同时又取决于一组参数，这组参数决定了 s1, s2, s3, .. 这个马可夫链的先验生成概率。如果我们将这组参数记为 λ ，我们实际上要求的是：P(S|O, λ) （其中 O 表示 o1,o2,o3,.. ，S表示 s1,s2,s3,..） 当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公式并且省掉一个常数项，可以把上述公式等价变换成 P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…) 其中 P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…的可能性, 而P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的可能性，所以这个公式的意义是用发送信号为s1,s2,s3…这个数列的可能性乘以 s1,s2,s3.. 本身可以一个句子的可能性，得出概率。 这里，s1,s2,s3…本身可以一个句子的可能性其实就取决于参数 λ ，也就是语言模型。所以简而言之就是发出的语音信号取决于背后实际想发出的句子，而背后实际想发出的句子本身的独立先验概率又取决于语言模型。 7. 贝叶斯网络吴军已经对贝叶斯网络作了科普。更详细的理论参考所有机器学习的书上都有。 【参考资料】一堆机器学习，一堆概率统计，一堆 Google ，和一堆 Wikipedia 条目，一堆 paper 。 部分书籍参考《机器学习与人工智能资源导引》。 本文转载自 《数学之美番外篇：平凡而又神奇的贝叶斯方法》 刘未鹏mindhacks.cn","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Bayesian","slug":"Bayesian","permalink":"http://github.com/tags/Bayesian/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】RxJava 入门详解","slug":"【Android】RxJava 入门详解","date":"2016-12-19T11:03:00.000Z","updated":"2016-12-22T03:23:45.927Z","comments":true,"path":"2016/12/19/【Android】RxJava 入门详解/","link":"","permalink":"http://github.com/2016/12/19/【Android】RxJava 入门详解/","excerpt":"本文转载自 给 Android 开发者的 RxJava 详解 —— by 扔物线 前言我从去年开始使用 RxJava ，到现在一年多了。今年加入了 Flipboard 后，看到 Flipboard 的 Android 项目也在使用 RxJava ，并且使用的场景越来越多 。而最近这几个月，我也发现国内越来越多的人开始提及 RxJava 。有人说『RxJava 真是太好用了』，有人说『RxJava 真是太难用了』，另外更多的人表示：我真的百度了也谷歌了，但我还是想问： RxJava 到底是什么？ 鉴于 RxJava 目前这种既火爆又神秘的现状，而我又在一年的使用过程中对 RxJava 有了一些理解，我决定写下这篇文章来对 RxJava 做一个相对详细的、针对 Android 开发者的介绍。 这篇文章的目的有两个： 给对 RxJava 感兴趣的人一些入门的指引 给正在使用 RxJava 但仍然心存疑惑的人一些更深入的解析 在正文开始之前的最后，放上 GitHub 链接和引入依赖的 gradle 代码：RxJava ： https://github.com/ReactiveX/RxJavaRxAndroid： https://github.com/ReactiveX/RxAndroid 引入依赖： //（版本号是文章发布时的最新稳定版）compile 'io.reactivex:rxjava:1.0.14' compile 'io.reactivex:rxandroid:1.0.1'","text":"本文转载自 给 Android 开发者的 RxJava 详解 —— by 扔物线 前言我从去年开始使用 RxJava ，到现在一年多了。今年加入了 Flipboard 后，看到 Flipboard 的 Android 项目也在使用 RxJava ，并且使用的场景越来越多 。而最近这几个月，我也发现国内越来越多的人开始提及 RxJava 。有人说『RxJava 真是太好用了』，有人说『RxJava 真是太难用了』，另外更多的人表示：我真的百度了也谷歌了，但我还是想问： RxJava 到底是什么？ 鉴于 RxJava 目前这种既火爆又神秘的现状，而我又在一年的使用过程中对 RxJava 有了一些理解，我决定写下这篇文章来对 RxJava 做一个相对详细的、针对 Android 开发者的介绍。 这篇文章的目的有两个： 给对 RxJava 感兴趣的人一些入门的指引 给正在使用 RxJava 但仍然心存疑惑的人一些更深入的解析 在正文开始之前的最后，放上 GitHub 链接和引入依赖的 gradle 代码：RxJava ： https://github.com/ReactiveX/RxJavaRxAndroid： https://github.com/ReactiveX/RxAndroid 引入依赖： //（版本号是文章发布时的最新稳定版）compile 'io.reactivex:rxjava:1.0.14' compile 'io.reactivex:rxandroid:1.0.1' RxJava 到底是什么一个词：异步。 RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。 其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。 RxJava 好在哪换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』 一个词：简洁。 异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 举个例子？假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种： new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(\".png\")) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的： Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(\".png\"); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 那位说话了：『你这代码明明变多了啊！简洁个毛啊！』大兄弟你消消气，我说的是逻辑的简洁，不是单纯的代码量少（逻辑简洁才是提升读写代码速度的必杀技对不？）。观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。 另外，如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑： Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(\".png\") &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 如果你习惯使用 Retrolambda ，你也可以直接把代码写成上面这种简洁的形式。而如果你看到这里还不知道什么是 Retrolambda ，我不建议你现在就去学习它。原因有两点：1. Lambda 是把双刃剑，它让你的代码简洁的同时，降低了代码的可读性，因此同时学习 RxJava 和 Retrolambda 可能会让你忽略 RxJava 的一些技术细节；2. Retrolambda 是 Java 6/7 对 Lambda 表达式的非官方兼容方案，它的向后兼容性和稳定性是无法保障的，因此对于企业项目，使用 Retrolambda 是有风险的。所以，与很多 RxJava 的推广者不同，我并不推荐在学习 RxJava 的同时一起学习 Retrolambda。事实上，我个人虽然很欣赏 Retrolambda，但我从来不用它。 在Flipboard 的 Android 代码中，有一段逻辑非常复杂，包含了多次内存操作、本地文件操作和网络操作，对象分分合合，线程间相互配合相互等待，一会儿排成人字，一会儿排成一字。如果使用常规的方法来实现，肯定是要写得欲仙欲死，然而在使用 RxJava 的情况下，依然只是一条链式调用就完成了。它很长，但很清晰。 所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。 API 介绍和原理简析这个我就做不到一个词说明了……因为这一节的主要内容就是一步步地说明 RxJava 到底怎样做到了异步，怎样做到了简洁。 1. 概念：扩展的观察者模式RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。 观察者模式先简述一下观察者模式，已经熟悉的可以跳过这一段。 观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用注册(Register)或者称为订阅(Subscribe)的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过 setOnClickListener() 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷：『你在作案的时候务必通知我』。 OnClickListener 的模式大致如下图： 如图所示，通过 setOnClickListener() 方法，Button 持有 OnClickListener 的引用（这一过程没有在图上画出）；当用户点击时，Button 自动调用 OnClickListener 的 onClick() 方法。另外，如果把这张图中的概念抽象出来（Button -&gt; 被观察者、OnClickListener -&gt; 观察者、setOnClickListener() -&gt; 订阅，onClick() -&gt; 事件），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。如下图： 而 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。 RxJava 的观察者模式RxJava 有四个基本概念： Observable (可观察者，即被观察者) Observer (观察者) subscribe (订阅) Event (事件) Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。 onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 RxJava 的观察者模式大致如下图： 2. 基本实现基于以上的概念， RxJava 的基本实现主要有三点： 1) 创建 ObserverObserver 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式： Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的： Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 2) 创建 ObservableObservable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则： Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted(); &#125;&#125;); 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。 create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如： just(T...) : 将传入的参数依次发送出来。 Observable observable = Observable.just(\"Hello\", \"Hi\", \"Aloha\");// 将会依次调用：// onNext(\"Hello\");// onNext(\"Hi\");// onNext(\"Aloha\");// onCompleted(); from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 String[] words = &#123;\"Hello\", \"Hi\", \"Aloha\"&#125;;Observable observable = Observable.from(words);// 将会依次调用：// onNext(\"Hello\");// onNext(\"Hi\");// onNext(\"Aloha\");// onCompleted(); 上面 just(T...) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。 3) Subscribe (订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单： observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 有人可能会注意到， subscribe() 这个方法有点怪：它看起来是『observalbe 订阅了 observer / subscriber』而不是『observer / subscriber 订阅了 observalbe』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 observer.subscribe(observable) / subscriber.subscribe(observable) ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。 Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）： // 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 可以看到，subscriber() 做了3件事： 调用 Subscriber.onStart() 。这个方法在前面已经介绍过，是一个可选的准备方法。 调用 Observable 中的 OnSubscribe.call(Subscriber) 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe() 方法执行的时候。 将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe(). 整个过程中对象间的关系如下图： 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下： Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, \"completed\"); &#125;&#125;;// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 简单解释一下这段代码中出现的 Action1 和 Action0。 Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。 Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。 注：正如前面所提到的，Observer 和 Subscriber 具有相同的角色，而且 Observer 在 subscribe() 过程中最终会被转换成 Subscriber 对象，因此，从这里开始，后面的描述我将用 Subscriber 来代替 Observer ，这样更加严谨。 4) 场景示例下面举两个例子： 为了把原理用更清晰的方式表述出来，本文中挑选的都是功能尽可能简单的例子，以至于有些示例代码看起来会有『画蛇添足』『明明不用 RxJava 可以更简便地解决问题』的感觉。当你看到这种情况，不要觉得是因为 RxJava 太啰嗦，而是因为在过早的时候举出真实场景的例子并不利于原理的解析，因此我刻意挑选了简单的情景。 a. 打印字符串数组 将字符串数组 names 中的所有字符串依次打印出来： String[] names = ...;Observable.from(names) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String name) &#123; Log.d(tag, name); &#125; &#125;); b. 由 id 取得图片并显示 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 正如上面两个例子这样，创建出 Observable 和 Subscriber ，再用 subscribe() 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。 然而， 在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。 3. 线程控制 —— Scheduler (一)在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 1) Scheduler 的 API (一)在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 文字叙述总归难理解，上代码： Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.d(tag, \"number:\" + number); &#125; &#125;); 上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO线程 发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。 而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句： int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。 2) Scheduler 的原理 (一)RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。 好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。 4. 变换终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。 RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。 1) API首先看一个 map() 的例子： Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。 可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换： map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 的示意图： flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单： Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String name) &#123; Log.d(tag, name); &#125; ...&#125;;Observable.from(students) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(subscriber); 很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现： Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123; @Override public void onNext(Student student) &#123; List&lt;Course&gt; courses = student.getCourses(); for (int i = 0; i &lt; courses.size(); i++) &#123; Course course = courses.get(i); Log.d(tag, course.getName()); &#125; &#125; ...&#125;;Observable.from(students) .subscribe(subscriber); 依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？ 这个时候，就需要用 flatMap() 了： Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable, 而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。 这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。 flatMap() 示意图： 扩展：由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）： networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token .flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123; @Override public Observable&lt;Messages&gt; call(String token) &#123; // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表 return networkClient.messages(); &#125; &#125;) .subscribe(new Action1&lt;Messages&gt;() &#123; @Override public void call(Messages messages) &#123; // 处理显示消息列表 showMessages(messages); &#125; &#125;); 传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 flatMap() ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。 throttleFirst() : 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber); 妈妈再也不怕我的用户手抖点开两个重复的界面啦。 此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。 2) 变换的原理：lift()这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）： // 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) &#123; return Observable.create(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber subscriber) &#123; Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); &#125; &#125;);&#125; 这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）—— subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。 当含有 lift() 时： lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； 而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； 当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。 如果你更喜欢具象思维，可以看图： 或者可以看动图： 两次和多次的 lift() 同理，如下图： 举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考： observable.lift(new Observable.Operator&lt;String, Integer&gt;() &#123; @Override public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) &#123; // 将事件序列中的 Integer 对象转换为 String 对象 return new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer integer) &#123; subscriber.onNext(\"\" + integer); &#125; @Override public void onCompleted() &#123; subscriber.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; subscriber.onError(e); &#125; &#125;; &#125;&#125;); 讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。 3) compose: 对 Observable 整体的变换除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写： observable1 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber1);observable2 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber2);observable3 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber3);observable4 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber1); 你觉得这样太不软件工程了，于是你改成了这样： private Observable liftAll(Observable observable) &#123; return observable .lift1() .lift2() .lift3() .lift4();&#125;...liftAll(observable1).subscribe(subscriber1);liftAll(observable2).subscribe(subscriber2);liftAll(observable3).subscribe(subscriber3);liftAll(observable4).subscribe(subscriber4); 可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了： public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; &#123; @Override public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) &#123; return observable .lift1() .lift2() .lift3() .lift4(); &#125;&#125;...Transformer liftAll = new LiftAllTransformer();observable1.compose(liftAll).subscribe(subscriber1);observable2.compose(liftAll).subscribe(subscriber2);observable3.compose(liftAll).subscribe(subscriber3);observable4.compose(liftAll).subscribe(subscriber4); 像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call() 方法直接对自身进行处理，也就不必被包在方法的里面了。 compose() 的原理比较简单，不附图喽。 5. 线程控制：Scheduler (二)除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。 1) Scheduler 的 API (二)前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map()、 flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？ 答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码： Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。 不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。 又有好事的（其实还是当初的我）问了：如果我非要调用多次 subscribeOn() 呢？会有什么效果？ 这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。 2) Scheduler 的原理（二）其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）： subscribeOn() 原理图： observeOn() 原理图： 从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）： 图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。 3) 延伸：doOnSubscribe()然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。 在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。 而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 示例代码： Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。 RxJava 的适用场景和使用方式1. 与 Retrofit 的结合 Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。 Retrofit 除了提供了传统的 Callback 形式的 API，还有 RxJava 版本的 Observable 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。 以获取一个 User 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求： @GET(\"/user\")public void getUser(@Query(\"userId\") String userId, Callback&lt;User&gt; callback); 在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应： getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 而使用 RxJava 形式的 API，定义同样的请求是这样的： @GET(\"/user\")public Observable&lt;User&gt; getUser(@Query(\"userId\") String userId); 使用的时候是这样的： getUser(userId) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 看到区别了吗？ 当 RxJava 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。 对比来看， Callback 形式和 Observable 形式长得不太一样，但本质都差不多，而且在细节上 Observable 形式似乎还比 Callback 形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？ 因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， Callback 形式马上就会开始让人头疼。比如： 假设这么一种情况：你的程序取到的 User 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 Callback 方式大概可以这么写： getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; processUser(user); // 尝试修正 User 数据 userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 有问题吗？ 很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下： getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; new Thread() &#123; @Override public void run() &#123; processUser(user); // 尝试修正 User 数据 runOnUiThread(new Runnable() &#123; // 切回 UI 线程 @Override public void run() &#123; userView.setUser(user); &#125; &#125;); &#125;).start(); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。 这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的： getUser(userId) .doOnNext(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; processUser(user); &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 后台代码和前台代码全都写在一条链中，明显清晰了很多。 再举一个例子：假设 /user 接口并不能直接访问，而需要填入一个在线获取的 token ，代码应该怎么写？ Callback 方式，可以使用嵌套的 Callback： @GET(\"/token\")public void getToken(Callback&lt;String&gt; callback);@GET(\"/user\")public void getUser(@Query(\"token\") String token, @Query(\"userId\") String userId, Callback&lt;User&gt; callback);...getToken(new Callback&lt;String&gt;() &#123; @Override public void success(String token) &#123; getUser(token, userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125; &#125;; &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;); 倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。 而使用 RxJava 的话，代码是这样的： @GET(\"/token\")public Observable&lt;String&gt; getToken();@GET(\"/user\")public Observable&lt;User&gt; getUser(@Query(\"token\") String token, @Query(\"userId\") String userId);...getToken() .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; onNext(String token) &#123; return getUser(token, userId); &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 用一个 flatMap() 就搞定了逻辑，依然是一条链。看着就很爽，是吧？ 2016/03/31 更新，加上我写的一个 Sample 项目： rengwuxian RxJava Samples 好，Retrofit 部分就到这里。 2. RxBindingRxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 OnClickListener 、设置 TextWatcher 这样的注册绑定对象的 API。 举个设置点击监听的例子。使用 RxBinding ，可以把事件监听用这样的方法来设置： Button button = ...;RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件 .subscribe(new Action1&lt;ViewClickEvent&gt;() &#123; @Override public void call(ViewClickEvent event) &#123; // Click handling &#125; &#125;); 看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 setOnClickListener() 来实现的。然而，仅仅这一个形式的改变，却恰好就是 RxBinding 的目的：扩展性。通过 RxBinding 把点击监听转换成 Observable 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 throttleFirst() ，用于去抖动，也就是消除手抖导致的快速连环点击： RxView.clickEvents(button) .throttleFirst(500, TimeUnit.MILLISECONDS) .subscribe(clickAction); 如果想对 RxBinding 有更多了解，可以去它的 GitHub 项目 下面看看。 3. 各种异步操作前面举的 Retrofit 和 RxBinding 的例子，是两个可以提供现成的 Observable 的库。而如果你有某些异步操作无法用这些库来自动生成 Observable，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。 4. RxBusRxBus 名字看起来像一个库，但它并不是一个库，而是一种模式。它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 Otto 或者 GreenRobot 的 EventBus。至于什么是 RxBus，可以看这篇文章。顺便说一句，Flipboard 已经用 RxBus 替换掉了 Otto ，目前为止没有不良反应。 最后对于 Android 开发者来说， RxJava 是一个很难上手的库，因为它对于 Android 开发者来说有太多陌生的概念了。可是它真的很牛逼。因此，我写了这篇《给 Android 开发者的 RxJava 详解》，希望能给始终搞不明白什么是 RxJava 的人一些入门的指引，或者能让正在使用 RxJava 但仍然心存疑惑的人看到一些更深入的解析。无论如何，只要能给各位同为 Android 工程师的你们提供一些帮助，这篇文章的目的就达到了。 关于作者朱凯（扔物线），Flipboard 北京 Android 工程师。 为什么写这个？与两三年前的境况不同，中国现在已经不缺初级 Android 工程师，但中级和高级工程师严重供不应求。因此我决定从今天开始不定期地发布我的技术分享，只希望能够和大家共同提升，通过我们的成长来解决一点点国内互联网公司人才稀缺的困境，也提升各位技术党的收入。所以，不仅要写这篇，我还会写更多。至于内容的定位，我计划只定位真正的干货，一些边边角角的小技巧和炫酷的黑科技应该都不会写，总之希望每篇文章都能帮读者提升真正的实力。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://github.com/tags/RxJava/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】APK瘦身记，实现将近一半的压缩效果","slug":"【Android】APK瘦身记，实现将近一半的压缩效果","date":"2016-11-30T02:31:55.000Z","updated":"2016-12-22T05:01:06.038Z","comments":true,"path":"2016/11/30/【Android】APK瘦身记，实现将近一半的压缩效果/","link":"","permalink":"http://github.com/2016/11/30/【Android】APK瘦身记，实现将近一半的压缩效果/","excerpt":"本文转载自知乎： APK瘦身记，如何实现高达53%的压缩效果 —— by 阿里聚安全 一、我是怎么思考这件事情的APK是Android系统安装包的文件格式，关于这个话题其实是一个老生常谈的题目，不论是公司内部，还是外部网络，前人前辈已经总结出很多方法和规律。不过随着移动端技术近两年的飞速发展，一些新的思维方式和优化方法也逐渐涌现和成熟起来。笔者在实践过程中踩过一些坑，收获了一些经验，在这里做个思考和总结，所以随笔给大家，希望对大家从事相关工作的时候有所帮助和参考，同时也是抛砖引玉，希望大家共同探讨这个开放性的话题。 关于为什么APK要瘦身，这个不多说，只从三个方面唠叨一下，对于用户（或者客户）来说，APK越大，在下载安装过程中，他们耗费的流量会越多，安装等待时间也会越长；对于产品本身，意味着下载转化率会越低（因为竞品中，用户有更多机会选择那个体验最好，功能最多，性能最好，包最小的）；对于研发来说，是一种优化改进技术的机会。","text":"本文转载自知乎： APK瘦身记，如何实现高达53%的压缩效果 —— by 阿里聚安全 一、我是怎么思考这件事情的APK是Android系统安装包的文件格式，关于这个话题其实是一个老生常谈的题目，不论是公司内部，还是外部网络，前人前辈已经总结出很多方法和规律。不过随着移动端技术近两年的飞速发展，一些新的思维方式和优化方法也逐渐涌现和成熟起来。笔者在实践过程中踩过一些坑，收获了一些经验，在这里做个思考和总结，所以随笔给大家，希望对大家从事相关工作的时候有所帮助和参考，同时也是抛砖引玉，希望大家共同探讨这个开放性的话题。 关于为什么APK要瘦身，这个不多说，只从三个方面唠叨一下，对于用户（或者客户）来说，APK越大，在下载安装过程中，他们耗费的流量会越多，安装等待时间也会越长；对于产品本身，意味着下载转化率会越低（因为竞品中，用户有更多机会选择那个体验最好，功能最多，性能最好，包最小的）；对于研发来说，是一种优化改进技术的机会。 欲瘦身，我们先找找胖的原因和问题。按目标－路径－资源的思维模式，找原因和问题有如下几条路径，一是拍脑袋，按自己的经验和判断，甚至是主观想象；二是去搜索引擎找关键字，逛各种技术论坛听技术大牛们怎么说，看各类技术文章抽取提炼；三是用一种可测量的工具或者方法发现问题。 前两种不赘述，我这里说说第三种方法。用一种可测量的工具或者方法来分析，所谓工欲善其事，必先利其器。这个器可以可以自己锻造，也可以用现成的。这里推荐一个在线apk分析工具，因为是外部工具，所以大家请在使用过程中，不要上传未发布出去的产品，为了数据安全，笔者这里拿一个github上开源的Android项目作为瘦身示例。 二、寻找问题NimbleDroid 是美国哥伦比亚大学的博士创业团队研发出来的分析Android app性能指标的系统，分析的方式有静态和动态两种方式，其中静态分析可以分析出APK安装包中大文件排行榜，各种知名SDK的大小以及占代码整体的比例，各种类型文件的大小以及占排行，各种知名SDK的方法数以及占所有dex中方法数的比例，废话不多说，下面上高清无码大图看看颜值吧。 如果想使用分析功能分析自己的产品，请登录并上传自己产品的apk包，所有功能目前均免费使用，如果是想分析Google Play上已经发布的产品，可以直接点击”Play Apps”查看，还可以使用搜索功能根据应用名和包名查看结果。再次强调下，请不要上传任何未发布的产品。 登录 上传apk文件 分析结果摘要 可以看到一些概览的信息，apk文件大小，总的方法数 文件大小分析详情页，大文件列表 这里列出的是apk文件中超过100k的文件排行，这里的文件大小指的是apk文件中的大小 各种知名SDK的大小以及占代码整体的比例，这里目前能识别出Android Support，Jackson JSON parser, Google Play Services, Paypal, Glide, OkHttp, Facebook SDK, Fabric, Gson等等，Application表示App中自己编写的代码部分 各种类型文件的大小以及排行 各种知名SDK占所有dex中方法数的比例 各种知名SDK的方法数排行榜 看完这个apk内剖图是不是有一种神清气爽的感觉！我把这个分析工具比做我们家买的智能体重秤，可以称体重，脂肪含量，骨重，骨密度，肌肉含量等等，那么，我们是不是发现了一些问题，进而把这些问题和我们之前靠经验和一拍脑袋的原因可以用逻辑联系在一起。 那么，我们接下来可以通过分析数据整理出我们的优化目标 大文件排行榜里，有11张png文件的大小超过了100k，记住，这可是压缩之后的啊； 大文件排行榜里，resources.arsc的大小接近2M，这也是一个优化点； 大文件排行榜里，classes.dex接近3M，classes.dex是代码的载体，这块的优化需要细分，再去看看细分SDK的排行榜； 组件占比环图里，Android Support, Jackson JSON Parser和Google Play Services是三方库的前三甲； 文件类型排行榜里，png, dex 和arsc是前三甲； 三、梳理优化目标所以我们的目标是没有蛀牙，不对，是下面的目标： png图片优化； resources.arsc文件的优化； 代码优化 3.1 图片优化的尝试首先是第一个目标，图片的优化，慢点，我们看看这些图为什么这么大先，准确的说，为什么这些图在apk（其实就是zip文件）里这么大，好了，上工具分析。 这次用了一些简单的工具组合，系统自带的cmd就好。 命令执行的结果如下 恩，所有的png文件居然是STORE的方式存储到apk里的，关于zip里的STORE和DEFLATE，详见Wikipedia ) 通俗的说，当文件是STORED的方式存储到zip，表示这个文件并没有经过压缩，如果是Defl:N的方式，表示通过DEFLATED normal的方式压缩存储到zip。 这看起来有点不合理，png原封不动的放入zip，当然最后产出的apk会比较大。那么，如何解决呢？笔者首先尝使用android gradle plugin的方式，发现aaptOptions和packagingOptions都未能解决问题。在github上发现一个开源项目AndResGuard，试了集成到项目中，再看结果如下： 优化前： 10536027字节 优化后： 普通zip压缩： 8786265字节 （压缩了将近17%） 采用7zip压缩：8567150字节 （压缩了将近19%） 再看看这个工具做了什么，对比下开启资源混淆前后 优化前 优化后 资源（png, xml, jpg等）名称混淆，资源路径名称混淆以及名称长度压缩； 原来以STORED形式存储到zip中的png文件被改成了DEFLATED（普通压缩存储）方式； 意外发现resources.arsc, META-INF/.SF 以及 META-INF/.MF变小了，而且是解压之后的文件大小也变小了。 用apk反编译神器jadx内窥apk寻找真相 原来apk中资源（png, xml，以及properties文件）的相对路径会存放到META-INF/.SF 以及 META-INF/.MF中并为每个资源文件计算SHA1值并存储在这两个文件中，至于为啥这么做以及这两个SHA1有啥区别和作用请参考网络上关于这方面知识的文章，已超出本文的主题所以这里不再赘述。 对于resources.arsc文件 很容易看出来它是资源文件索引表，所以，看到这里大家应该明白这三个文件为啥会变小了吧。 3.2 一次意外的发现顺着resources.arsc往下看，发现一个有趣的东西， 这又将成为一个优化点，去除那些没用的翻译资源，引入一些第三方的SDK，往往这些SDK带了很多翻译资源在里面，比如android support库，去掉后我们来看看效果。 假设我们只保留英文，当然只是个实验，现实中看具体情况了， 采用7zip压缩：8220738字节 （压缩了将近22%，再增加3个点） 当然，真实的项目里不可能这样，但是蚊子肉也是肉啊！ 其实，我想说的是这提供了一种优化思路，就是利用gradle的配置干掉无用的资源，同样的可以用在so本地库上，分辨率（gradle配置已deprecated）上。 gradle配置示例如下： 记得包在android{}中间哦。那么，有人要问了，abi里肿么没有x86？据说intel提供了一个解决方案叫houdini，是一个运行在x86设备上的中间件，可以将arm转码为x86的指令，不过效率很低，有些运算型的，比如计算MD5和SHA1，甚至不如java，笔者曾经做过测试对比，又是另外一个话题，此处不赘述，感兴趣的读者可以移步。 到此为止，我们已经在朝第一个目标迈进，不经意间发现了第一个目标和第二个目标之间的关系，所以利用资源混淆工具，达成了第二个目标。 利用7zip压缩，我们对整个包进行了2个点的压缩，这是一个超出预期的成果。 3.3图片优化的方法关于第一个目标，我们的路径还没有结束，拍脑袋想出来的路径是压缩png，非alpha图转成jpg，还有什么？所以去各种技术论坛逛了一圈，请教了各种技术大牛，梳理的路径如下： 1、手动lint检查，手动删除代码中没有引用到的资源，实际效果不等。 在Android Studio中打开“Analyze” 然后选择”Inspect Code…”，范围选择整个项目，然后点击”OK” 配置如下图 2、gradle脚本中开启shrinkResources 脚本参考如下 shrinkResources配合minifyEnabled使用效果更佳，详见shrinkResources用法以及注意 采用7zip压缩：8115283字节 （压缩了将近23%，再增加1个点） 3、使用图片压缩工具，压缩png图的大小，将非alpha的图转换成jpg形式，关于这点同事以及网络上的大牛们已经整理的很详细了，我这里做简单总结，欲知详情，请见附录的参考。 使用tinypng，我只想说咱们在公司做产品，此方案慎用，上传任何未发布产品的内容到外部网络，都有可能引起数据泄漏，所以慎用此方案。下面说替代方案。 WASTED pngquant ImageAlpha ImageOptim 以上工具太散，有没有集成化的工具，答案是“有” @心伦 童鞋开发的imagemin @姐夫童鞋开发的MSImageResourcesHelper png转成jpg格式，具体效果不等。 4、终极大杀器，png转成webp，关于webp，更多详情请参考谷歌官方文档以及安卓开发者在线参考 先上效果图： 采用7zip压缩：4926912字节 （压缩了将近53%，再增加30个点） 没看错吧，是30个点，目前apk的大小是原始apk大小的一半不到，而我做的，一行代码木有改动，仅用了一些工具而已！ 说人话，我木有吃减肥药，木有绝食，体重却轻了一半！！！ 但是，目前却没能用到项目中，因为有两个坑 在三星的部分机型上，部分有alpha背景部分的图会有一条很明显的黑线，这里就不上图了，这个问题目前通过白名单的方式不去做成webp的图来处理； 在小米2刷成4.xx的手机上，未能正确识别xml文件中描述的webp图片，导致界面起来后加载xml布局文件，文件加载webp失败，报错说resource file not found，导致app发生崩溃。跟踪发现是小米机器代理了类Resource为MIUIResource，但是这个MIUIResource未能正确识别webp，所以导致加载资源文件失败，初步判定，目前暂时没有解决方案，所以只能忍痛放弃这个优化方案。 关于第一个目标，图片资源的优化，就写到这里了。 3.4 代码优化第二个目标已达成，剩下第三个目标，代码的优化，梳理如下优化路径： 1、开启proguard的代码优化将 proguardFiles getDefaultProguardFile('proguard-android.txt'),'proguard-project.txt' 改为 proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),'proguard-project.txt' 开启代码优化后的注意点请参见附录。 2、去除无用的库如果apk支持的最低版本是API14,而代码中没有用到高于api14的api就可以考虑拿掉整个android support库。 3、用更小的库替代方案如果只用到了谷歌统计，那么就不要把整个google play services都集成进来，只集成需要的部分。 4、定期清理废弃的代码定期删除无用的逻辑和过期的业务功能模块，以及废弃的A/B test代码。 5、业务模块采用插件化框架，代码动态从云端拉取插件化，这是另外一个课题了，这里不赘述。 apk瘦身记最终的成果 10536027字节压缩到4926912字节, 压缩了将近53% 总结 脚本中开启资源混淆和资源压缩 用7zip代替zip gradle脚本中开启代码混淆优化和无用资源删除 用更小的图，使用压缩工具压缩图片大小 去除无用的资源，语言，本地so库，二方三方库和分辨率 用更小的库 尝试将android support库彻底踢出你的项目 定期清理代码 尝试用H5编写界面，图片云端获取 尝试插件化业务模块 寻找到zip文件夹中所有用STORE形式存储的文件（不限于raw目录下），尝试压缩，以及替代方案加载这些资源 尝试webp的图片加载方案，寻求突破 最后，继续学习和尝试新的优化方案 以此文献给“唯瘦身与产品不可辜负”的技术们！！！ 附录 如何做到将apk大小减少6M Android APP终极瘦身指南 APK瘦身实践","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"APK","slug":"APK","permalink":"http://github.com/tags/APK/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"基于社区发现算法和图分析Neo4j解读《权力的游戏》","slug":"基于社区发现算法和图分析Neo4j解读《权力的游戏》","date":"2016-11-21T03:08:00.000Z","updated":"2016-12-09T07:27:27.747Z","comments":true,"path":"2016/11/21/基于社区发现算法和图分析Neo4j解读《权力的游戏》/","link":"","permalink":"http://github.com/2016/11/21/基于社区发现算法和图分析Neo4j解读《权力的游戏》/","excerpt":"导读几个月前，数学家 Andrew Beveridge 和Jie Shan在数学杂志上发表《权力的网络》，主要分析畅销小说《冰与火之歌》第三部《冰雨的风暴》中人物关系，其已经拍成电视剧《权力的游戏》系列。他们在论文中介绍了如何通过文本分析和实体提取构建人物关系的网络。紧接着，使用社交网络分析算法对人物关系网络分析找出最重要的角色；应用社区发现算法来找到人物聚类。 其中的分析和可视化是用Gephi做的，Gephi是非常流行的图分析工具。但作者觉得使用Neo4j来实现更有趣。 导入原始数据到Neo4j原始数据可从网络上下载，格式如下： Source,Target,WeightAemon,Grenn,5Aemon,Samwell,31Aerys,Jaime,18...","text":"导读几个月前，数学家 Andrew Beveridge 和Jie Shan在数学杂志上发表《权力的网络》，主要分析畅销小说《冰与火之歌》第三部《冰雨的风暴》中人物关系，其已经拍成电视剧《权力的游戏》系列。他们在论文中介绍了如何通过文本分析和实体提取构建人物关系的网络。紧接着，使用社交网络分析算法对人物关系网络分析找出最重要的角色；应用社区发现算法来找到人物聚类。 其中的分析和可视化是用Gephi做的，Gephi是非常流行的图分析工具。但作者觉得使用Neo4j来实现更有趣。 导入原始数据到Neo4j原始数据可从网络上下载，格式如下： Source,Target,WeightAemon,Grenn,5Aemon,Samwell,31Aerys,Jaime,18... 上面是人物关系的之邻接表以及关系权重。作者使用简单的数据模型： (:Character &#123;name&#125;)-[:INTERACTS]-&gt;(:Character &#123;name&#125;) 带有标签Character的节点代表小说中的角色，用单向关系类型INTERACTS代表小说中的角色有过接触。节点属性会存储角色的名字name，两角色间接触的次数作为关系的属性：权重（weight）。 首先创建节点c，并做唯一限制性约束，c.name唯一，保证schema的完整性： CREATE CONSTRAINT ON (c:Character) ASSERT c.name IS UNIQUE; 一旦约束创建即相应的创建索引，这将有助于通过角色的名字查询的性能。作者使用Neo4j的Cypher（Cypher是一种声明式图查询语言，能表达高效查询和更新图数据库）LOAD CSV语句导入数据： LOAD CSV WITH HEADERS FROM &quot;https://www.macalester.edu/~abeverid/data/stormofswords.csv&quot; AS rowMERGE (src:Character &#123;name: row.Source&#125;)MERGE (tgt:Character &#123;name: row.Target&#125;)MERGE (src)-[r:INTERACTS]-&gt;(tgt)SET r.weight = toInt(row.Weight) 这样得到一个简单的数据模型： CALL apoc.meta.graph() 我们能可视化整个图形，但是这并不能给我们很多信息，比如哪些是最重要的人物，以及他们相互接触的信息： MATCH p=(:Character)-[:INTERACTS]-(:Character)RETURN p 人物网络分析作者使用Neo4j的图查询语言Cypher来做《权力的游戏》图分析，应用到了网络分析的一些工具，具体见《网络，人群和市场：关于高度连接的世界》。 人物数量万事以简单开始。先看看上图上由有多少人物： MATCH (c:Character) RETURN count(c) count(c) 107 概要统计统计每个角色接触的其它角色的数目： MATCH (c:Character)-[:INTERACTS]-&gt;()WITH c, count(*) AS numRETURN min(num) AS min, max(num) AS max, avg(num) AS avg_characters, stdev(num) AS stdev min max avg_characters stdev 1 24 4.957746478873241 6.227672391875085 图（网络）的直径网络的直径或者测底线或者最长最短路径： // Find maximum diameter of network// maximum shortest path between two nodesMATCH (a:Character), (b:Character) WHERE id(a) &gt; id(b)MATCH p=shortestPath((a)-[:INTERACTS*]-(b))RETURN length(p) AS len, extract(x IN nodes(p) | x.name) AS pathORDER BY len DESC LIMIT 4 len path 6 [Illyrio, Belwas, Daenerys, Robert, Tywin, Oberyn, Amory] 6 [Illyrio, Belwas, Daenerys, Robert, Sansa, Bran, Jojen] 6 [Illyrio, Belwas, Daenerys, Robert, Stannis, Davos, Shireen] 6 [Illyrio, Belwas, Daenerys, Robert, Sansa, Bran, Luwin] 我们能看到网络中有许多长度为6的路径。 最短路径作者使用Cypher 的shortestPath函数找到图中任意两个角色之间的最短路径。让我们找出凯特琳·史塔克（Catelyn Stark ）和卓戈·卡奥（Kahl Drogo）之间的最短路径： // Shortest path from Catelyn Stark to Khal DrogoMATCH (catelyn:Character &#123;name: &quot;Catelyn&quot;&#125;), (drogo:Character &#123;name: &quot;Drogo&quot;&#125;)MATCH p=shortestPath((catelyn)-[INTERACTS*]-(drogo))RETURN p 所有最短路径联结凯特琳·史塔克（Catelyn Stark ）和卓戈·卡奥（Kahl Drogo）之间的最短路径可能还有其它路径，我们可以使用Cypher的allShortestPaths函数来查找： // All shortest paths from Catelyn Stark to Khal DrogoMATCH (catelyn:Character &#123;name: &quot;Catelyn&quot;&#125;), (drogo:Character &#123;name: &quot;Drogo&quot;&#125;)MATCH p=allShortestPaths((catelyn)-[INTERACTS*]-(drogo))RETURN p 关键节点在网络中，如果一个节点位于其它两个节点所有的最短路径上，即称为关键节点。下面我们找出网络中所有的关键节点： // Find all pivotal nodes in networkMATCH (a:Character), (b:Character)MATCH p=allShortestPaths((a)-[:INTERACTS*]-(b)) WITH collect(p) AS paths, a, bMATCH (c:Character) WHERE all(x IN paths WHERE c IN nodes(x)) AND NOT c IN [a,b]RETURN a.name, b.name, c.name AS PivotalNode SKIP 490 LIMIT 10 a.name b.name PivotalNode Aegon Thoros Daenerys Aegon Thoros Robert Drogo Ramsay Robb Styr Daario Daenerys Styr Daario Jon Styr Daario Robert Qhorin Podrick Jon Qhorin Podrick Sansa Orell Theon Jon Illyrio Bronn Belwas 从结果表格中我们可以看出有趣的结果：罗柏·史塔克（Robb）是卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）的关键节点。这意味着，所有联结卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）的最短路径都要经过罗柏·史塔克（Robb）。我们可以通过可视化卓戈·卡奥（Drogo）和拉姆塞·波顿（Ramsay）之间的所有最短路径来验证： MATCH (a:Character &#123;name: &quot;Drogo&quot;&#125;), (b:Character &#123;name: &quot;Ramsay&quot;&#125;)MATCH p=allShortestPaths((a)-[:INTERACTS*]-(b))RETURN p 节点中心度节点中心度给出网络中节点的重要性的相对度量。有许多不同的方式来度量中心度，每种方式都代表不同类型的“重要性”。 度中心性(Degree Centrality)度中心性是最简单度量，即为某个节点在网络中的联结数。在《权力的游戏》的图中，某个角色的度中心性是指该角色接触的其他角色数。作者使用Cypher计算度中心性： MATCH (c:Character)-[:INTERACTS]-()RETURN c.name AS character, count(*) AS degree ORDER BY degree DESC character degree Tyrion 36 Jon 26 Sansa 26 Robb 25 Jaime 24 Tywin 22 Cersei 20 Arya 19 Joffrey 18 Robert 18 从上面可以发现，在《权力的游戏》网络中提利昂·兰尼斯特（Tyrion）和最多的角色有接触。鉴于他的心计，我们觉得这是有道理的。 加权度中心性（Weighted Degree Centrality）作者存储一对角色接触的次数作为INTERACTS关系的weight属性。对该角色的INTERACTS关系的所有weight相加得到加权度中心性。作者使用Cypher计算所有角色的这个度量： MATCH (c:Character)-[r:INTERACTS]-()RETURN c.name AS character, sum(r.weight) AS weightedDegree ORDER BY weightedDegree DESC character weightedDegree Tyrion 551 Jon 442 Sansa 383 Jaime 372 Bran 344 Robb 342 Samwell 282 Arya 269 Joffrey 255 Daenerys 232 介数中心性（Betweenness Centrality）介数中心性：在网络中，一个节点的介数中心性是指其它两个节点的所有最短路径都经过这个节点，则这些所有最短路径数即为此节点的介数中心性。介数中心性是一种重要的度量，因为它可以鉴别出网络中的“信息中间人”或者网络聚类后的联结点。 为了计算介数中心性，作者使用Neo4j 3.x或者apoc库。安装apoc后能用Cypher调用其170+的程序： MATCH (c:Character)WITH collect(c) AS charactersCALL apoc.algo.betweenness([&apos;INTERACTS&apos;], characters, &apos;BOTH&apos;) YIELD node, scoreSET node.betweenness = scoreRETURN node.name AS name, score ORDER BY score DESC name score Jon 1279.7533534055322 Robert 1165.6025171231624 Tyrion 1101.3849724234349 Daenerys 874.8372110508583 Robb 706.5572832464792 Sansa 705.1985623519137 Stannis 571.5247305125714 Jaime 556.1852522889822 Arya 443.01358430043337 Tywin 364.7212195528086 紧度中心性（Closeness centrality）紧度中心性是指到网络中所有其他角色的平均距离的倒数。在图中，具有高紧度中心性的节点在聚类社区之间被高度联结，但在社区之外不一定是高度联结的。 MATCH (c:Character)WITH collect(c) AS charactersCALL apoc.algo.closeness([&apos;INTERACTS&apos;], characters, &apos;BOTH&apos;) YIELD node, scoreRETURN node.name AS name, score ORDER BY score DESC name score Tyrion 0.004830917874396135 Sansa 0.004807692307692308 Robert 0.0047169811320754715 Robb 0.004608294930875576 Arya 0.0045871559633027525 Jaime 0.004524886877828055 Stannis 0.004524886877828055 Jon 0.004524886877828055 Tywin 0.004424778761061947 Eddard 0.004347826086956522 使用python-igraphNeo4j与其它工具（比如，R和Python数据科学工具）完美结合。我们继续使用apoc运行 PageRank和社区发现（community detection）算法。这里接着使用python-igraph计算分析。Python-igraph移植自R的igraph图形分析库。 使用pip install python-igraph安装它。 从Neo4j构建一个igraph实例为了在《权力的游戏》的数据的图分析中使用igraph，首先需要从Neo4j拉取数据，用Python建立igraph实例。作者使用 Neo4j 的Python驱动库py2neo。我们能直接传入Py2neo查询结果对象到igraph的TupleList构造器，创建igraph实例： from py2neo import Graphfrom igraph import Graph as IGraphgraph = Graph()query = '''MATCH (c1:Character)-[r:INTERACTS]-&gt;(c2:Character)RETURN c1.name, c2.name, r.weight AS weight'''ig = IGraph.TupleList(graph.run(query), weights=True) 现在有了igraph对象，可以运行igraph实现的各种图算法来。 PageRank作者使用igraph运行的第一个算法是PageRank。PageRank算法源自Google的网页排名。它是一种特征向量中心性(eigenvector centrality)算法。 在igraph实例中运行PageRank算法，然后把结果写回Neo4j，在角色节点创建一个pagerank属性存储igraph计算的值： pg = ig.pagerank()pgvs = []for p in zip(ig.vs, pg): print(p) pgvs.append(&#123;\"name\": p[0][\"name\"], \"pg\": p[1]&#125;)pgvswrite_clusters_query = '''UNWIND &#123;nodes&#125; AS nMATCH (c:Character) WHERE c.name = n.nameSET c.pagerank = n.pg'''graph.run(write_clusters_query, nodes=pgvs) 现在可以在Neo4j的图中查询最高PageRank值的节点： MATCH (n:Character)RETURN n.name AS name, n.pagerank AS pagerank ORDER BY pagerank DESC LIMIT 10 name pagerank Tyrion 0.042884981999963316 Jon 0.03582869669163558 Robb 0.03017114665594764 Sansa 0.030009716660108578 Daenerys 0.02881425425830273 Jaime 0.028727587587471206 Tywin 0.02570016262642541 Robert 0.022292016521362864 Cersei 0.022287327589773507 Arya 0.022050209663844467 社区发现算法用来找出图中的社区聚类。作者使用igraph实现的随机游走算法（ walktrap）来找到在社区中频繁有接触的角色社区，在社区之外角色不怎么接触。 在igraph中运行随机游走的社区发现算法，然后把社区发现的结果导入Neo4j，其中每个角色所属的社区用一个整数来表示： clusters = IGraph.community_walktrap(ig, weights=\"weight\").as_clustering()nodes = [&#123;\"name\": node[\"name\"]&#125; for node in ig.vs]for node in nodes: idx = ig.vs.find(name=node[\"name\"]).index node[\"community\"] = clusters.membership[idx]write_clusters_query = '''UNWIND &#123;nodes&#125; AS nMATCH (c:Character) WHERE c.name = n.nameSET c.community = toInt(n.community)'''graph.run(write_clusters_query, nodes=nodes) 我们能在Neo4j中查询有多少个社区以及每个社区的成员数： MATCH (c:Character)WITH c.community AS cluster, collect(c.name) AS membersRETURN cluster, members ORDER BY cluster ASC cluster members 0 [Aemon, Alliser, Craster, Eddison, Gilly, Janos, Jon, Mance, Rattleshirt, Samwell, Val, Ygritte, Grenn, Karl, Bowen, Dalla, Orell, Qhorin, Styr] 1 [Aerys, Amory, Balon, Brienne, Bronn, Cersei, Gregor, Jaime, Joffrey, Jon Arryn, Kevan, Loras, Lysa, Meryn, Myrcella, Oberyn, Podrick, Renly, Robert, Robert Arryn, Sansa, Shae, Tommen, Tyrion, Tywin, Varys, Walton, Petyr, Elia, Ilyn, Pycelle, Qyburn, Margaery, Olenna, Marillion, Ellaria, Mace, Chataya, Doran] 2 [Arya, Beric, Eddard, Gendry, Sandor, Anguy, Thoros] 3 [Brynden, Catelyn, Edmure, Hoster, Lothar, Rickard, Robb, Roose, Walder, Jeyne, Roslin, Ramsay] 4 [Bran, Hodor, Jojen, Luwin, Meera, Rickon, Nan, Theon] 5 [Belwas, Daario, Daenerys, Irri, Jorah, Missandei, Rhaegar, Viserys, Barristan, Illyrio, Drogo, Aegon, Kraznys, Rakharo, Worm] 6 [Davos, Melisandre, Shireen, Stannis, Cressen, Salladhor] 7 [Lancel] 角色“大合影” 《权力的游戏》的权力图。节点的大小正比于介数中心性，颜色表示社区（由随机游走算法获得），边的厚度正比于两节点接触的次数。现在已经计算好这些图的分析数据，让我们对其进行可视化，让数据看起来更有意义。 Neo4j自带浏览器可以对Cypher查询的结果进行很好的可视化，但如果我们想把可视化好的图嵌入到其它应用中，可以使用Javascript可视化库Vis.js。从Neo4j拉取数据，用Vis.js的neovis.js构建可视化图。Neovis.js提供简单的API配置，例如： var config = &#123; container_id: \"viz\", server_url: \"localhost\", labels: &#123; \"Character\": \"name\" &#125;, label_size: &#123; \"Character\": \"betweenness\" &#125;, relationships: &#123; \"INTERACTS\": null &#125;, relationship_thickness: &#123; \"INTERACTS\": \"weight\" &#125;, cluster_labels: &#123; \"Character\": \"community\" &#125;&#125;;var viz = new NeoVis(config);viz.render(); 其中： 节点带有标签Character，属性name； 节点的大小正比于betweenness属性； 可视化中包括INTERACTS关系； 关系的厚度正比于weight属性； 节点的颜色是根据网络中社区community属性决定； 从本地服务器localhost拉取Neo4j的数据； 在一个id为viz的DOM元素中展示可视化。 Resources A. Beveridge and J. Shan, “Network of Thrones” Math Horizons Magazine , Vol. 23, No. 4 (2016), pp. 18-22. J. Kleinberg and D. Easley, Networks, Crowds, and Markets: Reasoning About a Highly Connected World. Cambridge University Press (2010)All code is available on Github. 【参考资料】 Analyzing the Graph of Thrones – by William Lyon 基于社区发现算法和图分析Neo4j解读《权力的游戏》上篇 基于社区发现算法和图分析Neo4j解读《权力的游戏》下篇","categories":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://github.com/tags/Neo4j/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}]},{"title":"【D3.js】力导向布局 + 圆形图片展示的人物关系","slug":"【D3.js】力导向布局 + 圆形图片展示的人物关系","date":"2016-11-18T08:06:00.000Z","updated":"2016-11-18T08:28:03.413Z","comments":true,"path":"2016/11/18/【D3.js】力导向布局 + 圆形图片展示的人物关系/","link":"","permalink":"http://github.com/2016/11/18/【D3.js】力导向布局 + 圆形图片展示的人物关系/","excerpt":"前言使用d3的力学图（力导向图）与生活中常见的人物关系图结合，已经有了很好的例子： 【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图，博主实现了下面这种样式，已经相当不错了。 但是对于想把节点的方形图片换成圆形头像，网上的资料却很少，本例子就在上面的实例的基础上实现圆形头像，让人物关系图看起来更漂亮了一个档次。两个主要文件如下：","text":"前言使用d3的力学图（力导向图）与生活中常见的人物关系图结合，已经有了很好的例子： 【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图，博主实现了下面这种样式，已经相当不错了。 但是对于想把节点的方形图片换成圆形头像，网上的资料却很少，本例子就在上面的实例的基础上实现圆形头像，让人物关系图看起来更漂亮了一个档次。两个主要文件如下： # index.html&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Force&lt;/title&gt; &lt;style&gt;.nodetext &#123; font-size: 12px ; font-family: SimSun; fill:#000000;&#125;.linetext &#123; font-size: 12px ; font-family: SimSun; fill:#1f77b4; fill-opacity:0.0;&#125;.circleImg &#123; stroke: #ff7f0e; stroke-width: 1.5px;&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; var width = 900; var height = 800; var img_w = 77; var img_h = 80; var radius = 30; //圆形半径 var svg = d3.select(\"body\").append(\"svg\") .attr(\"width\",width) .attr(\"height\",height); d3.json(\"relation.json\",function(error,root)&#123; if( error )&#123; return console.log(error); &#125; console.log(root); //D3力导向布局 var force = d3.layout.force() .nodes(root.nodes) .links(root.edges) .size([width,height]) .linkDistance(200) .charge(-1500) .start(); //边 var edges_line = svg.selectAll(\"line\") .data(root.edges) .enter() .append(\"line\") .style(\"stroke\",\"#ccc\") .style(\"stroke-width\",1); //边上的文字（人物之间的关系） var edges_text = svg.selectAll(\".linetext\") .data(root.edges) .enter() .append(\"text\") .attr(\"class\",\"linetext\") .text(function(d)&#123; return d.relation; &#125;); // 圆形图片节点（人物头像） var nodes_img = svg.selectAll(\"image\") .data(root.nodes) .enter() .append(\"circle\") .attr(\"class\", \"circleImg\") .attr(\"r\", radius) .attr(\"fill\", function(d, i)&#123; //创建圆形图片 var defs = svg.append(\"defs\").attr(\"id\", \"imgdefs\") var catpattern = defs.append(\"pattern\") .attr(\"id\", \"catpattern\" + i) .attr(\"height\", 1) .attr(\"width\", 1) catpattern.append(\"image\") .attr(\"x\", - (img_w / 2 - radius)) .attr(\"y\", - (img_h / 2 - radius)) .attr(\"width\", img_w) .attr(\"height\", img_h) .attr(\"xlink:href\", d.image) return \"url(#catpattern\" + i + \")\"; &#125;) .on(\"mouseover\",function(d,i)&#123; //显示连接线上的文字 edges_text.style(\"fill-opacity\",function(edge)&#123; if( edge.source === d || edge.target === d )&#123; return 1.0; &#125; &#125;); &#125;) .on(\"mouseout\",function(d,i)&#123; //隐去连接线上的文字 edges_text.style(\"fill-opacity\",function(edge)&#123; if( edge.source === d || edge.target === d )&#123; return 0.0; &#125; &#125;); &#125;) .call(force.drag); var text_dx = -20; var text_dy = 20; var nodes_text = svg.selectAll(\".nodetext\") .data(root.nodes) .enter() .append(\"text\") .attr(\"class\",\"nodetext\") .attr(\"dx\",text_dx) .attr(\"dy\",text_dy) .text(function(d)&#123; return d.name; &#125;); force.on(\"tick\", function()&#123; //限制结点的边界 root.nodes.forEach(function(d,i)&#123; d.x = d.x - img_w/2 &lt; 0 ? img_w/2 : d.x ; d.x = d.x + img_w/2 &gt; width ? width - img_w/2 : d.x ; d.y = d.y - img_h/2 &lt; 0 ? img_h/2 : d.y ; d.y = d.y + img_h/2 + text_dy &gt; height ? height - img_h/2 - text_dy : d.y ; &#125;); //更新连接线的位置 edges_line.attr(\"x1\",function(d)&#123; return d.source.x; &#125;); edges_line.attr(\"y1\",function(d)&#123; return d.source.y; &#125;); edges_line.attr(\"x2\",function(d)&#123; return d.target.x; &#125;); edges_line.attr(\"y2\",function(d)&#123; return d.target.y; &#125;); //更新连接线上文字的位置 edges_text.attr(\"x\",function(d)&#123; return (d.source.x + d.target.x) / 2 ; &#125;); edges_text.attr(\"y\",function(d)&#123; return (d.source.y + d.target.y) / 2 ; &#125;); //更新结点图片和文字 nodes_img.attr(\"cx\",function(d)&#123; return d.x &#125;); nodes_img.attr(\"cy\",function(d)&#123; return d.y &#125;); nodes_text.attr(\"x\",function(d)&#123; return d.x &#125;); nodes_text.attr(\"y\",function(d)&#123; return d.y + img_w/2; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; # relation.json&#123;\"nodes\":[&#123; \"name\": \"云天河\" , \"image\" : \"tianhe.png\" &#125;,&#123; \"name\": \"韩菱纱\" , \"image\" : \"lingsha.png\" &#125;,&#123; \"name\": \"柳梦璃\" , \"image\" : \"mengli.png\" &#125;,&#123; \"name\": \"慕容紫英\" , \"image\" : \"ziying.png\" &#125;,&#123; \"name\": \"云天青\" , \"image\" : \"tianqing.png\" &#125;,&#123; \"name\": \"夙玉\" , \"image\" : \"suyu.png\" &#125;,&#123; \"name\": \"玄霄\" , \"image\" : \"xuanxiao.png\" &#125;,&#123; \"name\": \"夙瑶\" , \"image\" : \"suyao.png\" &#125;,&#123; \"name\": \"太清\" , \"image\" : \"taiqing.png\" &#125;,&#123; \"name\": \"宗炼\" , \"image\" : \"zonglian.png\" &#125;,&#123; \"name\": \"婵幽\" , \"image\" : \"chanyou.png\" &#125;,&#123; \"name\": \"奚仲\" , \"image\" : \"xizhong.png\" &#125;,&#123; \"name\": \"归邪\" , \"image\" : \"guixie.png\" &#125;],\"edges\":[&#123; \"source\": 0 , \"target\": 1 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 0 , \"target\": 2 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 0 , \"target\": 3 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 1 , \"target\": 2 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 1 , \"target\": 3 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 2 , \"target\": 3 , \"relation\":\"挚友\" &#125;,&#123; \"source\": 0 , \"target\": 4 , \"relation\":\"父子\" &#125;,&#123; \"source\": 0 , \"target\": 5 , \"relation\":\"母子\" &#125;,&#123; \"source\": 4 , \"target\": 5 , \"relation\":\"夫妻\" &#125;,&#123; \"source\": 0 , \"target\": 6 , \"relation\":\"义兄弟\" &#125;,&#123; \"source\": 4 , \"target\": 6 , \"relation\":\"同门\" &#125;,&#123; \"source\": 5 , \"target\": 6 , \"relation\":\"同门\" &#125;,&#123; \"source\": 4 , \"target\": 7 , \"relation\":\"同门\" &#125;,&#123; \"source\": 5 , \"target\": 7 , \"relation\":\"同门\" &#125;,&#123; \"source\": 6 , \"target\": 7 , \"relation\":\"同门\" &#125;,&#123; \"source\": 4 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 5 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 6 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 7 , \"target\": 8 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 8 , \"target\": 9 , \"relation\":\"同门\" &#125;,&#123; \"source\": 3 , \"target\": 9 , \"relation\":\"师徒\" &#125;,&#123; \"source\": 2 , \"target\": 10 , \"relation\":\"母子\" &#125;,&#123; \"source\": 10 , \"target\": 11 , \"relation\":\"主臣\" &#125;,&#123; \"source\": 10 , \"target\": 12 , \"relation\":\"主臣\" &#125;,&#123; \"source\": 11 , \"target\": 12 , \"relation\":\"同僚\" &#125;]&#125; 【参考资料】 【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图 how to make an image round in d3.js 用D3画简单的力导图","categories":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://github.com/tags/D3/"}],"keywords":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}]},{"title":"【Android】微信热修复 Tinker 的集成和使用","slug":"【Android】微信热修复 Tinker 的集成和使用","date":"2016-11-17T03:51:55.000Z","updated":"2016-12-22T06:52:41.389Z","comments":true,"path":"2016/11/17/【Android】微信热修复 Tinker 的集成和使用/","link":"","permalink":"http://github.com/2016/11/17/【Android】微信热修复 Tinker 的集成和使用/","excerpt":"简介 Tinker： n. 〈英〉小炉匠，补锅匠，修补匠 Tinker 是微信官方开源的 Android 热修复框架，支持在无需升级APK的前提下更新 dex, library and resources 文件。它也就是今年9月24才刚刚开源，几天功夫star数就超过3000，可见在开发者中的影响力有多大，也说明这是一个刚需。 Tinker GitHub: https://github.com/Tencent/tinker 使用步骤一个小坑很多人遇到的第一个错误就是提示 tinkerId is not set ，这个在tinker-sample-android的app/build.gradle 中默认设置为Git的提交版本号，如下 def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : gitSha()&#125; 如果不是通过git clone方式下载的就可能出现这个错误，其实可以简单粗暴的方式解决，那就是在app/build.gradle中把tinker id写死： def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : \"tinker_id_2333\"&#125; 下面介绍一下如何一步步的把Tinker集成到自己的项目中，以及会遇到哪些问题该如何解决。","text":"简介 Tinker： n. 〈英〉小炉匠，补锅匠，修补匠 Tinker 是微信官方开源的 Android 热修复框架，支持在无需升级APK的前提下更新 dex, library and resources 文件。它也就是今年9月24才刚刚开源，几天功夫star数就超过3000，可见在开发者中的影响力有多大，也说明这是一个刚需。 Tinker GitHub: https://github.com/Tencent/tinker 使用步骤一个小坑很多人遇到的第一个错误就是提示 tinkerId is not set ，这个在tinker-sample-android的app/build.gradle 中默认设置为Git的提交版本号，如下 def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : gitSha()&#125; 如果不是通过git clone方式下载的就可能出现这个错误，其实可以简单粗暴的方式解决，那就是在app/build.gradle中把tinker id写死： def getTinkerIdValue() &#123; return hasProperty(\"TINKER_ID\") ? TINKER_ID : \"tinker_id_2333\"&#125; 下面介绍一下如何一步步的把Tinker集成到自己的项目中，以及会遇到哪些问题该如何解决。 一、工程根目录的build.gradle中添加依赖在项目的build.gradle中，添加tinker-patch-gradle-plugin的依赖 buildscript &#123; dependencies &#123; classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.3') &#125;&#125; 此时如果gradle Sync不成功可能是因为没有加入 jcenter仓库 buildscript &#123; repositories &#123; mavenLocal() jcenter() //注意这里，因为maven仓库里没有 &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.2' classpath \"com.tencent.tinker:tinker-patch-gradle-plugin:$&#123;TINKER_VERSION&#125;\" &#125; // default values for all sub projects&#125; 二、在app/build.gradle中的dependencies节点添加依赖dependencies &#123; //可选，用于生成application类 provided('com.tencent.tinker:tinker-android-anno:1.7.3') //tinker的核心库 compile('com.tencent.tinker:tinker-android-lib:1.7.3') &#125; 三、复制官方sample工程app/build.gradle中的其他相关配置把官方 tinker-sample-android 工程中的app/build.gradle复制到自己的app/build.gradle中，特别是最下面的task 代码块，否则无法生成patch。 四、替换自己的Application类这一块需要特殊说明一下，tinker为了达到修改应用自己的Application的目的，使用代码框架封装继承DefaultApplicationLike的方式来实现对Application的修改，主要为了减少反射的使用和提高兼容性，具体说明参考 Tinker Wiki：自定义Application类。 在替换更改之前，强烈建议先把项目中的Application类做个备份。因为需要采用Annotation自动生成Application，原来的Application类需要删掉。 然后我们修改项目的 Application ，使之继承DefaultApplicationLike; 这块的确有点奇葩,这个DefaultApplicationLike不是继承自Application，需要用注解来设置项目中真正的Application，Tinker插件会自动生成真正的Application。 @DefaultLifeCycle(application = \"com.cuc.android.aps.MyApplication\",//通过注解，由tinker自动生成MyApplication flags = ShareConstants.TINKER_ENABLE_ALL, //tinkerFlags loaderClass = \"com.tencent.tinker.loader.TinkerLoader\", //loaderClassName, 我们这里使用默认 loadVerifyFlag = false) public class ApplicationFromTinkerLike extends DefaultApplicationLike &#123; public ApplicationFromTinkerLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager); &#125;&#125; 上边的com.cuc.android.aps.MyApplication就是真正的Application,不用我们自己写,是自动生成的。然后修改manifest.xml将application指向com.cuc.android.aps.MyApplication就行，开始会报错，build一下项目就好了。 五、在刚改好的 ApplicationFromTinkerLike 中重载onBaseContextAttached方法并在该方法中增加以下代码调用初始化tinker @Overridepublic void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); //you must install multiDex whatever tinker is installed! MultiDex.install(base); TinkerInstaller.install(this);&#125; 或者，我们可以直接将Sample工程中的文件（特别是Utils包下的）拷贝到我们自己的工程中，就像我一样，方便后期使用。比如SampleResultService、TinkerManager这几个类 然后重载onBaseContextAttached方法，可以像我一样写成下面这样 @Overridepublic void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); //you must install multiDex whatever tinker is installed! MultiDex.install(base); MyApplicationContext.application = (MyApplication) getApplication(); MyApplicationContext.context = getApplication(); TinkerManager.setTinkerApplicationLike(this); TinkerManager.initFastCrashProtect(); //should set before tinker is installed TinkerManager.setUpgradeRetryEnable(true); //optional set logIml, or you can use default debug log TinkerInstaller.setLogIml(new MyLogImp()); //installTinker after load multiDex //or you can put com.tencent.tinker.** to main dex TinkerManager.installTinker(this);&#125; 至此，自定义Application，也就是将Application中的实现移动到SampleApplicationLike中已经完成。 六、可以开始写测试patch的代码啦使用下面代码来load patch TinkerInstaller.onReceiveUpgradePatch(this.getApplication(), Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\"); 在自己的工程中增加两个按钮，其中一个按钮用来显示EditText中的内容，另一个按钮用来加载补丁，在加载补丁按钮点击事件中执行加载patch的操作，为后期修复代码bug做准备，代码为：Button toastInfo = (Button) top.findViewById(R.id.toastInfo);toastInfo.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //清除补丁 Toast.makeText(SysUtils.getApp(),\"clean patch!\",Toast.LENGTH_LONG).show(); Tinker.with(SysUtils.getApp()).cleanPatch(); &#125;&#125;);Button loadPatchButton = (Button) top.findViewById(R.id.loadPatch);loadPatchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //加载补丁（加载成功以后patch文件会自动删掉） TinkerInstaller.onReceiveUpgradePatch(SysUtils.getApp(), Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\"); &#125;&#125;); 打patch包的步骤1、调用assembleDebug编译原始包AndroidStudio 命令行下运行 $ ./gradlew assembleDebug 编译过的包会保存在build/bakApk中。然后我们将它安装到手机，可以看到补丁并没有加载。 2、修改代码，添加新功能或者更改功能例如在MainActivity中添加一个I am on patch onCreate的Toast. 3、然后修改build.gradle中的参数将步骤一编译保存的安装包路径拷贝到tinkerPatch中的tinkerOldApkPath参数中，根据需要也得同时修改tinkerApplyResourcePath ，tinkerApplyMappingPath 。 /** * you can use assembleRelease to build you base apk * use tinkerPatchRelease -POLD_APK= -PAPPLY_MAPPING= -PAPPLY_RESOURCE= to build patch * add apk from the build/bakApk */ext &#123; //for some reason, you may want to ignore tinkerBuild, such as instant run debug build? tinkerEnabled = true //for normal build //old apk file to build patch apk tinkerOldApkPath = \"$&#123;bakPath&#125;/app-debug-1116-15-53-17.apk\" //proguard mapping file to build patch apk tinkerApplyMappingPath = \"$&#123;bakPath&#125;/app-debug-1116-15-53-17-mapping.txt\" //resource R.txt to build patch apk, must input if there is resource changed tinkerApplyResourcePath = \"$&#123;bakPath&#125;/app-debug-1116-15-53-17-R.txt\" //only use for build all flavor, if not, just ignore this field tinkerBuildFlavorDirectory = \"$&#123;bakPath&#125;/app-debug-1107-10-33-32\"&#125; 4、调用tinkerPatchDebug, 生成补丁包$ ./gradlew tinkerPatchDebug 补丁包与相关日志会保存在/build/outputs/tinkerPatch/中，我们将其中的patch_signed_7zip.apk推送到手机的sdcard中。 $ adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /storage/sdcard0/ 5、运行app，执行LOAD PATCH代码块如果看到patch success, please restart process的toast，即可锁屏或者KILL 应用进程。 6、重新启动App我们可以看到，补丁包的确已经加载成功了。 使用Tinker的注意事项 1、Tinker_id的大版本升级问题 2、如果生成patch失败，并且原因如下： Warning: ignoreWarning is false, but we found loader classes are found in old secondary dex. 那么需要把相应的报错类声明在项目的keep_in_main_dex.txt 文件中，保证它编译时会被放置到主dex中。参考Tinker Issue #96 。 【参考资料】 Tinker 官方接入指南 微信Android热补丁实践演进之路 微信Tinker的一切都在这里，包括源码(一) 【腾讯Bugly干货分享】微信热补丁Tinker的实践演进之路 将Tinke集成到自己的项目 Android 微信热修复Tinker接入过程以及使用方法 Tinker 逆向分析","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"hotfix","slug":"hotfix","permalink":"http://github.com/tags/hotfix/"},{"name":"Tinker","slug":"Tinker","permalink":"http://github.com/tags/Tinker/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【D3】Link Nodes by Name","slug":"【D3】Link Nodes by Name","date":"2016-11-16T08:08:00.000Z","updated":"2016-11-18T08:27:59.326Z","comments":true,"path":"2016/11/16/【D3】Link Nodes by Name/","link":"","permalink":"http://github.com/2016/11/16/【D3】Link Nodes by Name/","excerpt":"Source : http://bl.ocks.org/mbostock/533daf20348023dfdd76 This example shows how to link nodes in a force-directed graph using a named identifier rather than a numeric index.","text":"Source : http://bl.ocks.org/mbostock/533daf20348023dfdd76 This example shows how to link nodes in a force-directed graph using a named identifier rather than a numeric index. # index.html&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;style&gt;.node &#123; stroke: #000; stroke-width: 1.5px;&#125;.link &#123; stroke: #999; stroke-width: 1.5px;&#125;&lt;/style&gt;&lt;svg width=\"960\" height=\"500\"&gt;&lt;/svg&gt;&lt;script src=\"//d3js.org/d3.v4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var svg = d3.select(\"svg\"), width = +svg.attr(\"width\"), height = +svg.attr(\"height\");var simulation = d3.forceSimulation() .force(\"charge\", d3.forceManyBody().strength(-200)) .force(\"link\", d3.forceLink().id(function(d) &#123; return d.id; &#125;).distance(40)) .force(\"x\", d3.forceX(width / 2)) .force(\"y\", d3.forceY(height / 2)) .on(\"tick\", ticked);var link = svg.selectAll(\".link\"), node = svg.selectAll(\".node\");d3.json(\"graph.json\", function(error, graph) &#123; if (error) throw error; simulation.nodes(graph.nodes); simulation.force(\"link\").links(graph.links); link = link .data(graph.links) .enter().append(\"line\") .attr(\"class\", \"link\"); node = node .data(graph.nodes) .enter().append(\"circle\") .attr(\"class\", \"node\") .attr(\"r\", 6) .style(\"fill\", function(d) &#123; return d.id; &#125;);&#125;);function ticked() &#123; link.attr(\"x1\", function(d) &#123; return d.source.x; &#125;) .attr(\"y1\", function(d) &#123; return d.source.y; &#125;) .attr(\"x2\", function(d) &#123; return d.target.x; &#125;) .attr(\"y2\", function(d) &#123; return d.target.y; &#125;); node.attr(\"cx\", function(d) &#123; return d.x; &#125;) .attr(\"cy\", function(d) &#123; return d.y; &#125;);&#125;&lt;/script&gt; # graph.json&#123; \"nodes\": [ &#123;\"id\": \"red\"&#125;, &#123;\"id\": \"orange\"&#125;, &#123;\"id\": \"yellow\"&#125;, &#123;\"id\": \"green\"&#125;, &#123;\"id\": \"blue\"&#125;, &#123;\"id\": \"violet\"&#125; ], \"links\": [ &#123;\"source\": \"red\", \"target\": \"yellow\"&#125;, &#123;\"source\": \"red\", \"target\": \"blue\"&#125;, &#123;\"source\": \"red\", \"target\": \"green\"&#125; ]&#125;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://github.com/tags/D3/"}],"keywords":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}]},{"title":"Android 热修复原理和实现","slug":"Android 热修复原理和实现","date":"2016-11-10T05:06:00.000Z","updated":"2016-12-22T05:02:25.162Z","comments":true,"path":"2016/11/10/Android 热修复原理和实现/","link":"","permalink":"http://github.com/2016/11/10/Android 热修复原理和实现/","excerpt":"查看原文： Android 热修复，没你想的那么难 —— by kymjs张涛 一种动态加载最简单的实现方式，代码实现起来非常简单，重要的是这种思路和原理 。 《插件化从放弃到捡起》第一章，首先看一张图： 这张图是我所理解的 Android 插件化技术的三个技术点以及它们的应用场景。今天以 【Qzone 热修复方案】为例，跟大家讲一讲插件化中 热修复方案 的实现。 原理ClassLoader在 Java 中，要加载一个类需要用到ClassLoader。Android 中有三个 ClassLoader, 分别为URLClassLoader、PathClassLoader、DexClassLoader。其中: URLClassLoader : 只能用于加载jar文件，但是由于 dalvik 不能直接识别jar，所以在 Android 中无法使用这个加载器。 PathClassLoader :它只能加载已经安装的apk。因为 PathClassLoader 只会去读取 /data/dalvik-cache 目录下的 dex 文件。例如我们安装一个包名为com.hujiang.xxx的 apk,那么当 apk 安装过程中，就会在/data/dalvik-cache目录下生产一个名为data@app@com.hujiang.xxx-1.apk@classes.dex的 ODEX 文件。在使用 PathClassLoader 加载 apk 时，它就会去这个文件夹中找相应的 ODEX 文件，如果 apk 没有安装，自然会报ClassNotFoundException。 DexClassLoader : 是最理想的加载器。它的构造函数包含四个参数，分别为： 1、dexPath, 指目标类所在的APK或jar文件的路径.类装载器将从该路径中寻找指定的目标类,该类必须是APK或jar的全路径.如果要包含多个路径,路径之间必须使用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得. 2、dexOutputDir, 由于dex文件被包含在APK或者Jar文件中,因此在装载目标类之前需要先从APK或Jar文件中解压出dex文件,该参数就是制定解压出的dex 文件存放的路径.在Android系统中,一个应用程序一般对应一个Linux用户id,应用程序仅对属于自己的数据目录路径有写的权限,因此,该参数可以使用该程序的数据路径. 3、libPath, 指目标类中所使用的C/C++库存放的路径 4、classload, 是指该装载器的父装载器,一般为当前执行类的装载器","text":"查看原文： Android 热修复，没你想的那么难 —— by kymjs张涛 一种动态加载最简单的实现方式，代码实现起来非常简单，重要的是这种思路和原理 。 《插件化从放弃到捡起》第一章，首先看一张图： 这张图是我所理解的 Android 插件化技术的三个技术点以及它们的应用场景。今天以 【Qzone 热修复方案】为例，跟大家讲一讲插件化中 热修复方案 的实现。 原理ClassLoader在 Java 中，要加载一个类需要用到ClassLoader。Android 中有三个 ClassLoader, 分别为URLClassLoader、PathClassLoader、DexClassLoader。其中: URLClassLoader : 只能用于加载jar文件，但是由于 dalvik 不能直接识别jar，所以在 Android 中无法使用这个加载器。 PathClassLoader :它只能加载已经安装的apk。因为 PathClassLoader 只会去读取 /data/dalvik-cache 目录下的 dex 文件。例如我们安装一个包名为com.hujiang.xxx的 apk,那么当 apk 安装过程中，就会在/data/dalvik-cache目录下生产一个名为data@app@com.hujiang.xxx-1.apk@classes.dex的 ODEX 文件。在使用 PathClassLoader 加载 apk 时，它就会去这个文件夹中找相应的 ODEX 文件，如果 apk 没有安装，自然会报ClassNotFoundException。 DexClassLoader : 是最理想的加载器。它的构造函数包含四个参数，分别为： 1、dexPath, 指目标类所在的APK或jar文件的路径.类装载器将从该路径中寻找指定的目标类,该类必须是APK或jar的全路径.如果要包含多个路径,路径之间必须使用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得. 2、dexOutputDir, 由于dex文件被包含在APK或者Jar文件中,因此在装载目标类之前需要先从APK或Jar文件中解压出dex文件,该参数就是制定解压出的dex 文件存放的路径.在Android系统中,一个应用程序一般对应一个Linux用户id,应用程序仅对属于自己的数据目录路径有写的权限,因此,该参数可以使用该程序的数据路径. 3、libPath, 指目标类中所使用的C/C++库存放的路径 4、classload, 是指该装载器的父装载器,一般为当前执行类的装载器 从framework源码中的dalvik.system包下，找到DexClassLoader源码，并没有什么卵用，实际内容是在它的父类BaseDexClassLoader中，顺带一提，这个类最低在API14开始有用。包含了两个变量： /** originally specified path (just used for &#123;@code toString()&#125;) */private final String originalPath; /** structured lists of path elements */private final DexPathList pathList; 可以看到注释：pathList就是多dex的结构列表，查看其源码 /*package*/ final class DexPathList &#123; private static final String DEX_SUFFIX = \".dex\"; private static final String JAR_SUFFIX = \".jar\"; private static final String ZIP_SUFFIX = \".zip\"; private static final String APK_SUFFIX = \".apk\"; /** class definition context */ private final ClassLoader definingContext; /** list of dex/resource (class path) elements */ private final Element[] dexElements; /** list of native library directory elements */ private final File[] nativeLibraryDirectories; 可以看到 dexElements 注释，dexElements 就是一个dex列表，那么我们就可以把每个 Element 当成是一个 dex。 此时我们整理一下思路，DexClassLoader 包含有一个dex数组Element[] dexElements，其中每个dex文件是一个Element，当需要加载类的时候会遍历 dexElements，如果找到类则加载，如果找不到从下一个 dex 文件继续查找。 那么我们的实现就是把这个插件 dex 插入到 Elements 的最前面，这么做的好处是不仅可以动态的加载一个类，并且由于 DexClassLoader 会优先加载靠前的类，所以我们同时实现了宿主 apk 的热修复功能。 ODEX过程上文就是整个热修复的原理了，就是向Classloader列表中插入一个dex。但是如果你这儿实现了，会发现一个问题，就是 ODEX 过程中引发的问题。在讲这个蛋疼的过程之前，有几个问题是要搞懂的。为什么 Android 不能识别 .class 文件，而只能识别 dex 文件。因为 dex 是对 class 的优化，它对 class 做了极大的压缩，比如以下是一个 class 文件的结构(摘自邓凡平老师博客) dex 将整个 Android 工程中所有的 class 压缩到一个(或几个) dex 文件中，合并了每个 class 的常量、class 版本信息等，例如每个 class 中都有一个相同的字符串，在 dex 中就只存一份就够了。所以，在Android 上，dalvik 虚拟机是无法识别一个普通 class 文件的，因为无法识别这个 class 文件的结构。 以下是一个 dex 文件的结构 : 感兴趣的可以阅读《深入理解Android》这本书。 继续往下，其实 dalvik 虚拟机也并不是直接读取 dex 文件的，而是在一个 APK 安装的时候，会首先做一次优化，会生成一个 ODEX 文件，即 Optimized dex。 为什么还要优化，依旧是为了效率。 只不过，Class -&gt; dex 是为了平台无关的优化；而 dex -&gt; odex 则是针对不同平台，不同手机的硬件配置做针对性的优化。就是在这一过程中，虚拟机在启动优化的时候，会有一个选项就是 verify 选项，当 verify 选项被打开的时候，就会执行一次校验，校验的目的是为了判断，这个类是否有引用其他 dex 中的类，如果没有，那么这个类会被打上一个 CLASS_ISPREVERIFIED 的标志。一旦被打上这个标志，就无法再从其他 dex 中替换这个类了。而这个选项开启，则是由虚拟机控制的。 字节码操作那么既然知道了原因，解决的办法自然也有了。你不是没有引用其他 dex 中的类就会被标记吗，那咱们就引用一个其他 dex 中的类。 ClassReader:该类用来解析编译过的class字节码文件。ClassWriter:该类用来重新构建编译后的类，比如说修改类名、属性以及方法，甚至可以生成新的类的字节码文件。ClassAdapter:该类也实现了ClassVisitor接口，它将对它的方法调用委托给另一个ClassVisitor对象。 /** * 当对象初始化的时候注入Inject类 * * @Note https://www.ibm.com/developerworks/cn/java/j-lo-asm30/ * @param inputStream 需要注入的Class的文件输入流 * @return 返回注入以后的Class文件二进制数组 */private static byte[] referHackWhenInit(InputStream inputStream) &#123; //该类用来解析编译过的class字节码文件。 ClassReader cr = new ClassReader(inputStream); //该类用来重新构建编译后的类，比如说修改类名、属性以及方法，甚至可以生成新的类的字节码文件 ClassWriter cw = new ClassWriter(cr, 0); //类的访问者,可以用来创建对一个Class的改动操作 ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) &#123; @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions); //如果方法名是&lt;init&gt;,每个类的构造函数函数名叫&lt;init&gt; if (\"&lt;init&gt;\".equals(name)) &#123; //在原本的visitMethod操作中添加自己定义的操作 mv = new MethodVisitor(Opcodes.ASM4, mv) &#123; @Override void visitInsn(int opcode) &#123; //Opcodes可以看做为关键字 if (opcode == Opcodes.RETURN) &#123; //visitLdcInsn() 将一个值写入到栈中,可以是一个Class类名/method方法名/desc方法描述 //这里相当于插入了一条语句:Class a = Inject.class; super.visitLdcInsn(Type.getType(\"Lcom/hujiang/hotfix/Inject;\")); &#125; //执行opcode对应的其他操作 super.visitInsn(opcode); &#125; &#125; &#125; //责任链完成,返回 return mv; &#125; &#125;; //accept这个方法接受一个实现了 ClassVisitor接口的对象实例作为参数，然后依次调用 ClassVisitor接口的各个方法 //用户无法控制各个方法调用顺序,但是可以提供不同的 Visitor(访问者) 来对字节码树进行不同的修改 //在这里,调用这一步的目的是为了让上面的visitMethod方法被调用 cr.accept(cv, 0); return cw.toByteArray();&#125; 代码实现可以参考 nuwa 中的实现，首先是 dex 怎样去插入到Classloader列表中，其实就是一段反射： public static void injectDexAtFirst(String dexPath, String defaultDexOptPath) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; DexClassLoader dexClassLoader = new DexClassLoader(dexPath, defaultDexOptPath, dexPath, getPathClassLoader()); Object baseDexElements = getDexElements(getPathList(getPathClassLoader())); Object newDexElements = getDexElements(getPathList(dexClassLoader)); Object allDexElements = combineArray(newDexElements, baseDexElements); Object pathList = getPathList(getPathClassLoader()); ReflectionUtils.setField(pathList, pathList.getClass(), \"dexElements\", allDexElements);&#125; 首先分别获取到宿主应用和补丁的 dex 中的PathList.dexElements, 并把两个 dexElements 数组做拼接，将补丁数组放在前面，最后将拼接后生成的数组再赋值回Classloader. nuwa 更主要的是他的 groovy 脚本，完整代码：这里，由于代码很多，就只跟大家讲两个关键的点的实现以及目的，具体的内容可以直接查看源码。 //获得所有输入文件,即preDex的所有jar文件Set&lt;File&gt; inputFiles = preDexTask.inputs.files.filesinputFiles.each &#123; inputFile -&gt; def path = inputFile.absolutePath //如果不是support包或者引入的依赖库,则开始生成代码修改部分的hotfix包 if (HotFixProcessors.shouldProcessPreDexJar(path)) &#123; HotFixProcessors.processJar(classHashFile, inputFile, patchDir, classHashMap, includePackage, excludeClass) &#125;&#125; 其中HotFixProcessors.processJar()是脚本的第一个作用，就是找出哪些类是发生了改变，应该生成对应的补丁。循环遍历工程中的全部类,声明忽略的直接跳过.对每个类计算hash,并写入到hashFile文件中.通过比较hashFile文件与原先host工程的hashFile(即这里的classHashMap参数),得到所有修改过的类生成这些类的class文件,以及所有修改过的class文件的集合jar文件。 Set&lt;File&gt; inputFiles = dexTask.inputs.files.filesinputFiles.each &#123; inputFile -&gt; def path = inputFile.absolutePath if (path.endsWith(\".class\") &amp;&amp; !path.contains(\"/R\\$\") &amp;&amp; !path.endsWith(\"/R.class\") &amp;&amp; !path.endsWith(\"/BuildConfig.class\")) &#123; if (HotFixSetUtils.isIncluded(path, includePackage)) &#123; if (!HotFixSetUtils.isExcluded(path, excludeClass)) &#123; def bytes = HotFixProcessors.processClass(inputFile) path = path.split(\"$&#123;dirName&#125;/\")[1] def hash = DigestUtils.shaHex(bytes) classHashFile.append(HotFixMapUtils.format(path, hash)) if (HotFixMapUtils.notSame(classHashMap, path, hash)) &#123; HotFixFileUtils.copyBytesToFile(inputFile.bytes, HotFixFileUtils.touchFile(patchDir, path)) &#125; &#125; &#125; &#125;&#125; 这一段是脚本的第二个作用，也就是上文字节码操作的目的，为了防止类被虚拟机打上CLASS_ISPREVERIFIED，所以需要执行字节码写入。其中HotFixProcessors.processClass()就是实际写入字节码的代码。 好像差个结尾同样的方案，除了 nuwa 还有一个开源的实现，HotFix 两者是差不多的，所以看一个就可以了。 看到有很多朋友问，如果混淆后代码怎么办？在 Gradle 插件编译过程中，有一个proguardTask，看名字应该就知道他是负责 proguard 任务的，我们可以保存首次执行时的混淆规则(也就是线上出BUG的包)，这个混淆规则保存在工程目录中的一个mapping文件，当我们需要执行热修复补丁生成的时候，将线上包的mapping规则拿出来应用到本次编译中，就可以生成混淆后的类跟线上混淆后的类相同的类名的补丁了。具体实现可以看 nuwa 项目的applymapping()方法。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"hotfix","slug":"hotfix","permalink":"http://github.com/tags/hotfix/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"使用Neo4j进行全栈Web开发","slug":"使用Neo4j进行全栈Web开发","date":"2016-11-10T03:08:00.000Z","updated":"2016-11-21T03:00:54.662Z","comments":true,"path":"2016/11/10/使用Neo4j进行全栈Web开发/","link":"","permalink":"http://github.com/2016/11/10/使用Neo4j进行全栈Web开发/","excerpt":"在开发一个全栈web应用时，作为整个栈的底层，你可以在多种数据库之间进行选择。作为事实的数据源，你当然希望选择一种可靠的数据库，但同时也希望它能够允许你以良好的方式进行数据建模。在本文中，我将为你介绍Neo4j，当你的数据模型包含大量关联数据以及关系时，它可以成为你的web应用栈的基础的一个良好选择。 Neo4j是什么？ Neo4j是一个图形数据库，这也就意味着它的数据并非保存在表或集合中，而是保存为节点以及节点之间的关系。在Neo4j中，节点以及关系都能够包含保存值的属性，此外： 可以为节点设置零或多个标签（例如Author或Book） 每个关系都对应一种类型（例如WROTE或FRIEND_OF） 关系总是从一个节点指向另一个节点（但可以在不考虑指向性的情况下进行查询）","text":"在开发一个全栈web应用时，作为整个栈的底层，你可以在多种数据库之间进行选择。作为事实的数据源，你当然希望选择一种可靠的数据库，但同时也希望它能够允许你以良好的方式进行数据建模。在本文中，我将为你介绍Neo4j，当你的数据模型包含大量关联数据以及关系时，它可以成为你的web应用栈的基础的一个良好选择。 Neo4j是什么？ Neo4j是一个图形数据库，这也就意味着它的数据并非保存在表或集合中，而是保存为节点以及节点之间的关系。在Neo4j中，节点以及关系都能够包含保存值的属性，此外： 可以为节点设置零或多个标签（例如Author或Book） 每个关系都对应一种类型（例如WROTE或FRIEND_OF） 关系总是从一个节点指向另一个节点（但可以在不考虑指向性的情况下进行查询） 为什么要选择Neo4j？在考虑为web应用选择某个数据库时，我们需要考虑对它有哪些方面的期望，其中最重要的一些条件包括： 它是否易于使用？ 它是否允许你方便地回应对需求的变更？ 它是否支持高性能查询？ 是否能够方便地对其进行数据建模？ 它是否支持事务？ 它是否支持大规模应用？ 它是否足够有趣（很遗憾的是对于数据库的这方面要求经常被忽略）？ 从这几个方面来说，Neo4j是一个合适的选择。Neo4j…… 自带一套易于学习的查询语言（名为 Cypher） 不使用schema，因此可以满足你的任何形式的需求 与关系型数据库相比，对于高度关联的数据（图形数据）的查询快速要快上许多 它的实体与关系结构非常自然地切合人类的直观感受 支持兼容ACID的事务操作 提供了一个高可用性模型，以支持大规模数据量的查询，支持备份、数据局部性以及冗余 提供了一个可视化的查询控制台，你不会对它感到厌倦的 什么时候不应使用Neo4j？作为一个图形NoSQL数据库，Neo4j提供了大量的功能，但没有什么解决方案是完美的。在以下这些用例中，Neo4j就不是非常适合的选择： 记录大量基于事件的数据（例如日志条目或传感器数据） 对大规模分布式数据进行处理，类似于Hadoop 二进制数据存储 适合于保存在关系型数据库中的结构化数据 在上面的示例中，你看到了由Author、City、Book和Category以及它们之间的关系所组成的一个图形。如果你希望通过Cypher语句在Neo4j web控制台中列出这些数据结果，可以执行以下语句： MATCH (city:City)&lt;-[:LIVES_IN]-(:Author)-[:WROTE]-&gt; (book:Book)-[:HAS_CATEGORY]-&gt;(category:Category) WHERE city.name = “Chicago” RETURN * 请注意这种ASCII风格的语法，它在括号内表示节点名称，并用箭头表示一个节点指向另一个节点的关系。Cypher通过这种方式允许你匹配某个指定的子图形模式。 当然，Neo4j的功能不仅仅在于展示漂亮的图片。如果你希望按照作者所处的地点（城市）计算书籍的分类数目，你可以通过使用相同的MATCH模式，返回一组不同的列，例如： MATCH (city:City)&lt;-[:LIVES_IN]-(:Author)-[:WROTE]-&gt; (book:Book)-[:HAS_CATEGORY]-&gt;(category:Category) RETURN city.name, category.name, COUNT(book) 执行这条语句将返回以下结果： city.name category.name COUNT(category) Chicago Fantasy 1 Chicago Non-Fiction 2 虽然Neo4j也能够处理“大数据”，但它毕竟不是Hadoop、HBase或Cassandra，通常来说不会在Neo4j数据库中直接处理海量数据（以PB为单位）的分析。但如果你乐于提供关于某个实体及其相邻数据关系（比如你可以提供一个web页面或某个API返回其结果），那么它是一种良好的选择。无论是简单的CRUD访问，或是复杂的、深度嵌套的资源视图都能够胜任。 你应该选择哪种技术栈以配合Neo4j？所有主流的编程语言都通过HTTP API的方式支持Neo4j，或者采用基本的HTTP类库，或是通过某些原生的类库提供更高层的抽象。此外，由于Neo4j是以Java语言编写的，因此所有包含JVM接口的语言都能够充分利用Neo4j中的高性能API。 Neo4j本身也提供了一个“技术栈”，它允许你选择不同的访问方式，包括简单访问乃至原生性能等等。它提供的特性包括： 通过一个HTTP API执行Cypher查询，并获取JSON格式的结果 一种“非托管扩展”机制，允许你为Neo4j数据库编写自己的终结点 通过一个高层Java API指定节点与关系的遍历 通过一个低层的批量加载API处理海量初始数据的获取 通过一个核心Java API直接访问节点与关系，以获得最大的性能 一个应用程序示例最近我正好有机会将一个项目扩展为基于Neo4j的应用程序。该应用程序（可以访问graphgist.neo4j.com查看）是关于GraphGist的一个门户网站。GraphGist是一种通过交互式地渲染（在你的浏览器中）生成的文档，它基于一个简单的文本文件（AsciiDoctor），其中用文字描述以及图片描述了整个数据模型、架构以及用例查询，可以在线执行它们，并使它们保持可视化。它非常类似一个iPython notebook或是一张交互式的白纸。GraphGist也允许读者在浏览器中编写自己定义的查询，以查看整个数据集。 Neo4j的原作者Neo Technology希望为GraphGist提供一个由社区创建的展示项目。当然，后端技术选用了Neo4j，而整个技术栈的其余部分，我的选择是： Node.js配合Express.js，其中引入了neo4j包 Angular.js Swagger UI 所有代码都已开源，可以在GitHub上任意浏览。 从概念上讲，GraphGist门户网站是一个简单的应用，它提供了一个GraphGist列表，允许用户查看每个GraphGist的详细内容。数据领域是由Gist、Keyword/Domain/Use Case（作为Gist分类）以及Person（作为Gist的作者）所组成的： 现在你已经熟悉这个模型了，在继续深入学习之前，我想为你快速地介绍一下Cypher这门查询语言。举例来说，如果我们需要返回所有的Gist和它们的关键字，可以通过以下语句实现： MATCH (gist:Gist)-[:HAS_KEYWORD]-&gt;(keyword:Keyword)RETURN gist.title, keyword.name 这段语句将返回一张表，其中的每一行是由每个Gist和Keyword的组合构成的，正如同SQL join的行为一样。现在我们更深入一步，假设我们想要找到某个人所编写的Gist对应的所有Domain，我们可以执行下面这条查询语句： MATCH (person:Person)-[:WRITER_OF]-&gt;(gist:Gist)-[:HAS_DOMAIN]-&gt;(domain:Domain)WHERE person.name = “John Doe”RETURN domain.name, COUNT(gist) 该语句将返回另一个结果表，其中的每一行包含Domain的名称，以及这个Person对于这一Domain所编写的全部Gist的数量。这里无需使用GROUP BY语句，因为当我们使用例如COUNT()这样的聚合函数时，Neo4j会自动在RETURN语句中对其它列进行分组操作。 现在你对Cypher已经有一点感觉了吧？那么让我们来看一个来自实际应用中的查询。在创建这个门户时，如果能够通过某种方式，只需对数据库进行一次请求就能够返回我们所需的所有数据，并且以一种我们需要的格式进行结构组织，那将十分有用。 让我们开始创建这个用于门户的API（可以在GitHub上找到）的查询吧。首先，我们需要按照Gist的title属性进行匹配，并匹配所有相关的Gist节点： // Match Gists based on title MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; // Optionally match Gists with the same keyword // and pass on these related Gists with the // most common keywords first OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) 这里有几个要注意的地方。首先，WHERE语句是通过一个正则表达式（即=~操作符）和一个参数对title属性进行匹配的。参数（Parameter）是Neo4j的一项特性，它能够将查询与其所代表的数据进行分离。使用参数能够让Neo4j对查询和查询计划进行缓存，这也意味着你无需担心遭遇查询注入攻击。其次，我们在这里使用了一个OPTIONAL MATCH语句，它表示我们希望始终返回原始的Gist，即使它并没有相关的Gist。 现在让我们对之前的查询进行扩展，将RETURN语句替换为WITH语句： MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) WITH gist, related_gist, COUNT(DISTINCT keyword.name) AS keyword_count ORDER BY keyword_count DESC RETURN gist, COLLECT(DISTINCT &#123;related: &#123; id: related_gist.id, title: related_gist.title, poster_image: related_gist.poster_image, url: related_gist.url &#125;, weight: keyword_count &#125;) AS related 在RETURN语句中的COLLECT()作用是将由Gist和相关Gist所组成的节点转换为一个结果集，让其中每一行Gist只出现一次，并对应一个相关Gist的节点数组。在COLLECT()语句中，我们在相关Gist中仅指定了所需的部分数据，以减小整个响应的大小。 最后，我们将产生这样一条查询语句，这也是最后一次使用WITH语句了： MATCH (gist:Gist) WHERE gist.title =~ &#123;search_query&#125; OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword)&lt;-[:HAS_KEYWORD]-(related_gist) WITH gist, related_gist, COUNT(DISTINCT keyword.name) AS keyword_count ORDER BY keyword_count DESC WITH gist, COLLECT(DISTINCT &#123;related: &#123; id: related_gist.id, title: related_gist.title, poster_image: related_gist.poster_image, url: related_gist.url &#125;, weight: keyword_count &#125;) AS related // Optionally match domains, use cases, writers, and keywords for each Gist OPTIONAL MATCH (gist)-[:HAS_DOMAIN]-&gt;(domain:Domain) OPTIONAL MATCH (gist)-[:HAS_USECASE]-&gt;(usecase:UseCase) OPTIONAL MATCH (gist)&lt;-[:WRITER_OF]-(writer:Person) OPTIONAL MATCH (gist)-[:HAS_KEYWORD]-&gt;(keyword:Keyword) // Return one Gist per row with arrays of domains, use cases, writers, and keywords RETURN gist, related, COLLECT(DISTINCT domain.name) AS domains, COLLECT(DISTINCT usecase.name) AS usecases, COLLECT(DISTINCT keyword.name) AS keywords COLLECT(DISTINCT writer.name) AS writers, ORDER BY gist.title 在这个查询中，我们将选择性地匹配所有相关的Domain、Use Case、Keyword和Person节点，并且将它们全部收集起来，与我们对相关Gist的处理方式相同。现在我们的结果不再是平坦的、反正规化的，而是包含一列Gist，其中每个Gist都对应着相关Gist的数组，形成了一种“has many”的关系，并且没有任何重复数据。太酷了！ 不仅如此，如果你觉得用表的形式返回数据太老土，那么Cypher也可以返回对象： RETURN &#123;gist: gist, domains: collect(DISTINCT domain.name) AS domains, usecases: collect(DISTINCT usecase.name) AS usecases, writers: collect(DISTINCT writer.name) AS writers, keywords: collect(DISTINCT keyword.name) AS keywords, related_gists: related &#125; ORDER BY gist.title 通常来说，在稍具规模的web应用程序中，需要进行大量的数据库调用以返回HTTP响应所需的数据。虽然你可以并行地执行查询，但通常来说你需要首先返回某个查询的结果集，才能发送另一个数据库请求以获取相关的数据。在SQL中，你可以通过生成复杂的、开销很大的表join语句，通过一个查询从多张表中返回结果。但只要你在同一个查询中进行了多次SQL join，这个查询的复杂性将会飞快地增长。更不用说数据库仍然需要进行表或索引扫描才能够获得相应的数据了。而在Neo4j中，通过关系获取实体的方式是直接使用对应于相关节点的指针，因此服务器可以随意进行遍历。 尽管如此，这种方式也存在着诸多缺陷。虽然这种方式能够通过一个查询返回所有数据，但这个查询会相当长。我至今也没有找到一种方式能够对进行模块化以便重用。进一步考虑：我们可以在其它场合同样调用这个终结点，但让它显示相关Gist的更多信息。我们可以选择修改这个查询以返回更多的数据，但也意味着对于原始的用例来说，它返回了额外的不必要数据。 我们是幸运的，因为有这么多优秀的数据库可以选择。虽然关系型数据库对于保存结构化数据来说依然是最佳的选择，但NoSQL数据库更适合于管理半结构化数据、非结构化数据以及图形数据。如果你的数据模型中包括大量的关联数据，并且希望使用一种直观的、有趣的并且快速的数据库进行开发，那么你就应当尝试一下Neo4j。 本文由Brian Underwood撰写，而Michael Hunger也为本文作出了许多贡献。 关于作者Brian Underwood是一位软件工程师，喜爱任何与数据相关的东西。作为一名Neo4j 的Developer Advocate，以及neo4j ruby gem的维护者，Brian经常通过一些演讲，以及在他的博客上的文章宣传图形数据库的强大与简洁。Brian如今正与他的妻儿在全球旅行。可以在Twitter 上找到Brian，或在LinkedIn上联系他。 查看英文原文：Full Stack Web Development Using Neo4j","categories":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://github.com/tags/Neo4j/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://github.com/categories/Web/"}]},{"title":"D3.js加载本地json文件的问题","slug":"D3.js加载本地json文件的问题","date":"2016-11-09T13:13:20.000Z","updated":"2016-12-22T05:04:49.471Z","comments":true,"path":"2016/11/09/D3.js加载本地json文件的问题/","link":"","permalink":"http://github.com/2016/11/09/D3.js加载本地json文件的问题/","excerpt":"问题打开本地html文件时，报错如下 XMLHttpRequest cannot load file:/cities.csv. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource.Uncaught NetworkError: Failed to execute &apos;send&apos; on &apos;XMLHttpRequest&apos;: Failed to load 分析原因是因为浏览器为了安全性考虑，默认对跨域访问禁止，不允许直接读取本地文件。 解决给浏览器传入启动参数（allow-file-access-from-files），允许跨域访问。Windows下，运行（CMD+R）或右键桌面快捷方式-&gt;属性-&gt;目标：","text":"问题打开本地html文件时，报错如下 XMLHttpRequest cannot load file:/cities.csv. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource.Uncaught NetworkError: Failed to execute &apos;send&apos; on &apos;XMLHttpRequest&apos;: Failed to load 分析原因是因为浏览器为了安全性考虑，默认对跨域访问禁止，不允许直接读取本地文件。 解决给浏览器传入启动参数（allow-file-access-from-files），允许跨域访问。Windows下，运行（CMD+R）或右键桌面快捷方式-&gt;属性-&gt;目标： &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; --allow-file-access-from-files","categories":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://github.com/tags/D3/"}],"keywords":[{"name":"D3.js","slug":"D3-js","permalink":"http://github.com/categories/D3-js/"}]},{"title":"【Android】Broadcast广播机制总结","slug":"【Android】Broadcast广播机制总结","date":"2016-10-25T08:06:00.000Z","updated":"2016-12-21T04:04:54.088Z","comments":true,"path":"2016/10/25/【Android】Broadcast广播机制总结/","link":"","permalink":"http://github.com/2016/10/25/【Android】Broadcast广播机制总结/","excerpt":"原文链接： Android总结篇系列：Android广播机制 1. Android广播机制概述Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播作为Android组件间的通信方式，可以使用的场景如下： 同一app内部的同一组件内的消息通信（单个或多个线程之间）； 同一app内部的不同组件之间的消息通信（单个进程）； 同一app具有多个进程的不同组件之间的消息通信； 不同app之间的组件之间消息通信； Android系统在特定情况下与App之间的消息通信。 从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：","text":"原文链接： Android总结篇系列：Android广播机制 1. Android广播机制概述Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播作为Android组件间的通信方式，可以使用的场景如下： 同一app内部的同一组件内的消息通信（单个或多个线程之间）； 同一app内部的不同组件之间的消息通信（单个进程）； 同一app具有多个进程的不同组件之间的消息通信； 不同app之间的组件之间消息通信； Android系统在特定情况下与App之间的消息通信。 从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下： 广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册； 广播发送者通过binder机制向AMS发送广播； AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中； 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。 对于不同的广播类型，以及不同的BroadcastReceiver注册方式，具体实现上会有不同。但总体流程大致如上。 由此看来，广播发送者和广播接收者分别属于观察者模式中的消息发布和订阅两端，AMS属于中间的处理中心。广播发送者和广播接收者的执行是异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到。显然，整体流程与EventBus非常类似。 在上文说列举的广播机制具体可以使用的场景中，现分析实际应用中的适用性： 第一种情形：同一app内部的同一组件内的消息通信（单个或多个线程之间），实际应用中肯定是不会用到广播机制的（虽然可以用），无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”； 第二种情形：同一app内部的不同组件之间的消息通信（单个进程），对于此类需求，在有些教复杂的情况下单纯的依靠基于接口的回调等方式不好处理，此时可以直接使用EventBus等，相对而言，EventBus由于是针对统一进程，用于处理此类需求非常适合，且轻松解耦。可以参见文件《Android各组件/控件间通信利器之EventBus》。 第三、四、五情形：由于涉及不同进程间的消息通信，此时根据实际业务使用广播机制会显得非常适宜。下面主要针对Android广播中的具体知识点进行总结。 2. BroadcastReceiver自定义BroadcastReceiver自定义广播接收器需要继承基类BroadcastReceivre，并实现抽象方法onReceive(context, intent)方法。广播接收器接收到相应广播后，会自动回到onReceive(..)方法。默认情况下，广播接收器也是运行在UI线程，因此，onReceive方法中不能执行太耗时的操作。否则将因此ANR。一般情况下，根据实际业务需求，onReceive方法中都会涉及到与其他组件之间的交互，如发送Notification、启动service等。下面代码片段是一个简单的广播接收器的自定义： public class MyBroadcastReceiver extends BroadcastReceiver &#123; public static final String TAG = \"MyBroadcastReceiver\"; public static int m = 1; @Override public void onReceive(Context context, Intent intent) &#123; Log.w(TAG, \"intent:\" + intent); String name = intent.getStringExtra(\"name\"); Log.w(TAG, \"name:\" + name + \" m=\" + m); m++; Bundle bundle = intent.getExtras(); &#125;&#125; BroadcastReceiver注册类型BroadcastReceiver总体上可以分为两种注册类型：静态注册和动态注册。 1). 静态注册：直接在AndroidManifest.xml文件中进行注册。规则如下： &lt;receiver android:enabled=[\"true\" | \"false\"]android:exported=[\"true\" | \"false\"]android:icon=\"drawable resource\"android:label=\"string resource\"android:name=\"string\"android:permission=\"string\"android:process=\"string\" &gt;. . .&lt;/receiver&gt; 其中，需要注意的属性 android:exported — 此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）； android:name — 此broadcastReceiver类名； android:permission — 如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收； android:process — broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程） 常见的注册形式有: &lt;receiver android:name=\".MyBroadcastReceiver\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 其中，intent-filter由于指定此广播接收器将用于接收特定的广播类型。本示例中给出的是用于接收网络状态改变或开启启动时系统自身所发出的广播。当此App首次启动时，系统会自动实例化MyBroadcastReceiver，并注册到系统中。 之前常说：静态注册的广播接收器即使app已经退出，主要有相应的广播发出，依然可以接收到，但此种描述自Android 3.1开始有可能不再成立。具体分析详见本文后面部分。 2). 动态注册：动态注册时，无须在AndroidManifest中注册组件。直接在代码中通过调用Context的registerReceiver函数，可以在程序中动态注册BroadcastReceiver。registerReceiver的定义形式如下： registerReceiver(BroadcastReceiver receiver, IntentFilter filter)registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) 典型的写法示例如下： public class MainActivity extends Activity &#123; public static final String BROADCAST_ACTION = \"com.example.corn\"; private BroadcastReceiver mBroadcastReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBroadcastReceiver = new MyBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); registerReceiver(mBroadcastReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(mBroadcastReceiver); &#125;&#125; 注：Android中所有与观察者模式有关的设计中，一旦涉及到register，必定在相应的时机需要unregister。因此，上例在onDestroy()回到中需要unregisterReceiver(mBroadcastReceiver)。 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中。当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 3. 广播发送及广播类型经常说”发送广播“和”接收“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。 下段代码片段显示的是一个普通广播的定义过程，并发送出去。其中setAction(..)对应于BroadcastReceiver中的intentFilter中的action。 Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);intent.putExtra(\"name\", \"qqyumidi\");sendBroadcast(intent); 根据广播的发送方式，可以将其分为以下几种类型： Normal Broadcast：普通广播 System Broadcast : 系统广播 Ordered broadcast：有序广播 Sticky Broadcast：粘性广播(在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated) Local Broadcast：App应用内广播 下面分别总结下各种类型的发送方式及其特点。 1). Normal Broadcast：普通广播此处将普通广播界定为：开发者自己定义的intent，以context.sendBroadcast_”AsUser”(intent, …)形式。具体可以使用的方法有：sendBroadcast(intent)/sendBroadcast(intent, receiverPermission)/sendBroadcastAsUser(intent, userHandler)/sendBroadcastAsUser(intent, userHandler,receiverPermission)。普通广播会被注册了的相应的感兴趣（intent-filter匹配）接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。 2). System Broadcast: 系统广播Android系统中内置了多个系统广播，只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开启启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，有系统自动发出。 3). Ordered broadcast：有序广播有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。 对于有序广播，其主要特点总结如下： a. 多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。 b. 先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。 4)Sticky Broadcast：粘性广播在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated。既然已经deprecated，此处不再多做总结。 5)Local Broadcast：App应用内广播（此处的App应用以App应用进程为界）由前文阐述可知，Android中的广播可以跨进程甚至跨App直接通信，且注册是exported对于有intent-filter的情况下默认值是true，由此将可能出现安全隐患如下： 其他App可能会针对性的发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收到广播并处理； 其他App可以注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 无论哪种情形，这些安全隐患都确实是存在的。由此，最常见的增加安全性的方案是： 对于同一App内部发送和接收广播，将exported属性人为设置成false，使得非本App内部发出的此广播不被接收； 在广播发送和接收时，都增加上相应的permission，用于权限验证； 发送广播时，指定特定广播接收器所在的包名，具体是通过intent.setPackage(packageName)指定在，这样此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 App应用内广播可以理解成一种局部广播的形式，广播的发送者和接收者都同属于一个App。实际的业务需求中，App应用内广播确实可能需要用到。同时，之所以使用应用内广播时，而不是使用全局广播的形式，更多的考虑到的是Android广播机制中的安全性问题。 相比于全局广播，App应用内广播优势体现在： 安全性更高； 更加高效。 为此，Android v4兼容包中给出了封装好的LocalBroadcastManager类，用于统一处理App应用内的广播问题，使用方式上与通常的全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将主调context变成了LocalBroadcastManager的单一实例。 代码片段如下： //registerReceiver(mBroadcastReceiver, intentFilter);//注册应用内广播接收器localBroadcastManager = LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter); //unregisterReceiver(mBroadcastReceiver);//取消注册应用内广播接收器localBroadcastManager.unregisterReceiver(mBroadcastReceiver);Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);intent.putExtra(\"name\", \"qqyumidi\");//sendBroadcast(intent);//发送应用内广播localBroadcastManager.sendBroadcast(intent); 4. 不同注册方式的广播接收器回调onReceive(context, intent)中的context具体类型 1). 对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext； 2). 对于全局广播的动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context； 3). 对于通过LocalBroadcastManager动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Application Context。 注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册的ContextReceiver才有可能接收到（静态注册或其他方式动态注册的ContextReceiver是接收不到的）。 5. 不同Android API版本中广播机制相关API重要变迁1). Android5.0/API level 21开始粘滞广播和有序粘滞广播过期，以后不再建议使用； 2). ”静态注册的广播接收器即使app已经退出，主要有相应的广播发出，依然可以接收到，但此种描述自Android 3.1开始有可能不再成立“ Android 3.1开始系统在Intent与广播相关的flag增加了参数，分别是FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES。 FLAG_INCLUDE_STOPPED_PACKAGES：包含已经停止的包（停止：即包所在的进程已经退出） FLAG_EXCLUDE_STOPPED_PACKAGES：不包含已经停止的包 主要原因如下： 自Android3.1开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。 详情参加Android官方文档：http://developer.android.com/about/versions/android-3.1.html#launchcontrols 由此，对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。 但是对于自定义的广播，可以通过复写此flag为FLAG_INCLUDE_STOPPED_PACKAGES，使得静态注册的BroadcastReceiver，即使所在App进程已经退出，也能能接收到广播，并会启动应用进程，但此时的BroadcastReceiver是重新新建的。 Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);intent.putExtra(\"name\", \"qqyumidi\");sendBroadcast(intent); 注1：对于动态注册类型的BroadcastReceiver，由于此注册和取消注册实在其他组件（如Activity）中进行，因此，不受此改变影响。 注2：在3.1以前，相信不少app可能通过静态注册方式监听各种系统广播，以此进行一些业务上的处理（如即时app已经退出，仍然能接收到，可以启动service等..）,3.1后，静态注册接受广播方式的改变，将直接导致此类方案不再可行。于是，通过将Service与App本身设置成不同的进程已经成为实现此类需求的可行替代方案。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Broadcast","slug":"Broadcast","permalink":"http://github.com/tags/Broadcast/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"谷歌整体战略：关于人工智能、云服务和登月计划的未来","slug":"谷歌整体战略：关于人工智能、云服务和登月计划的未来","date":"2016-10-21T07:43:20.000Z","updated":"2016-12-21T04:00:42.906Z","comments":true,"path":"2016/10/21/谷歌整体战略：关于人工智能、云服务和登月计划的未来/","link":"","permalink":"http://github.com/2016/10/21/谷歌整体战略：关于人工智能、云服务和登月计划的未来/","excerpt":"CB Insights 今日发布了一篇关于谷歌业务战略的深度分析报告: Google Strategy Teardown: Betting The Future On AI, Cloud Services, And (Tamed) Moonshots，盘点了谷歌在人工智能、云服务、虚拟现实/增强现实、电信与能源、运输与物流、硬件和服务平台等众多领域的业务和战略。其中人工智能是贯穿谷歌所有方面的创新的线索。 自 1998 年谷歌在加利福尼亚州门洛帕克的一间车库变成一家公司以来，它已经发展成为了后 .com 时代企业创新的火炬手。谷歌对长远创新的亲睐体现在多个方面——从其广为人知的员工可用于个人项目的「20% 个人时间」政策（这个政策导致了 Gmail 和 AdSense 的诞生），到其在 2009 年成立的准独立的风险资本部分 Google Ventures，再到其面向未来创新的「登月计划」的 Google X 创新实验室（已改称 X）。 但是，近些年来，该公司已经开始转变其实验性的方法、有风险的研发和分散式的公司结构了。 在 2011 年执掌谷歌后，CEO Larry Page（现为 Alphabet 的领导者）就宣布谷歌将在「更少的箭头后放更多木材」，要向更重要的方向投入更多资源：从民主化的自下而上的创新方法变成更为自上而下的重点式战略。 实际上，据报道「20% 个人时间」政策在近些年来已经受到了限制，需要更多的管理批准和监督。 与此同时，谷歌已经从核心的搜索和广告业务扩展到了更为广阔的业务领域，其涵盖了从消费硬件到汽车到电信到医疗到风险投资等众多领域。","text":"CB Insights 今日发布了一篇关于谷歌业务战略的深度分析报告: Google Strategy Teardown: Betting The Future On AI, Cloud Services, And (Tamed) Moonshots，盘点了谷歌在人工智能、云服务、虚拟现实/增强现实、电信与能源、运输与物流、硬件和服务平台等众多领域的业务和战略。其中人工智能是贯穿谷歌所有方面的创新的线索。 自 1998 年谷歌在加利福尼亚州门洛帕克的一间车库变成一家公司以来，它已经发展成为了后 .com 时代企业创新的火炬手。谷歌对长远创新的亲睐体现在多个方面——从其广为人知的员工可用于个人项目的「20% 个人时间」政策（这个政策导致了 Gmail 和 AdSense 的诞生），到其在 2009 年成立的准独立的风险资本部分 Google Ventures，再到其面向未来创新的「登月计划」的 Google X 创新实验室（已改称 X）。 但是，近些年来，该公司已经开始转变其实验性的方法、有风险的研发和分散式的公司结构了。 在 2011 年执掌谷歌后，CEO Larry Page（现为 Alphabet 的领导者）就宣布谷歌将在「更少的箭头后放更多木材」，要向更重要的方向投入更多资源：从民主化的自下而上的创新方法变成更为自上而下的重点式战略。 实际上，据报道「20% 个人时间」政策在近些年来已经受到了限制，需要更多的管理批准和监督。 与此同时，谷歌已经从核心的搜索和广告业务扩展到了更为广阔的业务领域，其涵盖了从消费硬件到汽车到电信到医疗到风险投资等众多领域。 去年十月份的 Alphabet 组织架构重组就是为了这个庞大的规划网引入更大的结构、透明度和财政责任。为了同样的目的，该公司还在今年七月份聘请了摩根士丹利在财务纪律（financial discipline）享有盛名的资深高管 Ruth Porat 作为首席财务官。 一年来，这些举措已经给山景城应对收购和研发的方法带来了明显的改变。新的股权激励将会将员工的奖励和个人单位绩效挂钩。在 X 实验室，负责人 Astro Teller 曾写了需要推进登月项目「毕业」——「毕业」是指项目最终成长为 Alphabet 企业家族中可扩展的团队和产品。以 GV 为例，该投资部门已经很长时间没有领导了，其规模以及尤其的种子交易截至今年目前为止已经缩减了。 由于该公司幅员辽阔，我们使用了 CB Insights 科技市场智能平台中的许多工具来提炼 Alphabet 组织范围内各个单位的收购、投资和研究/专利活动，从而获得了一个关于其未来战略的数据驱动的视角。鉴于该公司运营范围的辽阔，我们不会触及每一项计划和部门，而只关注推动谷歌系向前的主要和反复出现的主题，其中包括： 推进云和硬件：Alphabet 推动增长的领域已经不再限于广告了，也在研发、收购和投资有可能实现收入和带来利润的业务和领域，例如高级移动和智能家居硬件，尤其是云和企业服务。比如谷歌在 Nest 之后最大的收购 Apigee 就是一家已经上市的企业云公司。 人工智能优先（AI-first）战略：该公司正在利用其人工智能/机器学习的专家人才（包括那些通过 DeepMind 收购吸纳进来的）来差异化自己在上述部门以及搜索和广告、整个面向消费者的网页服务和其它 Alphabet 单位的产品。谷歌新款的高端移动和智能家居设备就是提供一些人工智能服务的渠道。 关注增强现实/虚拟现实、自动驾驶和数字医疗：投资、收购和山景城的专利数据范围包括自动驾驶、可穿戴、人工智能驱动的医疗和为全球更大范围的人口提供网络接入。 收购再次回升：该公司在 2016 年第 3 季度进行了 9 次收购，是自 2014 年第 3 季度以来最多的。这说明了该公司的兼并收购（M&amp;A）意愿的复兴，因为其已经表现出了进一步拓展移动硬件（包括 Pixel 手机和智能家居中枢）、企业云服务、交通/物流、虚拟现实等领域的打算。 GV 已经大大退出了种子市场：GV 已经基本上不再投资年轻的创业公司了。其种子投资上的行为已经较去年同期下降了 85%，在 2016 年上半年完全没有任何新的种子交易。 规范其它登月项目：控制开支和强迫登月项目概划盈利的途径。这让该公司启用了资深人士和重组了团队以实现业务化，另外还招募了一些外部行业资深人士来推动 Loon 和自动汽车项目的商业化。 目录 谷歌核心的一些背景 收购 投资 谷歌 GV 谷歌资本 专利数据分析 按领域划分的 Alphabet 计划 人工智能 云与企业 消费硬件和平台 增强现实/虚拟现实 电信与能源 交通与物流 医疗保健和数字健康 金融科技 结语 谷歌核心的一些背景在我们深入到 Alphabet 未来战略背后的数据之前，我们必须快速了解其目前最成熟和最盈利的业务线：谷歌搜索和广告。 提醒一下，现在的谷歌包含搜索、地图、云和企业、谷歌品牌的硬件和操作系统（Chrome、安卓等）和 YouTube。其它所有单位（从投资部门（GV、Google Capital）到 X 部门）现在都直接隶属于 Alphabet。但我们将统一使用「谷歌」进行指代，不管它现在确实属于谷歌还是在 Alphabet 之前属于谷歌。 2016 年第 2 季度，该公司的总收入（top-line）和净收入（bottom-line）增长超出了分析预期。主要在谷歌的核心广告业务的推动下，Alphabet 的季度收入跃升了 21%，增长至 215 亿美元，利润则增长了 24%，超出了市场预估。这种强劲的势头的推动力来自向移动平台的成功过渡，其中包括新的移动广告格式和更好的效果评估。 尽管上个季度的结果大部分是积极的，但也存在一些可能会影响长期前景的趋势。首先，谷歌广告业务的收入中来自其自家网站的份额在 2016 年第 2 季度首次达到了巅峰的 80%，而在 2011 年时这个比例是 70%。这意味着未来的广告增长将前所未有地更加依赖于谷歌向其自己网站（例如搜索结果和谷歌新闻等等）的流量引导，而不是向网络成员的网站。 移动广告通常比桌面广告的利润低，所以谷歌的成功是在每次点击的收入（CPC，当消费者点击广告商的广告时，广告商向谷歌的平均付费）更低的情况下实现的，其巨大的增量抵消一些这种情况的影响。2016 年第 2 季度在自家网站的 CPC 仅有两年前自家网站的 CPC 的 76%。 应用程序和连接设备数量的激增也带来了挑战，因为在 Facebook 和微信等应用程序占用大量用户在线时间，以及新一代设备（如智能家居中心）导流搜索流量成为潜在竞争对手的情况下，还不清楚谷歌的搜索引擎是否会继续占领主导地位（例如通过亚马逊的 Echo 智能家居设备和其 Alexa 语音助手直接进行的搜索）。 事实上，谷歌在全球数字广告支出中所占的份额持续下降，因为像 Facebook 这样的国内竞争对手以及百度和阿里巴巴等国际竞争对手都在持续增加市场份额。 谷歌的广告业务使公司长期以来一直保持稳定，同时它的财务手段也成为其登月计划（moonshot）的支撑。然而，尽管 Alphabet 的业务数量庞大，其财务业绩和增长前景仍然严重依赖于谷歌的原有业务（广告占了 Alphabet 2016 年第二季度收入的 89％）。其核心业务的卓越表现在其它不稳定的业务中是显而易见的，但是山景城（加利福尼亚州的一个县）已经敏锐地觉察到谷歌的收入来源是缺乏多样性的。当我们通过它的子公司深入了解 Alphabet 的活动时，我们将看到寻找新的增长途径是如何塑造了该公司的战略的收购。 收购传统认为谷歌是最有收购能力的科技公司之一，但它的收购步伐速度放缓，并导致了 Alphabet 架构下的机构重组。 自 2001 年以来，该公司已经进行了近 200 次收购，引进外部人才和扩展新的部门，并在这个过程中创造了 Larry Page 的另一句「牙刷测试（toothbrush test）」技术格言，来确定并购目标是否值得。（目标是必须开发客户认为每天都不可缺少的产品。） 我们的收购跟踪工具包括在山景城稳定的收购流中的每个收购记录。Alphabet 今年迄今（16 年 10 月 10 日）已经收购了 13 家公司，仅在上个月就进行了 3 次收购，其中包括 6.5 亿美元收购上市云公司 Apigee。我们使用 CB Insights Acquirer Analytics 工具跟踪谷歌自 2010 年以来的并购活动： 在这十年的大部分时间里，谷歌一直是技术并购的主导力量；活动在 2014 年达到顶峰，因为谷歌在第二季度收购了十多家公司，远远领先于那一年其它科技巨头的收购规模。然而，该公司的收购步伐大幅放缓，Alphabet 重组，并在 2016 年上半年大幅下降。最近一个季度的收购活动增加，虽然是否为昙花一现还有待观察，也或许是山景城适应了 Alphabet 的新收购速度释放的信号。到目前为止，2016 年第四季度，Alphabet 只收购了 Famebit，一个可以帮助商业品牌与 YouTube 上的视频创作者建立联系的平台。 除了最新的财务紧张问题，近十年来大规模收购带来的低迷结果可能也促使了公司收购活动的暂停。该公司快速地收购了至少 7 家机器人公司——Schaft , Industrial Perception , Meka Robotics, Redwood Robotics ,Bot &amp; Dolly , Holomni , 以及最著名的波士顿动力（Boston Dynamics）——触发了 2014 年的炒作高峰（如趋势图所示，如下），但这些公司从来没有合并成为一个高效的机器人公司。前安卓负责人 Andy Rubin 带领了机器人浪潮，但 Rubin 于 2014 年 10 月离开公司创办全球硬件创业孵化器 Playground Global。失去了有远见的人物可能会阻碍机器人部门的发展，不管是在谷歌或是在 Alphabet，这个名为 Replicant 的机器人部门从未真正合并成为一个完整的公司。 相反，在 Alphabet 创立后，Replicant 直接进入管理层的视线，新公司 Alphabet 对其各公司的创收潜力进行了严格的审查。虽然像波士顿动力公司这样的子公司在 YouTube 上备受推崇，但是漫长的商业化道路导致该公司在 2016 年初被出售。最近，谷歌 2014 年对智能家居的重要战略环节——收购 Revolv，Dropcam（5.55 亿美元）和 Nest（3.2 亿美元，迄今为止收购的最大的初创公司）也被管理不善和员工流失的指控所困扰。Nest 的紧张局势随着 Nest 联合创始人兼首席执行官 Tony Fadell 在 6 月份的离开而公之于众。Fadell 辞职的事件中反复提到了智能家居领导层之间的摩擦，最引人注目的是 Dropcam 创始人 Greg Duffy 在 Medium 上的一篇博客（他的 Dropcam 团队被纳入 Nest 智能家居部门）： 将 Dropcam 卖给 Alphabet 是我的错误……可以说，我与当前 Nest 的领导在管理方式上有极大的差异。 Nest 的问题可以看作是旧的管理结构的失败，即在公司扩展到新的市场和产品线时，没有正确地管理其各个子公司，在 Googleplex 背景下协调达成一致的目标和企业文化。事实上，Nest 部门（现在是一个独立的 Alphabet 公司）远离了该公司的新智能家居硬件的努力方向（刚于 2016 年 10 月 4 日的智能硬件大会上发布 Google Home）。作为 Alphabet 的事实上的智能家居公司，Nest 可能是成为亚马逊 Echo 设备的竞争者的最好的选择。然而，亚马逊设备对谷歌公司的主要搜索业务的明显威胁，以及与亚马逊竞争的日益激烈，可能导致谷歌得出结论：必须将开发智能家居作为公司核心，并由谷歌的执行官直接监督。 此外，这样的产品需要与谷歌的核心搜索和虚拟助理服务紧密集成。Nest 作为谷歌的非核心公司想要实现这一点，跨越部门间的界限和达成共识将有更多的麻烦。 新成立的 Alphabet 结构可能有助于更成功的并购和不同业务的整合。Alphabet 旗下的不同部门将可以根据它们自己的战略利益和路线规划进行收购游说；但也会面临一个更为清晰的组织结构，能让 Alphabet 称霸天下，也会迫使其减少对投机项目的投入。 尽管谷歌的机器人和智能家居的投资已经变成了警示性的故事，但谷歌在许多其它领域的收购却带来了毫无疑问更为积极的结果。2014 年谷歌收购的 DeepMind（金额在 5 亿到 6 亿美元之间）已经通过其高调的 AlphaGo 和 WaveNet 项目巩固了谷歌在人工智能研究方面的声誉，而且其技术也已经在谷歌的数据中心和翻译工具等产品中得到了应用。 除了智能家居，谷歌与亚马逊的激烈竞争也带来了对云和企业服务的收购，以及一种完全不同的战略方法。谷歌正确地将云平台作为了其优先事项，因为其过去在这方面落后于亚马逊的 AWS 和微软的 Azure（尽管谷歌最近得到了一些战略性的云客户，其中包括苹果和 Spotify）。 在这个领域，谷歌严重依赖于收购来补充其内部研发和在其平台之上提供增值服务。特别地，CEO Sundar Pichai 曾说过该公司的目标是通过稳健的、对开发者友好的服务进行竞争，而不是单纯的规模。我们的收购方分析数据也突出了这方面的努力： 一个主要的例子是谷歌在今年 9 月对 Api.ai 的收购，这是一家帮助开发者开发对话式智能接口的创业公司。这能很好地和人工智能交织在一起，而人工智能则是谷歌的差异化战略的另一支柱（更多细节请参看行业部分）。 谷歌在这一领域的其它收购还包括 2014 年的 Stackdriver、Appurify、Firebase 和 Zync Render，以及过去两个月的 Apigee 和 Orbitera。事实上，谷歌 2016 年的一半以上的收购都涉及到企业应用或 B2B 云服务。其中许多都发生在 Recode 3 月份的谷歌在寻找企业云领域的目标上最活跃的报道之后。 据最近离开谷歌的人说，那些收购请求出现最频繁的是这个领域：企业。 在云的推动下，谷歌得以关注服务中端市场的多个目标，旨在增加多样化的企业能力，这和对 Nest 的数十亿美元的重磅收购不同。其 1 亿美元收购的计费服务公司 Orbitera 是这种追赶策略以及其对一个灵活的、「多云（multi-cloud）」世界（其中企业将越来越依赖于多个供应商）的支持的象征。 另外值得一提的是，和押注前沿的有希望但未得到证明的领域相比（比如，自动驾驶汽车和机器人），Alphabet 的一系列云和企业收购更倾向于有明显的赚钱机会的较为成熟的公司。 Alphabet 六月份对 Webpass 的收购也是来自于对成熟的电信领域的收购。Alphabet 运营 Fiber 业务的 Access &amp; Energy 部门已经宣布了利用 Webpass 的无线技术降低资本开支和部署时间的计划（伴随着 Fiber 业务成本高昂的扩张）。在这样的背景中，Webpass 看起来像是又一个带来了即时影响的收购——降低了开始并提升了盈利能力。 不可否认，自 Alphabet 诞生以来的这短短一年时间，数据就已经深远地影响了这个新组织在平衡「登月项目」和财政责任上的尝试，并且明晰了其实现收入的路径。 投资：谷歌，GV 和谷歌资本Alphabet 的投资活动一直被竞争者和观察家们关注。一部分投资由下属的谷歌或其分支直接发起（例如 DeepMind 直接投资了远程医疗初创公司 Babylon）。但大部分投资来自 Alphabet 的两家主要投资机构：专注于早期初创企业的 GV（前谷歌风投）和对扩张期公司投资的谷歌资本（Google Capital）。 这些投资分支一直强调其投资策略与谷歌本身互相独立。在 2015 年 9 月，集团的运营策略发生了改变，GV 和谷歌资本成为了新控股公司下的两家分支公司。（但他们共同接受 Aphabet 的高级副总裁 David Drummond 的监督，此人同时监管集团的企业并购业务。）我们相应地单独分析他们的活动，但它们仍会同时出现在一些深入的剖析中。 正如上图显示的，三家机构的投资活动数量在近期有很大波动。GV 的交易活动在 Alphabet 成立之前已经开始下降，而投资的增长来自于谷歌资本和谷歌本身的战略投资。 谷歌从谷歌开始，公司的主要战略投资包括几次大型交易到一些「前沿」领域如增强现实，太空运输和探索。谷歌在 2014 年 10 月领投了隐形增强现实设备 Magic Leap 5.42 亿美元的一轮投资，在 2015 年 1 月又参与了 Space X 10 亿美元的 D 轮融资。有消息称谷歌正准备在未来对这家宇航公司继续投资 90 亿美元，以获得 7.5% 股权。 这种投资活动的规模强调了山景城对于先进科技领域的重视。谷歌认为 AR/VR 是未来计算视觉呈现的核心。其 Magic Leap 的交易宣示了公司策略的进一步多元化（谷歌已有包括在 2016 年 10 月发布的消费级产品 Daydream 移动 VR 头盔，和其他早期产品，如 Cardboard，Google Glass 和 Tango）。 与此同时，谷歌向 SpaceX 进行了大笔投资，这将帮助 Alphabet 的「登月计划」为谷歌提供地理信息（Terra Bella，前 Skybox Imaging 项目），同时帮助提升全球互联网覆盖面积（Access and Energy，前 Project Loon 等计划）。廉价高效的地球卫星发射将会为对这两个方面提供便利，而 SpaceX 的首席执行官埃隆·马斯克对此也志趣相投，他决心建立一个以卫星为媒介的全球通信网络。谷歌直接资助了卫星服务公司 O3b Networks ── 而 O3b 已被欧洲卫星通信公司 SES 以 14 亿美元的价格收购──这些投资也与上述活动相关。 除了战略投资，在 2016 年 4 月谷歌建立了 Area 120，一个为公司内部员工准备的创业孵化器。这些措施是为了防止公司人才的外流。孵化器的名字中提及挤出 20% 的时间进行创业，就像谷歌的其他传统一样，这已经变成了一个正式的，明确的计划。 GVAlphabet 风投机构自 2009 年成立以来，已经成为了风投生态中的重要一环，它一直是最为活跃的风投公司。我们接下来分析 GV。 有这样一个事实：Bill Maris，作为创始人和首席执行官在 8 月初离开了 GV。有匿名消息称这次人员变动与上级公司 Alphabet 的重组有关（在 Maris 治下的 GV 以自主决定权而闻名）。目前事件的双方仍公开表示友好，Maris 这样评论： 我的离开是因为所有事情都很棒……我与 Alphabet 之间没有问题。但 Alphabet 的改变对所有人都有一点影响。我们（GV）从第一天开始就是独立的。 虽然如此，在后 Aphabet 时代里，创始人的离去仍将成为主题，这一幕也许将会在公司的其他部门继续呈现。 通过 CB Insight 的投资分析工具分析 GV 近期的投资活动，我们可以看到 GV 的投资速度自 2013 年末到 2014 年初的顶峰（约每季度 30 笔投资）以后，有逐渐下降的趋势。这与我们之前 GV 正在减少新投资活动的结论相同。 GV 在 2009 年以 10 亿美元资本起家，每年膨胀 50 亿美元。随着 GV 资金来源的充裕，它逐渐参与进了大型投资，如 2014 年优步 12 亿美元的 D 轮投资和 Jet.com 在 2015 年的 B 轮投资。CB Insight 的投资分析工具显示了 GV 持续增长的中型交易，在 2016 年第一季度，公司一跃进入了大型投资的行列，包括 2 月份对 Oscar（40 亿美元）和 Magic Leap（7.94 亿美元）的投资。总的来说，数据显示 GV 的大型投资脱离了 2015 年以前的中位数，出现了急剧上升。 交易数量的减少和投资金额的增加表明 GV 已完全退出天使轮投资市场，这个曾经它赖以为生的领域。在过去的两年里，它的天使轮投资活动每年减少 85%，在 2016 年上半年则完全没有这种投资出现。 Bill Maris 在去年 12 月承认了这种变化，认为在前期投资中的机会正在减少。在 今年 8 月 Maris 离职的采访中，他同样指出 GV 目前对于投资形式存在限制： 当你有 25 亿美元的资金，进行种子轮投资就是浪费时间了。 同时，GV 融资项目的区域也越来越固定了──以美国为中心。公司 2014 年启动了 12.5 亿美元的欧洲投资专项资金，由五位合伙人进行管理。然而，在后 Alphabet 时代，这个项目在 2015 年 12 月宣告终止，其中资金被回收并投入 GV 品牌再造项目。 在大约一年半之前，欧洲的分部进行了不到十项投资，其中最大的交易是对宾馆预定网站 Secret Escapes 6000 万美元的 C 轮融资（Octopus Investments 是这次投资的另一个领投者）。 从行业上看，GV 一直被其「独立」的策略所束缚，公司表面上追求高风险，但潜在高回报的登月式的项目，实际上却与传统风投公司别无二致。Maris 的个人魅力渲染了谷歌对于登月式项目的追求。医疗领域的投资为这种看法做出了注解，正如 Maris 在 2015 年文件中所说： 如果你今天问我，我们会活到 500 岁吗？答案是肯定的……如果有人让你在很多钱和能活很久中进行选择，你会怎么选？ 的确，GV 一直在强调他们会投资医疗初创企业。他们的投资范围从数字医疗公司（Flatiron Health）到供应商（One Medical），也包括新方向如基因医疗（Editas，Foundation Medicine，23andMe）。近年来，公司正在这些公司上投入越来越多的资金。在 2015 年 3 月，Maris 在接受彭博社的采访时披露，其时 GV 已将 36% 的资金投入生命科学领域，而在 2013 年，这个数字只有 6%。 GV 的投资和 Alphabet 其他部门 Verily 与 Calico 的投资共同正在为变革性医疗研究助力。如此重视医疗行业无疑是因为 Bill Maris 拥有生命科学背景；事实上，这位前生物科学公司管理人直接推动了 Calico，Alphabet 神秘的抗衰老研究部门。在 CB Insight 中，我们可以深入了解 GV 对于其他领域的投资，跨度从 AR/VR 领域到无人机，互联网金融，网络安全，再到人工智能。GV 的投资组合与 Alphabet 令人眼花缭乱的资本操作有着很多重合。至少 6 家 GV 投资的公司最终都被山景城收购，其中值得注意的是 2014 年的 Nest。 另一方面，优步突然变成了 GV 甚至 Alphabet 投资策略中潜在的不和谐音符。随着竞争对手的压力，优步开始将重心转向他们的自动驾驶汽车，而谷歌此前也投资了拼车应用 Waze（收购于 2013 年）探索共乘车市场。随着这些步骤的实施，在共乘车服务上他们正在对优步形成威胁。 作为回应，优步正在逐渐稀释管理层中 Alphabet 的地位，交易负责人 David Drummond 离开了优步董事会。这家打车公司同时驱逐了董事会观察员 David Krane，后者是 GV 的合伙人，现已成为 Bill Maris 的继任者。 谷歌资本谷歌资本是 Alphabet 风投家庭中年轻的一员，于 2013 年创立。因其资金充裕，公司的投资方向明显不同于集团内老一代的同僚，谷歌资本主要参与初创企业的后期融资阶段。据称，他们每年的投资数量为 30 亿美元。一个健康的数字，但略微少于 GV。正如其宣称的，谷歌资本将自身定位于盈利导向（而不是战略导向）的投资者。当然，其不断增长的资金仍正在利用专业知识，招募基础和其母公司谷歌的威望作为其核心卖点。集团的其他公司承诺给对谷歌资本共享资源。Edward Kim，被投资公司 Gusto 的首席技术官赞赏这种工作方式： 他们真的从谷歌内部找到了一个人，一个能够解决我们问题的人。相比资金，他们其实带来了更多技术上的帮助。 自成立以来，谷歌资本一直维持比 GV 更低的活跃度。他们每季度的成交数量维持在 1 至 3 笔，只在 2015 年第三季度超过了这一数字。 谷歌资本通常参与 2500 万至 10 亿美元的融资轮，这不属于很大的交易。其中一些包括 CloudFlare 的 D 轮融资（11 亿美元），FanDuel 的 E 轮融资（27.5 亿美元），和 Oscar 的 C 轮融资（40 亿美元）。 谷歌资本的投资方式反映了硅谷大多数高端投资公司的习惯，与那些著名对冲基金，或老虎基金与富达投资的科技投资共同基金相似。 GV 很少在谷歌资本投资之前对同一家公司进行投资。前者确实出现在了谷歌资本投资的一些公司的共同投资人名单上，但这一般都是在追逐利益时出现的巧合。当然，随着 GV 正在逐渐远离早期投资市场，两家投资机构的重叠区域可能会越来越多。 谷歌资本目前最值得一提的交易是对 Care.com 的首次公开市场投资。今年 6 月，谷歌资本宣布了对这家护理服务公司 4635 万美元的投资，该公司于 2014 年 1 月份上市。这次交易意味着公司的投资部门跨越私人与公开市场，这与那些共同基金和对冲基金的业务相同，正如谷歌资本的合伙人 Laela Sturdy 在回答公司对私人和公开市场领域之间的立场的问题时所说的： Care.com 体现了本公司的投资喜好。我们一直专注于成长阶段的公司，我们唯一的目标是帮助他们成长为拥有谷歌体量的巨头。 我们可能会看到未来谷歌资本进行更多的 PIPE（私募资本投资公开市场），又或许他们将固守传统的私人投资领域。 专利数据分析使用 CBInsights 专利数据，我们还筛选出公司研究活动的趋势。这项分析在执行时有几个注意事项，主要是，专利申请过程在应用发布前有一个明显的时间差。这个延迟时间从几个月到两年不等。我也拿谷歌做过该方面分析，排除了其外部收购公司带有的专利。 另外值得注意的是，谷歌一直以来对专利所持的态度。过去，公司高管包括 Larry Page 和 Sergey Brin 他们自己都反对申请过多的专利，这会威胁到硅谷的创新精神。乔布斯发布第一台 iPhone 时，谷歌只有 38 项专利。到了 2011 年，谷歌高级副总裁总法律顾问 Kent Walker 描述了公司对专利制度的普遍厌恶，他们希望见到改革措施： 专利不是创新。这是一种阻止他人创新的特权。 然而，随着智能手机的诉讼在本世纪初加剧，谷歌被迫转变了立场。2012 年，它以 125 亿美元的价格收购了摩托罗拉手机业务，这是迄今为止该公司最大的收购，该收购为谷歌不断增长的 IP 库带来了丰富的手机专利。谷歌自己也开始迅速提交专利应用申请。 关键数据突出在与谷歌前沿产品计划相关的专利上。Mountain View 的专利点亮了其谷歌眼镜计算设备及其他可穿戴设备研究。「Balloon」也在 2014 年问世，它从今年年初到现在一直处于下面这张列表的首位，Project Loon 的气球动力互连网络开发一直在持续。 关键词「车辆（vehicle）」上升的频率也反应出谷歌在自动驾汽车领域上的投入，他们一直在扩大自动驾驶的测试团队，还在寻找汽车制造商合作伙伴。2012 年，带有汽车关键词的应用数量激增，而且最近几年一直在增长，包括专利数据可能还不完整的 2014 年，所以当这些档案公布于世时，汽车应用的数量实际上甚至会更多。 很多这些专利产生计划（moonshot），当然包括自动驾驶机车项目，已经占领了谷歌的 X 实验室。自从 2010 年建立以来，X 实验室一直在尝试成为一个成功的致力于尖端前沿的企业研究机构，其他像 PARC 和贝尔实验室最终都因其母公司而失败了（至少在资金上）。 我们的趋势工具挖掘了数百万条媒体关于技术趋势的报告后显示，「moonshot」一词的流行度一时间接近了「Google X」。换句话说，谷歌的实验室与 moonshot 概念紧密相关，像传统的企业创新实验室运营商一样，Alphabet 已经不再避开专利系统了。 下一节中，我们将细究遗爱谷歌的一些优先项目，以及它们是如何融合进 Alphabet 的特定产业策略中的。 Alphabet 在各领域的战略和其投资部门很像，Alphabet 其他的子公司（包括谷歌）的业务都涉足了不同的领域。这里，我们对 Alphabet 涉足的重点领域进行分组深入分析。再次强调，下面的列表中不包括这家公司的所有业务活动，而是综合概述了其目前的兴趣领域。 人工智能今年 10 月在其最新高端 Pixel 智能手机的发布会展示中，谷歌 CEOSundar Pichai 说世界正在从「移动至上」转向「人工智能至上」。谷歌与人工智能这一时髦领域有着密切的联系，而且占领这一领域的欲望越来越强烈，并成为了最活跃的人工智能公司卖家。 在其公司内部，谷歌大脑以一个 X 项目成功凸显。去年，Astro Teller 将谷歌大脑描述成「谷歌的生产价值所在，可以抵得上 GoogleX 的总成本了，」这个小组开发了 tensorflow，并提高了从翻译到语音搜索的核心技术。在 Alphabet 今年第二季度盈利的电话会议上，Sundar Pichai 也对投资人重复强调了机器学习的重要性。 机器学习是驱动未来的引擎… 谷歌内部目前有超过 100 个团队在使用机器学习，从街景到 gmail 到语音搜索等等。 除了实体产品外，一个脱胎于 DeepMind 的系统已经帮助其耗电量巨大的数据中心减少了成本和实现了环境保护功能，将能源使用效率提升了 15%。 谷歌正在将机器智能和学习部署到它的所有业务上，我们也在几个关键领域对其人工智能方面的业务活动做出分析。 云&amp; 企业谷歌的云和企业服务已快速上升至其优先项目中了，这一点在其疯狂的收购中可见一斑。进一步推进有利可盈的服务市场延伸了 Alphabet 所强调的能直接带来财务上涨的机会的逻辑（上一季度，亚马逊 AWS 部门产生近 100 亿美元收入） 在 Alphabet 成立谷歌云事业部 Google Cloud Enterprise 后，谷歌立即挖来了 VMWare 的前 CEODiane Greene 任职谷歌的云计算事业部的高级副总裁。谷歌云包括了 Google for Work、云平台（针对 AWS）、和 Google App。谷歌已经开始重新定位其品牌。2016 年 9 月，Google for Work 品牌更名为 G Suite。视频群聊和没人爱的 Google+网络也正在转向企业用户。我们已经看到，谷歌正在收购和建立众多对开发人员友好的服务来区分其平台。然而，谷歌也在很多业务中利用了机器学习技术，以便在与对手的竞争中抢占先机。 谷歌大脑和公司的人工智能收购业务有助于推动这些进展，同时也肩负着提醒旁观者 Mountain View 在人工智能领域的领先地位的责任。然而据我们的趋势分析显示，就其云产品而言，谷歌在媒体报道上依然落后于微软 Azure 和 AWS。 虽然谷歌一直落后于亚马逊、微软，甚至是 IBM，但早期的回报总是积极性的。今年第二季度谷歌的「其他收入」（包括云及许可费用，硬件、及其他非广告业务）为 22 亿美元，并以 33% 的年增长率上升。公司高管们很快就注意到了，云服务是这一增长的主要驱动力，而且将仍然是谷歌找到创收新途径的战略基石。 消费硬件&amp;平台我们已经涉足了这个领域，但是 Alphabet 面向消费者的项目一直在努力平衡他们在金融实用主义上对激进项目的偏好。Nest 最近的已经出现在各个角落，但是其他部门的业务还在面临自己的困难。 谷歌搞出了 X，而 Advanced Technology and Projects（ATAP）的研发部门也在开发「epic shit（史诗级项目）」，并与公司保持适当的整合。但是，像其他的部门一样，针对于消费者的研发部门今年也经历了更换重要领导。 谷歌自从把摩托罗拉前总裁 Rick Osterloh 拉回董事会主持新一轮洗牌时，汇集了像 ATAP, Chromecast, Nexus, Pixel 智能手机和谷歌眼镜（后者原先由 Tony Fadell 负责）不同的面向消费者团队。这个新的硬件部门最近搁置了 Project Ara，自 2013 起来一度大肆宣传的模块化智能手机。 谷歌一直对其自主手机硬件品牌产品 Nexus 和 Pixel 不太满意，现在 Pixel 取代了 Nexus，并与运营商签约了正式分销协议。 谷歌的消费设备跨越各种智能手机、平板电脑、笔记本电脑，以及一个运行 Andromeda 的混合设备，一个统一了安卓和 Chrome 的操作系统。该公司继续在很大程度上轮流依赖于多家制造商伙伴（三星、HTC、华为等等）为其生产设备。 显然，谷歌谷歌刚刚宣布了 Pixel 线的品牌制造厂商，并促成了合作伙伴 HTC 与富士康合作（据说导致华为退出该项目）。 这些新手机与 Home 和 Daydream 一起在 10 月的「Made by Google」大会上发布。该产品的闪电问世为 Osterloh 的新硬件部门定下了基调，以谷歌为中心的品牌推广透露着该公司有点模仿微软 Surface 产品线的意味，更加接近苹果在硬件设计和软件服务上的业务布局。新的 Pixel 设备的溢价定价比对了之前 Apple 的 iPhone7 系产品的定价。谷歌又一次在一个成熟的行业中追逐一块高利润的馅饼。 谷歌也在展望对话智能平台的未来，从 Allo 的即时讯息到智能家居。此外，新的 Pixel 智能手机已经有内置捆绑人工智能的功能，包括新的虚拟谷歌助手，以及 Pixel 用户的照片和视频无限存储。至少现在，谷歌正在为其品牌 Pixel 和家居设备保留了语音助手（通过 Allo 的机器人聊天可以用上这个语音助手，但是没有整合进来）。 谷歌一直在利用人工智能来区分其消费云产品，比如其带有自然语言搜索和自动脸与对象识别的照片产品 在硬件和即时讯息这两个业务上，谷歌已经晚了一步，但是这些举措都对山景（Mountain View）产品在人工智能技术和作为搜索平台中心上奠定重要地位起到了关键作用。每个通过一个 Alexa-或者 Siri 驱动的设备的查询都威胁到了谷歌当前收入模型的基础。即便谷歌在这里取得了成功，一个以语音为中心的搜索形式仍有可能颠覆其已经依赖了十几年的传统网页搜索广告的显示模式。 同时，如果谷歌能将其设备和服务通过其人工智能技术含量区分开来，它将有机会创造出一个新的、潜在的高利润业务线，甚至可以通过拓展市场份额加强其与苹果和亚马逊的对抗。 增强现实（AR）/虚拟现实（VR）Alphabet 的增强现实/虚拟现实的经典战略已经开展成了多个并行运行的项目。该公司在这项业务上已经从预算虚拟现实（Cardboard），到 AR（谷歌眼镜）硬件再到 VR（Daydream）和 AR（Tango）平台，还有其前面提到的 Magic Leap。在我们的增强与虚拟现实研究简报中，我们已经研究了谷歌和其他科技公司。从产品创新来看，Daydream 头戴设备很有趣，它一改之前笨重的塑料套而使用了轻便的布状织物，是一款面向大众消费者的虚拟现实概念的新设计产品。 事实上，围绕谷歌 AR/VR 的讨论大部分都是讨论 VR 而不是 AR，这并不意外，因为它的 AR 可穿戴产品 Google Glass 失败了，而 Daydream 成为了谷歌在此领域中的旗手。 通信 &amp; 能源Alphabet 通过外部投资（SpaceX、O2b Networks）、收购（Titan Aerospace，现在是 Project Skybender）以及一些内部项目，投入了数十亿美元改进全球互联网的接通性。Google Fiber 要做的事已经演变成了对市场中传统电信服务提供商的打击，也就是那些为大半城市群提供千兆网络和电视服务的一方。 然而，Fiber 已经被部署光纤网络的成本困扰一段时间了，更不要提来自在位者的条例和法规难题了（Fiber 曾被指为 Alphabet「Other Bets」中最大的单项支出，Other Bets 是该集团对登月项目经济报告的涵盖性术语。）一旦资本支出自由流通，Fiber 如今正被邀请接受 Alphabet 的经济审查，8 月份来自高层的一份措辞严厉的要求就可见一般： Alphabet CEO 拉里·佩奇命令 Fiber 减少客户攫取成本到目前的 1/10，同时要求 Fiber 主管 Craig Barratt 砍掉一半职员，从 1000 到 500。 就像我们上面提到的，对 Webpass 的收购就像一剂药膏，直接缓和了这些损失。 其他项目包括谷歌的 Project Fi mobile virtual network operator（MVNO），谷歌称该项目是一项实验，动机是改进现任运营商。一个 MVNO，本质上也就是从无线和市场手机服务商那里购买带宽放到自己品牌、价位和支撑方案下面。 Link、Skybender 和 Loon 项目针对的是偏远地区和新兴市场的完全不同的人群，但这显然是「所有人都接入网络」理念的延展。和其它 X 单元一样，Loon 项目最近已经走出了 X，得到了来自 WildBlue 的行业老兵 Tom Moore 的领导，以推动该项目实现商业化。Loon 项目也利用了谷歌的机器学习之力，部署了能够优化气球的位置和方向的算法。 只要这些「登月项目」从 X 毕业，就很容易预想它们会被收纳到 Alphabet 的 Access &amp; Energy 的旗帜之下。有传言说这个 A&amp;E 单位将会换个新名字，但目前仍然还会包括 Alphabet 在能源方面的工作。Sunroof 项目是其中的一项计划，Makani 机载风力涡轮机（在 2013 年收购）如果成功，也是另一个自然的候选项目。 交通和物流谷歌自动驾驶汽车项目于 2010 年在 Google X 成立；其表现和公众知名度使之成为了 Google X 这个部门事实上的代言人。该公司已经相应地进行了投资，有传言说谷歌为这个长期项目准备了 100 亿美元。 就在 Alphabet 的重组之前，该项目也雇佣了自己的行业老兵——来自 Hyundai America 和 TrueCar 的 John Krafcik。这被广泛地解读成是使该项目正式实现独立的开始。在 4 月份的一个采访中，Astro Teller 将其描述成是「正在从 X 毕业的过程中」。（尽管 X 已经从谷歌分离，但该汽车项目目前仍然保留了原来的名字）。 事实上，这个谷歌汽车项目的测试场地已经从山景城扩展到了德克萨斯州、亚利桑那州和华盛顿州。在 5 月份时，它也与一家主要的汽车制造商（Fiat Chrysler）确定了首次合作关系，并且还在 7 月份引入了一个法律领导。 但是，一些长期的团队成员已经离开了这一项目。8 月份时候我们看到项目 CTO Chris Urmson 离开，一些工程师也离开了并创立了 Otto 和 Nuro.ai 等公司。随着其他玩家的加入，谷歌在这一领域的独特地位已经受到了挑战，正如我们 Trends 趋势工具对自动驾驶相关热点的跟踪那样： 在物流方面，Alphabet 有谷歌 Express 同日送达服务，这项服务在今年 2 月份已经扩展到生鲜杂货店。 在 X 旗下，还有 Wing 无人机项目，该项目最近和 Chipotle 进行了合作在弗吉尼亚理工测试卷饼送递服务。 和其它部门一样，这两个快递项目都是针对电子商务巨头亚马逊的无人机和其它物流项目的防御，以应对其对谷歌的产品搜索流量的威胁。它们也将 Alphabet 带入了与 Instacart、FreshDirect 和 Uber 的竞争中。我们已经将 Uber 评价为了自动驾驶和驾乘共享的有力竞争者。Wing 项目也与越来越多自动快递无人机创业公司形成了竞争关系。 医疗保健和数字健康正如我们所见，Bill Maris 领导的 GV 已经投资了很多医疗保健和数字健康领域的创业公司。尽管我们目前还不清楚在 GV 的新领导下，这个趋势是否还会继续，但 Alphabet 旗下已经有两个从事生命科学研究的分支机构了。 其中 Verify（即原来的谷歌生命科学（Google Life Sciences））自 2015 年 12 月以来启动很多项目，包括智能葡萄糖感应隐形眼镜、纳米诊断和用于抵抗震颤的 stabilized spoons（收购自 Lift Labs）。Verily 也与一些顶级的医疗保健品牌建立了合作，其中包括 Johnson &amp; Johnson（Verb Surgical）、GlaxoSmithKline（Galvani Bioelectronics）和 Dexcom（连续血糖监测）。 Verily 是另一个还没有明确的商业化规划的 Alphabet 部门。Verily 已经出现了人才流失的状况，一些人回到了谷歌的怀抱，一些人则成了竞争对手。充满怀疑的观察者也在质疑 Verily 项目的有效性和实用性，其中包括斯坦福大学疾病预防学教授。 人们需要搞明白这些玩意对于市场和公司的意义──一个新世界──或者我们正在谈论的东西将很快展现影响……后者是难以想象的。 同时 Calico 展现了登月哲学的真正精神，通过研究年龄基因和挑战衰老疾病来延长人类寿命。不同于 Alphabet 的其他分支，Calico 从集团外雇佣了医疗专家。在 2015 年 9 月，谷歌披露了这家分公司的预算达到了 24 亿美元，在必要的情况下可以增至 49 亿美元。 Calico 一直笼罩在谜团之中，它只有很少的具体产品，却更重视进行长期研究项目（Verily 在其基因研究中所言）。Calico 的网站内容简单，但仍然显示他们正与许多著名公司合作，包括 AbbVie，AncestryDNA，同时还有很多大学。 金融科技我们曾详细介绍了 Alphabet 突然切入金融科技领域，所以这里只是简要介绍一下。在投资领域，GV 和谷歌资本在科技金融的投资中占有重要地位。 保险技术是其中的焦点，Alphabet 在 2015 年中参与了至少 6 次这方面的合作与投资。这包括 Nest 与 American Family 的合作，和现在已经结束的 Google Compare，CoverHound 和 Compare.com 的伙伴关系。 今年六月，谷歌又宣布禁止在其所有网站上出现发薪日贷款的广告。在支付领域，谷歌停止了实物的 Google Wallet 卡服务，但仍在继续运营 Android Pay 平台。后者面临的竞争对手不仅是苹果，还包括 Android 授权的很多公司包括三星，他们也都在自己的手机上开发出了自己的支付平台。 结语总而言之，Alphabet 目前正在公司结构的转型期。公司的目标已经转变为面向更协调的目标和多元化的盈利。Alphabet 已经在努力使长期以来分工不甚明确的各个分支目标更加清晰。观察家和股东们都欢迎新的分支，硬件和软件团队，并满意公司专注于领导行业的目标。 当然，公司内部仍有冗余，大量 X 计划在过渡期间仍然存在。Alphabet 目前正将重心转向利润和商业潜力，同时以更为集中的方式应对竞争对手的挑战，它已选择了一个主要武器：人工智能。人工智能将是 Alphabet 在未来新市场中的杀手锏。但深耕人工智能是否能为谷歌带来成功仍有待观察。这主要取决于执行，以及人工智能的应用能否在运输，云服务，医疗和消费级硬件等各项领域中同时展现出竞争力。 ✄ ———————————————————————© 本文由机器之心编译，转载请联系微信公众号获得授权。✄ ———————————————————————","categories":[],"tags":[{"name":"Google","slug":"Google","permalink":"http://github.com/tags/Google/"}],"keywords":[]},{"title":"深入了解Android Studio和Gradle","slug":"深入了解Android Studio和Gradle","date":"2016-10-18T09:08:00.000Z","updated":"2016-10-18T10:07:30.387Z","comments":true,"path":"2016/10/18/深入了解Android Studio和Gradle/","link":"","permalink":"http://github.com/2016/10/18/深入了解Android Studio和Gradle/","excerpt":"原文链接： 重新认识AndroidStudio和Gradle，这些都是我们应该知道的 — by 井方哥 前言主要从AndroidStudio的环境安装升级，Gradle，Eclipse转AS,多渠道配置，Maven私服，Action,Option，快捷键等几个方面出发，讲一些操作技巧以及我对AndroidStudio使用的一些理解与经验。本文较全面的讲述了我们在开发中必须要了解的，比较多而全，可能不能马上记住，目的在于大家看我之后能有一个认识，在需要使用的时候知道有这么个东西。希望对你的开发工作有所帮助，不足之处，请批评指正。 一、Install&amp;Settings&amp;Update1、GradleGradle官方会不断更新，我们可以使用本地安装的方式，并配置path，我们就可以使用Terminal直接输入gradle命令执行构建任务。当然如果我们想快速更新，可以修改配置文件。 首先，修改project\\gradle\\warpper\\gradle-wapper.properties 文件，其中distributionUrl的值： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.4-all.zip 这里实际是从网络下载配置的版本，会自动检测，如果不是的就会下载。 然后修改 project的build.gradle dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125;","text":"原文链接： 重新认识AndroidStudio和Gradle，这些都是我们应该知道的 — by 井方哥 前言主要从AndroidStudio的环境安装升级，Gradle，Eclipse转AS,多渠道配置，Maven私服，Action,Option，快捷键等几个方面出发，讲一些操作技巧以及我对AndroidStudio使用的一些理解与经验。本文较全面的讲述了我们在开发中必须要了解的，比较多而全，可能不能马上记住，目的在于大家看我之后能有一个认识，在需要使用的时候知道有这么个东西。希望对你的开发工作有所帮助，不足之处，请批评指正。 一、Install&amp;Settings&amp;Update1、GradleGradle官方会不断更新，我们可以使用本地安装的方式，并配置path，我们就可以使用Terminal直接输入gradle命令执行构建任务。当然如果我们想快速更新，可以修改配置文件。 首先，修改project\\gradle\\warpper\\gradle-wapper.properties 文件，其中distributionUrl的值： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.4-all.zip 这里实际是从网络下载配置的版本，会自动检测，如果不是的就会下载。 然后修改 project的build.gradle dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125; 注意：这两个配置是一一对应的，比如gradle-2.4-all对应的就是1.3.0。后者的意思是这个project配置的gradle构建版本为1.3.0，前者的意思是这个project使用的gradle的版本为2.4。我们会发现，如果我们修改前者，如果本地没有安装这个版本的gradle，会自动从gradle官网下载。但是，如果我们修改后者，它会自动从jcenter()仓库下载一些plugin之类的。 2、AS具体的安装和更新网上有许多的详细教程，我只想说以下三点。 Android Studio是Google官方基于IntelliJ IDEA开发的一款Android应用开发工具,绝逼比Eclipse强大，还没有转的尽快吧: 关闭AndroidStudio的自检升级，如果准备好升级还是自己选择想升级的版本升级靠谱； 升级前导出AndroidStudio的配置文件settings.jar(C:\\Users\\Administrator.AndroidStudio1.4\\config目录下，或者操作File|Export Setings导出)，升级后导入Settings.jar，这样就不需要重新配置，有必要的话给自己备份一个，说不定老天无缘无故挂了重装很方便。 具体细节的配置可以阅读，强烈建议直接打开AS的设置窗口，多转几次就熟悉了里边的各种配置啦。也可以参考这边文章，（1.4版本，有点旧了，差不多够用）打造你的开发工具，settings必备 二、Gradle1 简述Groovy语言Groovy是一种开发语言，是在Java平台上的，具有向Python，Ruby语言特性的灵活动态语言,Groovy保重了这些特性像Java语法一样被Java开发者使用。编译最终都会转成java的.class文件。他们的关系如下图。我想这大概也是Gradle构建系统为什么要选择Groovy的原因，它具有java语言的特性，开发者容易理解使用。一定要明白我们在build.gradle里边不是简单的配置，而是直接的逻辑开发。如果你熟练掌握Groovy，那么你在build.grale里边可以做任何你想做的事。 2 Gradle编程框架Gradle是一个工具，同时它也是一个编程框架。使用这个工具可以完成app的编译打包等工作，也可以干别的工作！Gradle里边有许多不同的插件，对应不同的工程结构、打包方式和输出文件类型。我们经常使用到的便是maven\\java\\com.android.application\\android-library等。当按照要求配置好gradle的环境后，执行gradle的task，便会自动编译打包输出你想要的.apk.aar.jar文件,如果你足够牛逼，你有gradle就够了，直接拿记事本开发； 如下图，是Gradle的工作流程。 Initializtion 初始化，执行settings.gradle(我们看到都是include”,实际里边可深了） Hook 通过API来添加，这中间我们可以自己编程干些自己想做的事情 Configuration 解析每个project的build.gradle，确定project以及内部Task关系，形成一个有向图 Execution 执行任务，输入命令 gradle xxx ,按照顺序执行该task的所有依赖以自己本身 3 关于gradle的task每个构建由一个或者多个project构成，一个project代表一个jar，一个moudle等等。一个project包含若干个task，包含多少由插件决定，而每一个task就是更细的构建任务，比如创建一个jar、生成Javadoc、上传aar到maven仓库。我们可以通过执行如下命令查看所有的task: gradle tasks --all 当然，我们也可以在AS中可以看到所有的task，双击就可以执行单个的task. 当然，我们也可以在build.gradle中写自己的task。关于详细的task介绍可以查看网络资料进行学习，推荐Gradle入门系列，基本花上半天到一天的时候简单的过一遍就有一个大概的了解。 4 Gradle环境下Android的文件结构 project-name gradle module-name build //构建生成文件 intermediates//构建打包的资源文件 assets//资源文件 exploded-aar//如果我们依赖了许多的aar或者依赖工程，最终都“copy”到了这个目录下 mainfests//合并的mainfest outputs apk//输出我们需要的.apk文件 lint-results.html//lint检查报告 reports tests//单元测试报告 ivy.xml//moudle的配置（task任务）、依赖关系等 libs //本地的依赖jar包等 src //本moudule所有的代码和资源文件 androidTest //需要android环境的单元测试，比如UI的单元测试 Test //普通的java单元测试 main //主渠道 java //java code jni //navtive jni so gen res assets AndroidManifest.xml +build.gradle //module build.gradle // for all module gradle.propeties //全局配置文件 local.properties //SDK、NDK配置 config.gradle//自定义的配置文件 settings.gradle//module管理 6 关于几个buid.gradle、gradle.propeties文件 build.gradle文件(主工程的Top-level) apply from:\"config.gradle\"//可以给所有的moudle引入一个配置文件buildscript &#123; repositories &#123; jcenter()&#125;dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter()//引入远程仓库 maven &#123; url MAVEN_URL &#125;//引入自己的私有maven仓库 &#125;&#125; gradle.properties(全局配置文件） # This can really make a significant difference if you are building a very complex project with many sub-module dependencies:#sub-moudle并行构建org.gradle.parallel=true#后台进程构建org.gradle.daemon=true#私有maven仓库地址MAVEN_URL= http://xxx.xx.1.147:8081/nexus/content/repositories/thirdparty/ build.gradle(module) apply plugin: 'com.android.application'//插件 决定是apk\\aar\\jar等android &#123;compileSdkVersion 23buildToolsVersion \"24.0.0\"// 此处注释保持默认打开，关闭后可使不严格的图片可以通过编译,但会导致apk包变大//aaptOptions.cruncherEnabled = false//aaptOptions.useNewCruncher = false packagingOptions &#123; exclude 'META-INF/NOTICE.txt'// 这里是具体的冲突文件全路径 exclude 'META-INF/LICENSE.txt'&#125;//默认配置defaultConfig &#123; applicationId \"com.locove.meet\" minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName \"1.0\" multiDexEnabled=true//65536问题&#125;sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs']//重新配置路径 &#125;&#125;buildTypes &#123; release &#123; // zipAlign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources false // 混淆 minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.releaseConfig &#125;&#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.google.code.gson:gson:2.2.+' testCompile 'junit:junit:4.12'&#125; 7 gradle编译文件和缓存文件 gradle缓存文件：C:\\Users\\Administrator.gradle\\caches\\modules-2\\files-2.1 idea缓存文件： C:\\Users\\Administrator.AndroidStudio1.4 三、构建过程简析这里参考了QQ音乐技术团队Android构建过程分析 下图是文章末尾的一张构建流程图： 解压合并资源： 主要是assets目录，res目录，Androidmainfest.xml目录。其中合并的时候会涉及到优先级的问题，详情请查看该篇文章。 AAPT(Android Asset Packaging Tool)打包 R.java文件 资源ID app.ap 压缩包 对png图进行优化等 源码编译： 生成.class字节码，在这里可以进行删除无用类，字节码优化，重命名（包名），还有一点就是代码混淆。 生成dex、打包签名、zipalign","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Hiker Guide","slug":"Hiker中文使用教程","date":"2016-10-17T07:47:20.000Z","updated":"2016-10-25T03:55:53.303Z","comments":true,"path":"2016/10/17/Hiker中文使用教程/","link":"","permalink":"http://github.com/2016/10/17/Hiker中文使用教程/","excerpt":"Hiker An attractive, exquisite theme for Hexo. named “Hiker”, short for “HikerNews”. ☞ Live Preview | Hiker 中文版使用文档","text":"Hiker An attractive, exquisite theme for Hexo. named “Hiker”, short for “HikerNews”. ☞ Live Preview | Hiker 中文版使用文档 Installation Get it from GitHub $ git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker Enable Modify theme setting in _config.yml to hiker. # Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hiker Update $ cd themes/Hiker$ git pull ConfigurationTheme configuration example# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Header Menumenu: Home: / Archives: archives Categories: categories Tags: tags About: aboutrss: /atom.xmlsince: 2013# Set default keywords (Use a comma to separate)keywords: \"\"# Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.avatar: css/images/mylogo.jpg# Homepage# eg. home_background_image: css/images/home-bg.jpghome_background_image: css/images/home-bg.jpghome_logo_image: enable: false border: false url: css/images/homelogo.jpg# AboutPage backgroundabout_big_image: css/images/pose.jpg# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- category- tag- tagcloud- archive- recent_posts# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname:# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default# Article theme color# Available value:# random | orange | blue | red | green | blacktheme_color: random# display widgets at the bottom of index pages (pagination == 2)index_widgets:# - category# - tagcloud# - archive# widget behaviorarchive_type: 'monthly'show_count: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification:baidu_site_verification:qihu_site_verification:# Miscellaneousgoogle_analytics:gauges_analytics:twitter:google_plus:fb_admins:fb_app_id: menu - Navigation menu rss - RSS link excerpt_link - “Read More” link at the bottom of excerpted articles. false to hide the link. fancybox - Enable Fancybox sidebar - Sidebar style. You can choose left, right, bottom or false. widgets - Widgets displaying in sidebar google_analytics - Google Analytics ID favicon - Favicon path twitter - Twiiter ID google_plus - Google+ ID FeaturesHomepage backgroundYou could place the image file in YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images directory. and modify home_background_image in hiker/_config.yml. # Homepage# eg. home_background_image: css/images/home-bg.jpghome_background_image: css/images/home-bg.jpg If you DON’T want any image as your homepage background, just set home_background_image empty in hiker/_config.yml, then you have an default homepage with random decorative pattern. Code Highlight ThemeHiker use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hiker/_config.yml. # Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default Blog Theme ColorHiker provide five color themes for your blog. orange blue red green black You can modify theme_color in hiker/_config.yml. # Article theme color# Available value:# random | orange | blue | red | green | blacktheme_color: random Night modeJust for article reading. In article page, you can click the logo image of header to switch to Night mode. FancyboxHiker uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. ![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hiker provides 5 built-in widgets: category tag tagcloud archives recent_posts All of them are enabled by default. You can edit them in widget setting. Comment supportHiker has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to hiker hiker/_config.yml: # comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/tags/Hexo/"}],"keywords":[]},{"title":"Chrome自带的开发者工具进阶技巧","slug":"Chrome自带的开发者工具进阶技巧","date":"2016-09-28T10:50:00.000Z","updated":"2016-10-18T06:45:25.373Z","comments":true,"path":"2016/09/28/Chrome自带的开发者工具进阶技巧/","link":"","permalink":"http://github.com/2016/09/28/Chrome自带的开发者工具进阶技巧/","excerpt":"原文链接： Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain Chrome自带开发者工具。它的功能十分丰富，包括元素、网络、安全等等。今天我们主要介绍JavaScript控制台部分的功能。 我最早写代码的时候，也就是在JS控制台里输出一些服务器返回的内容，或者一些变量的值。但是后来通过一些深入的学习和了解，我发现Chrome的JS控制台原来还有这么多神奇的功能。 在这里我总结了一些特别有用的功能。要是你凑巧在Chrome里浏览这篇文章的话，现在就打开开发者工具，跟着随手试试吧！ 1.选取DOM元素要是你用过两天jQuery的话，一定对 $(&#39;.className&#39;) 或者 $(&#39;#id&#39;) 这种选择器不会陌生。上面这俩货分别是jQuery的类选择器和ID选择器。 在一个网页没有引入jQuery的情况下，在控制台里你也可以通过类似的方法选取DOM. 不管 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;) 还是 $(&#39;.class #id&#39;) 等类似的选择器，都相当于原生JS的document.querySelector(&#39;&#39;) 方法。这个方法返回第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;) 记得是两个\\$\\$符号来选择所有匹配规则的DOM元素。选择返回的结果是一个数组，可以通过数组的方法来访问其中的单个元素。 举个栗子 $$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。","text":"原文链接： Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain Chrome自带开发者工具。它的功能十分丰富，包括元素、网络、安全等等。今天我们主要介绍JavaScript控制台部分的功能。 我最早写代码的时候，也就是在JS控制台里输出一些服务器返回的内容，或者一些变量的值。但是后来通过一些深入的学习和了解，我发现Chrome的JS控制台原来还有这么多神奇的功能。 在这里我总结了一些特别有用的功能。要是你凑巧在Chrome里浏览这篇文章的话，现在就打开开发者工具，跟着随手试试吧！ 1.选取DOM元素要是你用过两天jQuery的话，一定对 $(&#39;.className&#39;) 或者 $(&#39;#id&#39;) 这种选择器不会陌生。上面这俩货分别是jQuery的类选择器和ID选择器。 在一个网页没有引入jQuery的情况下，在控制台里你也可以通过类似的方法选取DOM. 不管 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;) 还是 $(&#39;.class #id&#39;) 等类似的选择器，都相当于原生JS的document.querySelector(&#39;&#39;) 方法。这个方法返回第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;) 记得是两个\\$\\$符号来选择所有匹配规则的DOM元素。选择返回的结果是一个数组，可以通过数组的方法来访问其中的单个元素。 举个栗子 $$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。 2.一秒钟让Chrome变成所见即所得的编辑器你可能经常会困惑你到底能不能直接在浏览器里更改网页的文本内容。答案是肯定的，你可以只通过一行简单的指令把Chrome变成所见即所得的编辑器，直接在网页上随心所欲地删改文字。 你不需要再傻傻地右键审查元素，编辑源代码了。打开Chrome的开发者控制台，输入 document.body.contentEditable=true 然后奇迹就发生啦，你竟然可以在网页里直接编辑，或者随意拖动图片的位置了！要是你正在用Chrome现在就可以试试！ 3.获取某个DOM元素绑定的事件在调试的时候，你肯定需要知道某个元素上面绑定了什么触发事件。Chrome的开发者控制台可以让你很轻松地找到它们。 getEventListeners($(&#39;selector&#39;)) 方法以数组对象的格式返回某个元素绑定的所有事件。你可以在控制台里展开对象查看详细的内容。 要是你需要选择其中的某个事件，可以通过下面的方法来访问： getEventListeners($('selector')).eventName[0].listener 这里的 eventName 表示某种事件类型，例如： getEventListeners($('#firstName')).click[0].listener 上面的例子会返回ID为 firstName 元素绑定的click事件。 4.监测事件当你需要监视某个DOM触发的事件时，也可以用到控制台。例如下面这些方法： monitorEvents($(&#39;selector&#39;)) 会监测某个元素上绑定的所有事件，一旦该元素的某个事件被触发就会在控制台里显示出来。 monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;) 可以监听某个元素上绑定的具体事件。第二个参数代表事件类型的名称。例如 monitorEvents($(&#39;#firstName&#39;),&#39;click&#39;) 只监测ID为firstName的元素上的click事件。 monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….]) 同上。可以同时检测具体指定的多个事件类型。 unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 5.用计时器来获取某段代码块的运行时间通过 console.time(‘labelName’) 来设定一个计时器，其中的 labelName 是计时器的名称。通过console.timeEnd(‘labelName’) 方法来停止并输出某个计时器的时间。例如： console.time('myTime'); //设定计时器开始 - myTimeconsole.timeEnd('mytime'); //结束并输出计时时长 - myTime//输出: myTime:123.00 ms 再举一个通过计时器来计算代码块运行时间的例子： console.time('myTime'); //开始计时 - myTimefor(var i=0; i &lt; 100000; i++)&#123; 2+4+5;&#125;console.timeEnd('mytime'); //结束并输出计时时长 - myTime//输出 - myTime:12345.00 ms 6.以表格的形式输出数组假设我们有一个像下面这样的数组： var myArray=[&#123;a:1,b:2,c:3&#125;,&#123;a:1,b:2,c:3,d:4&#125;,&#123;k:11,f:22&#125;,&#123;a:1,b:2,c:3&#125;] 要是你直接在控制台里输入数组的名称，Chrome会以文本的形式返回一个数组对象。但你完全可以通过console.table(variableName) 方法来以表格的形式输出每个元素的值。例如下图： 7.通过控制台方法来检查元素你可以直接在控制台里输入下面的方法来检查元素 inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。例如 inspect($(&#39;#firstName&#39;)) 选择所有ID是 firstName 的元素，inspect($(&#39;a&#39;)[3]) 检查并返回页面上第四个 p元素。\\$0, \\$1, \\$2等等会返回你最近检查过的几个元素，例如 \\$0 会返回你最后检查的元素，\\$1 则返回倒数第二个。 8.列出某个元素的所有属性你也可以通过控制台列出某个元素的所有属性： dir($(‘selector’)) 会返回匹配选择器的DOM元素的所有属性，你可以展开输出的结果查看详细内容。 9.获取最后计算结果的值你可以把控制台当作计算器使用。当你在Chrome控制台里进行计算时，可以通过$_来获取最后的计算结果值，还是直接看例子吧： 2+3+49 //- The Answer of the SUM is 9$_9 // Gives the last Result$_ * $_81 // As the last Result was 9Math.sqrt($_)9 // As the last Result was 81$_9 // As the Last Result is 9 10.清空控制台输出当你需要这么做的时候，只需要输入 clear() 然后回车就好啦！ Chrome开发者工具的强大远远超出你的想象！这只是其中的一部分小技巧而已，希望能够帮到你！","categories":[],"tags":[{"name":"WebDevelopment","slug":"WebDevelopment","permalink":"http://github.com/tags/WebDevelopment/"}],"keywords":[]},{"title":"【Android】抽象布局 — include、merge 、ViewStub","slug":"【Android】抽象布局 — include、merge 、ViewStub","date":"2016-09-19T03:47:00.000Z","updated":"2016-10-18T04:55:28.728Z","comments":true,"path":"2016/09/19/【Android】抽象布局 — include、merge 、ViewStub/","link":"","permalink":"http://github.com/2016/09/19/【Android】抽象布局 — include、merge 、ViewStub/","excerpt":"在布局优化中，Androi的官方提到了这三种布局&lt;include/&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 一、布局重用&lt;include/&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下： &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; &lt;/LinearLayout&gt;","text":"在布局优化中，Androi的官方提到了这三种布局&lt;include/&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 一、布局重用&lt;include/&gt;&lt;include /&gt;标签能够重用布局文件，简单的使用如下： &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=\"@color/app_bg\" android:gravity=\"center_horizontal\"&gt; &lt;include layout=\"@layout/titlebar\"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=\"wrap_content\" android:text=\"@string/hello\" android:padding=\"10dp\" /&gt; &lt;/LinearLayout&gt; 1) &lt;include /&gt;标签必须使用单独的layout属性。 2) 可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖。 3) 在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。 4) 布局中可以包含两个相同的include标签，引用时可以使用如下方法解决 比如这个布局文件：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"android:layout_width=\"fill_parent\"android:layout_height=\"fill_parent\"android:scrollbars=\"vertical\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:orientation=\"vertical\" android:padding=\"10dip\" &gt; &lt;include android:id=\"@+id/discovered_servers\" layout=\"@layout/discovered_servers_element\" /&gt; &lt;include android:id=\"@+id/bookmarks\" layout=\"@layout/bookmarks_element\" /&gt; //注意以下这个include和上面的include &lt;include android:id=\"@+id/bookmarks_favourite\" layout=\"@layout/bookmarks_element\" /&gt; &lt;include android:id=\"@+id/new_conn\" layout=\"@layout/new_conn_element\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 这里我们include了两次res/layout/bookmarks_element.xml，这个子布局内容如下： &lt;!-- res/layout/bookmarks_element.xml 布局 --&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;TextView android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:paddingBottom=\"10dip\" android:paddingTop=\"10dip\" android:text=\"@string/bookmarks\" android:textAppearance=\"?android:attr/textAppearanceLarge\" /&gt; &lt;LinearLayout android:id=\"@+id/bookmarks_list\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:padding=\"10dip\" /&gt;&lt;/merge&gt; 如果向下面这样调用是错的， LinearLayout fav_bookmarks = findViewById(R.id.bookmarks_list); // WRONG!!!! 正确的方法是这样： View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite); bookmarks_container_2.findViewById(R.id.bookmarks_list); 二、减少视图层级&lt;merge/&gt;&lt;merge /&gt;标签用于减少View树的层次来优化Android的布局。先来用个例子演示一下： 首先主需要一个配置文件activity_main.xml &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt;&lt;/RelativeLayout&gt; 再来一个最简单的Activity，文件名MainActivity.java package com.example.merge;import android.app.Activity;import android.os.Bundle;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 按着上面的代码创建工程，运行后使用“DDMS -&gt; Dump View Hierarchy for UI Automator”工具，截图如下: merge 使用前： 最下面两层RelativeLayout与TextView就是 activity_main.xml 布局中的内容，上面的FrameLayout是Activity setContentView添加的顶层视图。下面使用merge标签可以查看下区别。 布局文件 activity_main.xml 修改内容如下： &lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt;&lt;/merge&gt; 使用“DDMS -&gt; Dump View Hierarchy for UI Automator”工具，截图如下: merge 使用后 可以看到，FrameLayout下面直接就是TextView，与之前的相比少了一层 RelativeLayout 而实现的效果相同。 那么，什么情况考虑使用&lt;merge /&gt;标签？ 一种是向上面的例子一样，子视图不需要指定任何针对父视图的布局属性，例子中TextView仅仅需要直接添加到父视图上用于显示就行。 另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题，官方文档 Android Layout Tricks #3: Optimize by merging 中的例子演示的就是这种情况。 &lt;merge /&gt;标签有什么限制没？ &lt;merge /&gt;只能作为XML布局的根标签使用。 当 Inflate 以&lt;merge /&gt;开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。 三、需要时使用&lt;ViewStub /&gt;限于篇幅，这里只大概总结一下ViewStub的使用方法，详细介绍和使用写到后面的文章中。 &lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下： &lt;ViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/panel_import\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法： ((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); or View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。 注：ViewStub 目前有个缺陷就是还不支持 &lt;merge /&gt; 标签。 更多&lt;ViewStub /&gt;标签介绍可以参考官网教程《Android Layout Tricks #3: Optimize with stubs》 【参考资料】： 1、Android抽象布局 — include、merge 、ViewStub2、Tech Stuff: Android &lt;include/&gt; layout pitfalls3、Android 性能优化 四 布局优化merge标签的使用4、Android之merge布局5、 Android实战技巧：ViewStub的应用","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】设计模式：深入理解单例模式","slug":"【Java】设计模式：深入理解单例模式","date":"2016-09-08T06:18:20.000Z","updated":"2016-10-18T04:56:48.874Z","comments":true,"path":"2016/09/08/【Java】设计模式：深入理解单例模式/","link":"","permalink":"http://github.com/2016/09/08/【Java】设计模式：深入理解单例模式/","excerpt":"什么是设计模式？简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，今天就先来分享下最常用的单例模式。 引言对于单例模式，有工作经验的人基本上都使用过。面试的时候提到设计模式基本上都会提到单例模式，但是很多人对单例模式也是一知半解，当然也包括我哈哈哈=_=。所以我们有必要深入理解一下所谓的「单例模式」。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式结构图： 使用单例的优点： 单例类只有一个实例 共享资源，全局使用 节省创建时间，提高性能","text":"什么是设计模式？简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，今天就先来分享下最常用的单例模式。 引言对于单例模式，有工作经验的人基本上都使用过。面试的时候提到设计模式基本上都会提到单例模式，但是很多人对单例模式也是一知半解，当然也包括我哈哈哈=_=。所以我们有必要深入理解一下所谓的「单例模式」。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式结构图： 使用单例的优点： 单例类只有一个实例 共享资源，全局使用 节省创建时间，提高性能 它的七种写法单例模式有多种写法各有利弊，现在我们来看看各种模式写法。 1、饿汉式public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 这种方式和名字很贴切，饥不择食，在类装载的时候就创建，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。 Java Runtime就是使用这种方式，它的源代码如下： public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don't let anyone else instantiate this class */ private Runtime() &#123;&#125; //以下代码省略&#125; 总结：「饿汉式」是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用「饿汉式」的单例模式就是不合适的，这时候就需要用到「懒汉式」的方式去按需延迟加载单例。 2、懒汉式（非线程安全）public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。在多线程访问的时候，很可能会造成多次实例化，就不再是单例了。 「懒汉式」与「饿汉式」的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用「懒汉式」就是非常不错的选择。 3、懒汉式（线程安全）public class Singleton &#123; private static Singleton instance; private Singleton ()&#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这两种「懒汉式」单例，名字起的也很贴切，一直等到对象实例化的时候才会创建，确实够懒，不用鞭子抽就不知道走了，典型的时间换空间，每次获取实例的时候才会判断，看是否需要创建，浪费判断时间，如果一直没有被使用，就不会被创建，节省空间。 因为这种方式在getInstance()方法上加了同步锁，所以在多线程情况下会造成线程阻塞，把大量的线程锁在外面，只有一个线程执行完毕才会执行下一个线程。 Android中的 InputMethodManager 使用了这种方式，我们看看它的源码： public final class InputMethodManager &#123; static InputMethodManager sInstance; /** * Retrieve the global InputMethodManager instance, creating it if it * doesn't already exist. * @hide */ public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 4、双重校验锁（DCL）上面的方法「懒汉式（线程安全）」毫无疑问存在性能的问题 — 如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！ 让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码，就成了下面的双重校验锁（Double Check Lock）： public class Singleton &#123; /** * 注意此处使用的关键字 volatile， * 被volatile修饰的变量的值，将不会被本地线程缓存， * 所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 */ private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这种写法在getSingleton()方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，不了解volatile关键字的可以查看 Java多线程（三）volatile域 和 java中volatile关键字的含义 两篇文章，可以看到双重检查模式是正确使用volatile关键字的场景之一。 「双重校验锁」：既可以达到线程安全，也可以使性能不受很大的影响，换句话说在保证线程安全的前提下，既节省空间也节省了时间，集合了「饿汉式」和两种「懒汉式」的优点，取其精华，去其槽粕。 对于volatile关键字，还是存在很多争议的。由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 还有就是在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java1.5及以上的版本。 5、静态内部类另外，在很多情况下JVM已经为我们提供了同步控制，比如： 在static {...}区块中初始化的数据 访问final字段时 因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现「懒汉式」的延迟加载和线程安全。 public class Singleton &#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125; &#125; 第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。 然而这还不是最简单的方式，《Effective Java》中作者推荐了一种更简洁方便的使用方式，就是使用「枚举」。 6、枚举《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 public enum Singleton &#123; //定义一个枚举的元素，它就是 Singleton 的一个实例 INSTANCE; public void doSomeThing() &#123; // do something... &#125; &#125; 使用方法如下： public static void main(String args[]) &#123; Singleton singleton = Singleton.instance; singleton.doSomeThing();&#125; 枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。 7. 使用容器public class SingletonManager &#123; private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;(); private Singleton() &#123; &#125; public static void registerService(String key, Objectinstance) &#123; if (!objMap.containsKey(key) ) &#123; objMap.put(key, instance) ; &#125; &#125; public static ObjectgetService(String key) &#123; return objMap.get(key) ; &#125;&#125; 这种事用SingletonManager 将多种单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。 总结对于以上七种单例，分别是「饿汉式」、「懒汉式(非线程安全)」、「懒汉式(线程安全)」、「双重校验锁」、「静态内部类」、「枚举」和「容器类管理」。很多时候取决人个人的喜好，虽然双重检查有一定的弊端和问题，但我就是钟爱双重检查，觉得这种方式可读性高、安全、优雅（个人观点）。所以代码里常常默写这样的单例，写的时候真感觉自己是个伟大的建筑师哈哈哈哈（真不要脸(￢_￢)（逃。 【参考资料】：1、Android设计模式之单例模式2、十分钟认识单例模式的多种姿势3、设计模式（二）单例模式的七种写法4、深入Java单例模式5、java中volatile关键字的含义","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://github.com/categories/Design-Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://github.com/categories/Design-Pattern/"}]},{"title":"【Go语言】基本类型排序和 slice 排序","slug":"【Go语言】基本类型排序和 slice 排序","date":"2016-09-07T08:36:00.000Z","updated":"2016-10-18T04:56:08.221Z","comments":true,"path":"2016/09/07/【Go语言】基本类型排序和 slice 排序/","link":"","permalink":"http://github.com/2016/09/07/【Go语言】基本类型排序和 slice 排序/","excerpt":"Go 是通过 sort 包提供排序和搜索，因为 Go 暂时不支持泛型（将来也不好说支不支持），所以，Go 的 sort 和 search 使用起来跟类型是有关的，或是需要像 c 一样写比较函数等，稍微显得也不是很方便。 引言 Go 的排序思路和 C 和 C++ 有些差别。 C 默认是对数组进行排序， C++ 是对一个序列进行排序， Go 则更宽泛一些，待排序的可以是任何对象， 虽然很多情况下是一个 slice (分片， 类似于数组)，或是包含 slice 的一个对象。 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； 乍一看条件 3 是多余的， c 和 c++ 都不提供 swap 。 c 的 qsort 的用法： qsort(data, n, sizeof(int), cmp_int); data 是起始地址， n 是元素个数， sizeof(int) 是每个元素的大小， cmp_int 是一个比较两个 int 的函数。 c++ 的 sort 的用法： sort(data, data+n, cmp_int); data 是第一个元素的位置， data+n 是最后一个元素的下一个位置， cmp_int 是比较函数。","text":"Go 是通过 sort 包提供排序和搜索，因为 Go 暂时不支持泛型（将来也不好说支不支持），所以，Go 的 sort 和 search 使用起来跟类型是有关的，或是需要像 c 一样写比较函数等，稍微显得也不是很方便。 引言 Go 的排序思路和 C 和 C++ 有些差别。 C 默认是对数组进行排序， C++ 是对一个序列进行排序， Go 则更宽泛一些，待排序的可以是任何对象， 虽然很多情况下是一个 slice (分片， 类似于数组)，或是包含 slice 的一个对象。 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； 乍一看条件 3 是多余的， c 和 c++ 都不提供 swap 。 c 的 qsort 的用法： qsort(data, n, sizeof(int), cmp_int); data 是起始地址， n 是元素个数， sizeof(int) 是每个元素的大小， cmp_int 是一个比较两个 int 的函数。 c++ 的 sort 的用法： sort(data, data+n, cmp_int); data 是第一个元素的位置， data+n 是最后一个元素的下一个位置， cmp_int 是比较函数。 基本类型排序(int、float64 和 string)1、升序排序对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。 package main import ( \"fmt\" \"sort\") func main() &#123; intList := [] int &#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := [] float64 &#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := [] string &#123;\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"&#125; sort.Ints(intList) sort.Float64s(float8List) sort.Strings(stringList) fmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList) &#125; 2、降序排序int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。 go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写： package main import ( \"fmt\" \"sort\") func main() &#123; intList := [] int &#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := [] float64 &#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := [] string &#123;\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"&#125; sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(float8List))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)&#125; 3、深入理解排序sort 包中有一个 sort.Interface 接口，该接口有三个方法 Len() 、 Less(i,j) 和 Swap(i,j) 。 通用排序函数 sort.Sort 可以排序任何实现了 sort.Inferface 接口的对象(变量)。对于 [] int 、[] float64 和 [] string 除了使用特殊指定的函数外，还可以使用改装过的类型 IntSclice 、 Float64Slice 和 StringSlice ， 然后直接调用它们对应的 Sort() 方法；因为这三种类型也实现了 sort.Interface 接口， 所以可以通过 sort.Reverse 来转换这三种类型的 Interface.Less 方法来实现逆向排序， 这就是前面最后一个排序的使用。 下面使用了一个自定义(用户定义)的 Reverse 结构体， 而不是 sort.Reverse 函数， 来实现逆向排序。 package main import ( \"fmt\" \"sort\") // 自定义的 Reverse 类型type Reverse struct &#123; sort.Interface // 这样，Reverse可以接纳任何实现了sort.Interface的对象&#125; // Reverse 只是将其中的 Inferface.Less 的顺序对调了一下func (r Reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i)&#125; func main() &#123; ints := []int&#123;5, 2, 6, 3, 1, 4&#125; sort.Ints(ints) // 特殊排序函数，升序 fmt.Println(\"after sort by Ints:\\t\", ints) doubles := []float64&#123;2.3, 3.2, 6.7, 10.9, 5.4, 1.8&#125; sort.Float64s(doubles) fmt.Println(\"after sort by Float64s:\\t\", doubles) // [1.8 2.3 3.2 5.4 6.7 10.9] strings := []string&#123;\"hello\", \"good\", \"students\", \"morning\", \"people\", \"world\"&#125; sort.Strings(strings) fmt.Println(\"after sort by Strings:\\t\", strings) // [good hello mornig people students world] ipos := sort.SearchInts(ints, -1) // int 搜索 fmt.Printf(\"pos of 5 is %d th\\n\", ipos) dpos := sort.SearchFloat64s(doubles, 20.1) // float64 搜索 fmt.Printf(\"pos of 5.0 is %d th\\n\", dpos) fmt.Printf(\"doubles is asc ? %v\\n\", sort.Float64sAreSorted(doubles)) doubles = []float64&#123;3.5, 4.2, 8.9, 100.98, 20.14, 79.32&#125; // sort.Sort(sort.Float64Slice(doubles)) // float64 排序方法 2 // fmt.Println(\"after sort by Sort:\\t\", doubles) // [3.5 4.2 8.9 20.14 79.32 100.98] (sort.Float64Slice(doubles)).Sort() // float64 排序方法 3 fmt.Println(\"after sort by Sort:\\t\", doubles) // [3.5 4.2 8.9 20.14 79.32 100.98] sort.Sort(Reverse&#123;sort.Float64Slice(doubles)&#125;) // float64 逆序排序 fmt.Println(\"after sort by Reversed Sort:\\t\", doubles) // [100.98 79.32 20.14 8.9 4.2 3.5]&#125; sort.Ints / sort.Float64s / sort.Strings 分别来对整型/浮点型/字符串型slice进行排序。然后是有个测试是否有序的函数。还有分别对应的 search 函数，不过，发现搜索函数只能定位到如果存在的话的位置，不存在的话，位置是不对的。 关于一般的数组排序，程序中显示了，有 3 种方法！目前提供的三种类型 int，float64 和 string 呈现对称的，也就是你有的，对应的我也有。关于翻转排序或是逆向排序，就是用个翻转结构体，重写 Less() 函数即可。上面的 Reverse 是个通用的结构体。 上面说了那么多， 只是对基本类型进行排序， 该到说说 struct 结构体类型的排序的时候了， 实际中这个用得到的会更多。 结构体类型的排序结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。 1、模拟 IntSlice 排序package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; // 按照 Person.Age 从大到小排序type PersonSlice [] Person func (a PersonSlice) Len() int &#123; // 重写 Len() 方法 return len(a)&#125;func (a PersonSlice) Swap(i, j int)&#123; // 重写 Swap() 方法 a[i], a[j] = a[j], a[i]&#125;func (a PersonSlice) Less(i, j int) bool &#123; // 重写 Less() 方法， 从大到小排序 return a[j].Age &lt; a[i].Age&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonSlice(people)) // 按照 Age 的逆序排序 fmt.Println(people) sort.Sort(sort.Reverse(PersonSlice(people))) // 按照 Age 的升序排序 fmt.Println(people) &#125; 这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。 这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。 2、封装成 Wrapperpackage main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; //注意此处 people [] Person by func(p, q * Person) bool&#125; func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;&#125;) fmt.Println(people) &#125; 这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。 3、进一步封装感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下： package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; people [] Person by func(p, q * Person) bool&#125; type SortBy func(p, q *Person) bool func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; // 封装成 SortPerson 方法func SortPerson(people [] Person, by SortBy)&#123; sort.Sort(PersonWrapper&#123;people, by&#125;)&#125; func main() &#123; people := [] Person&#123; &#123;\"zhang san\", 12&#125;, &#123;\"li si\", 30&#125;, &#123;\"wang wu\", 52&#125;, &#123;\"zhao liu\", 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) SortPerson(people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;) fmt.Println(people) &#125; 在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。 4、另一种思路package main import ( \"fmt\" \"sort\") type Person struct &#123; Name string Weight int&#125; type PersonSlice []Person func (s PersonSlice) Len() int &#123; return len(s) &#125;func (s PersonSlice) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125; type ByName struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByName 中 func (s ByName) Less(i, j int) bool &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125; // 将 Less 绑定到 ByName 上 type ByWeight struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByWeight 中func (s ByWeight) Less(i, j int) bool &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125; // 将 Less 绑定到 ByWeight 上 func main() &#123; s := []Person&#123; &#123;\"apple\", 12&#125;, &#123;\"pear\", 20&#125;, &#123;\"banana\", 50&#125;, &#123;\"orange\", 87&#125;, &#123;\"hello\", 34&#125;, &#123;\"world\", 43&#125;, &#125; sort.Sort(ByWeight&#123;s&#125;) fmt.Println(\"People by weight:\") printPeople(s) sort.Sort(ByName&#123;s&#125;) fmt.Println(\"\\nPeople by name:\") printPeople(s) &#125; func printPeople(s []Person) &#123; for _, o := range s &#123; fmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight) &#125;&#125; 对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。 参考资料：1、go语言的排序和搜索","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/tags/Go语言/"}],"keywords":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}]},{"title":"【Android 】TextView 局部文字变色","slug":"【Android 】TextView 局部文字变色","date":"2016-09-07T07:02:45.000Z","updated":"2016-12-22T05:06:00.866Z","comments":true,"path":"2016/09/07/【Android 】TextView 局部文字变色/","link":"","permalink":"http://github.com/2016/09/07/【Android 】TextView 局部文字变色/","excerpt":"TextView 对于富文本效果的实现支持不支持呢？比如“局部文字颜色的变动”，“局部字体的变动” 一、需求效果 二、解决方案针对这类问题，Android提供了 SpannableStringBuilder，方便我们自定义富文本的实现。 textView = (TextView) findViewById(R.id.textview);SpannableStringBuilder builder = new SpannableStringBuilder(textView.getText().toString());//ForegroundColorSpan 为文字前景色，BackgroundColorSpan为文字背景色ForegroundColorSpan redSpan = new ForegroundColorSpan(Color.RED);ForegroundColorSpan whiteSpan = new ForegroundColorSpan(Color.WHITE);ForegroundColorSpan blueSpan = new ForegroundColorSpan(Color.BLUE);ForegroundColorSpan greenSpan = new ForegroundColorSpan(Color.GREEN);ForegroundColorSpan yellowSpan = new ForegroundColorSpan(Color.YELLOW); builder.setSpan(redSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(whiteSpan, 1, 2, Spannable.SPAN_INCLUSIVE_INCLUSIVE);builder.setSpan(blueSpan, 2, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(greenSpan, 3, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(yellowSpan, 4,5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);textView.setText(builder);","text":"TextView 对于富文本效果的实现支持不支持呢？比如“局部文字颜色的变动”，“局部字体的变动” 一、需求效果 二、解决方案针对这类问题，Android提供了 SpannableStringBuilder，方便我们自定义富文本的实现。 textView = (TextView) findViewById(R.id.textview);SpannableStringBuilder builder = new SpannableStringBuilder(textView.getText().toString());//ForegroundColorSpan 为文字前景色，BackgroundColorSpan为文字背景色ForegroundColorSpan redSpan = new ForegroundColorSpan(Color.RED);ForegroundColorSpan whiteSpan = new ForegroundColorSpan(Color.WHITE);ForegroundColorSpan blueSpan = new ForegroundColorSpan(Color.BLUE);ForegroundColorSpan greenSpan = new ForegroundColorSpan(Color.GREEN);ForegroundColorSpan yellowSpan = new ForegroundColorSpan(Color.YELLOW); builder.setSpan(redSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(whiteSpan, 1, 2, Spannable.SPAN_INCLUSIVE_INCLUSIVE);builder.setSpan(blueSpan, 2, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(greenSpan, 3, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);builder.setSpan(yellowSpan, 4,5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);textView.setText(builder); 除了上述代码中使用的 ForegroundColorSpan 和 BackgroundColorSpan之外，还有以下这些Span可以使用： AbsoluteSizeSpan(int size) —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小 RelativeSizeSpan(float proportion) —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out) ScaleXSpan(float proportion) —— 缩放字体，与上面的类似，默认为1,设置后就是原来的乘以proportion，大于1时放大(zoon in)，小于时缩小(zoom out) BackgroundColorSpan(int color) —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int) ForegroundColorSpan(int color) —— 前景着色，也就是字的着色，参数与背景着色一致 TypefaceSpan(String family) —— 字体，参数是字体的名字比如“sans”, “sans-serif”等 StyleSpan(Typeface style) —— 字体风格，比如粗体，斜体，参数是android.graphics.Typeface里面定义的常量，如Typeface.BOLD，Typeface.ITALIC等等。StrikethroughSpan—-如果设置了此风格，会有一条线从中间穿过所有的字，就像被划掉一样 三、动手试试比如实现下图中TextView的样式 然后代码如下： TextView tv = (TextView)view.findViewById(R.id.toast_text);String str1 = \"提交成功！\\n积分\";String str2 = \"+\" + score1;String str3 = \"！审核通过后再\";String str4 = \"+\" + score2;SpannableStringBuilder builder = new SpannableStringBuilder(str1 + str2 + str3 + str4 + \"！\");builder.setSpan(new ForegroundColorSpan(Color.parseColor(\"#ffffa200\")), str1.length(), (str1 + str2).length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);builder.setSpan(new ForegroundColorSpan(Color.parseColor(\"#ffffa200\")), (str1 + str2 + str3).length(), (str1 + str2 + str3 + str4).length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);tv.setText(builder); 参考资料：1、Android-修改TextView中部分文字的颜色2、Android TextView 设置部分文字背景色和文字颜色","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】获取View的截图","slug":"【Android】获取View的截图","date":"2016-08-30T02:32:00.000Z","updated":"2016-10-18T04:55:33.990Z","comments":true,"path":"2016/08/30/【Android】获取View的截图/","link":"","permalink":"http://github.com/2016/08/30/【Android】获取View的截图/","excerpt":"引言 在Android应用开发过程中，可能会遇到需要对整个界面或者某一部分进行截图的需求。 Android中对View的截图也有以下两种方式，值得注意的是两个方法都不适用于SurfaceView： 使用DrawingCache如果使用DrawingCache，则对要截图的View有一个要求：View本身已经显示在界面上。如果View没有添加到界面上或者没有显示（绘制）过，则buildDrawingCache会失败。这种方式比较适合对应用界面或者某一部分的截图。步骤很简单： view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能","text":"引言 在Android应用开发过程中，可能会遇到需要对整个界面或者某一部分进行截图的需求。 Android中对View的截图也有以下两种方式，值得注意的是两个方法都不适用于SurfaceView： 使用DrawingCache如果使用DrawingCache，则对要截图的View有一个要求：View本身已经显示在界面上。如果View没有添加到界面上或者没有显示（绘制）过，则buildDrawingCache会失败。这种方式比较适合对应用界面或者某一部分的截图。步骤很简单： view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能 完整的截图功能函数如下： /** * 获取一个 View 的缓存视图 * * @param view * @return */ private Bitmap getCacheBitmapFromView(View view) &#123; final boolean drawingCacheEnabled = true; view.setDrawingCacheEnabled(drawingCacheEnabled); view.buildDrawingCache(drawingCacheEnabled); final Bitmap drawingCache = view.getDrawingCache(); Bitmap bitmap; if (drawingCache != null) &#123; bitmap = Bitmap.createBitmap(drawingCache); view.setDrawingCacheEnabled(false); &#125; else &#123; bitmap = null; &#125; return bitmap; &#125; 直接调用View.draw如果需要截图的View并没有添加到界面上，可能是通过java代码创建的或者inflate创建的，此时调用DrawingCache方法是获取不到位图的。因为View在添加到容器中之前并没有得到实际的大小（如果LayoutWidth是MatchParent，它还没有Parent…），所以首先需要指定View的大小： private void layoutView(View v, int width, int height) &#123; // validate view.width and view.height v.layout(0, 0, width, height); int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY); // validate view.measurewidth and view.measureheight v.measure(measuredWidth, measuredHeight); v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());i &#125; 使用方式如下： int viewWidth = webView.getMeasuredWidth(); int viewHeight = webView.getMeasuredHeight(); if (viewWidth &gt; 0 &amp;&amp; viewHeight &gt; 0) &#123; b = Bitmap.createBitmap(viewWidth, viewHeight, Config.ARGB_8888); Canvas cvs = new Canvas(b); webView.draw(cvs); &#125; 对于WebView的截图有一点特殊，网页内容并不能在布局完成后立即渲染出来，大概需要300ms的时间（对于不同性能的设备、网页复杂程度和Webkit版本可能不同）。 如果创建后台的WebView需要截图的话，应该在创建时就对其进行布局操作，这样加载完成后大部分就已经渲染完毕了（除非有异步的js处理）。 【参考资料】： 1、Android应用截图两种方法2、知乎和简书的夜间模式实现套路","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】如何加速 AndroidStudio 的编译效率","slug":"【Android】如何加速 AndroidStudio 的编译效率","date":"2016-08-26T07:20:00.000Z","updated":"2016-10-18T04:55:51.767Z","comments":true,"path":"2016/08/26/【Android】如何加速 AndroidStudio 的编译效率/","link":"","permalink":"http://github.com/2016/08/26/【Android】如何加速 AndroidStudio 的编译效率/","excerpt":"引言如果你之前用eclipse开发过Android app的话，转到android studio的第一反应也许就是：”编译速度有点慢“，表现的最明显的一点就是，每次android studio使用gradle编译，即便是更改的代码量很少，也会按照预先设置的task的顺序，依次走完编译的各项流程。这时候如果电脑CPU配置不高的时候，就会超级卡界面，更别说改代码了。 所以 这点就让人很痛苦， 然而问题总还是要被解决的，作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下)。 现在把如何优化gradle编译速度的方法记录在此，希望可以 帮助到广大的同行们。 准备工作首先，保证项目使用的Gradle是最新的，我这里用的是2.10版本。因为Gradle 2.4之后在编译效率上面有了一个非常大的提高，看下图官方的速度对比。","text":"引言如果你之前用eclipse开发过Android app的话，转到android studio的第一反应也许就是：”编译速度有点慢“，表现的最明显的一点就是，每次android studio使用gradle编译，即便是更改的代码量很少，也会按照预先设置的task的顺序，依次走完编译的各项流程。这时候如果电脑CPU配置不高的时候，就会超级卡界面，更别说改代码了。 所以 这点就让人很痛苦， 然而问题总还是要被解决的，作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下)。 现在把如何优化gradle编译速度的方法记录在此，希望可以 帮助到广大的同行们。 准备工作首先，保证项目使用的Gradle是最新的，我这里用的是2.10版本。因为Gradle 2.4之后在编译效率上面有了一个非常大的提高，看下图官方的速度对比。 然后先在你的项目build.gradle文件内(不是app里面的gradle文件), 就是这里： 添加一个task， 代码如下: task wrapper(type: Wrapper) &#123; gradleVersion = '2.10' //你安装的最新Gradle版本&#125; 加进去以后是这个样子： // Top-level build file where you can add configuration options common to all sub-projects/modules.// Running 'gradle wrapper' will generate gradlew - Getting gradle wrapper working and using it will save you a lot of pain.task wrapper(type: Wrapper) &#123; gradleVersion = '2.10'&#125;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0' &#125; ext &#123; compileSdkVersion = 21 buildToolsVersion =\"23.0.2\" minSdkVersion = 18 targetSdkVersion = 21 sourceCompatibility = JavaVersion.VERSION_1_7 targetCompatibility = JavaVersion.VERSION_1_7 &#125;&#125; 然后打开terminal, 输入./gradlew wrapper，Windows 下输入： gradlew wrapper 然后gradle就会自动去下载2.4版本,这也是官方推荐的手动设置gradle的方法 守护进程，并行编译通过以上步骤,我们设置好了 Android Studio 使用最新的 Gradle 版本，下一步就是正式开启优化之路了。我们需要将gradle作为守护进程一直在后台运行，这样当我们需要编译的时候，gradle就会立即跑过来然后 吭哧吭哧的开始干活。除了设置gradle一直开启之外，当你的工作空间存在多个project的时候，还需要设置gradle对这些projects并行编译，而不是单线的依次进行编译操作。 说了那么多， 那么怎么设置守护进程和并行编译呢？其实非常简单，gradle本身已经有了相关的配置选项，在你电脑的GRADLE_HOME这个环境变量所指的那个文件夹内，有一个.gradle/gradle.properties文件。 在这个文件里，放入下面两句话就OK了: org.gradle.daemon=trueorg.gradle.parallel=true 有一个地方需要注意的是,android studio 本身在编译的时候,已经是使用守护进程中的gradle了,那么这里加上了org.gradle.daemon=true就是保证了你在使用命令行编译apk的时候也是使用的守护进程. 你也可以将上述的配置文件放到你project中的根目录下,以绝对确保在任何情况下,这个project都会使用守护进程进行编译.不过有些特殊的情况下也许你应该注意守护进程的使用,具体的细节参考官网When should I not use the Gradle Daemon? 在使用并行编译的时候必须要注意的就是,你的各个project之间不要有依赖关系,否则的话,很可能因为你的Project A 依赖Project B, 而Project B还没有编译出来的时候,gradle就开始编译Project A 了.最终 导致编译失败.具体可以参考官网Multi-Project Building and Testing。 还有一些额外的gradle设置也许会引起你的兴趣,例如你想增加堆内存的空间,或者指定使用哪个jvm虚拟机等等(代码如下) org.gradle.jvmargs=-Xmx768morg.gradle.java.home=/path/to/jvm 如果你想详细的了解gradle的配置,请猛戳官网 Gradle User Guide。 【参考资料】：1、Boosting the performance for Gradle in your Android projects2、译文：优化android studio编译效率的方法3、How/when to generate Gradle wrapper files?","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Go】为什么 Go 语言把类型声明放在后面？","slug":"【Go】为什么 Go 语言把类型声明放在后面？","date":"2016-08-18T08:36:00.000Z","updated":"2016-10-18T04:56:04.881Z","comments":true,"path":"2016/08/18/【Go】为什么 Go 语言把类型声明放在后面？/","link":"","permalink":"http://github.com/2016/08/18/【Go】为什么 Go 语言把类型声明放在后面？/","excerpt":"关于类型，官网上有一段仔细地介绍了一下函数指针的部分，现在的设计比起 C 的语法，清晰很多。 也就是说，类型放在后面是为了更加清晰易懂。Rob Pike 曾经在 Go 官方博客解释过这个问题（查看原文：Go’s Declaration Syntax），简略翻译如下（水平有限翻译的不对的地方见谅）： 引言Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。 C 的语法首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如： int x; 上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明： int *p;int a[3];","text":"关于类型，官网上有一段仔细地介绍了一下函数指针的部分，现在的设计比起 C 的语法，清晰很多。 也就是说，类型放在后面是为了更加清晰易懂。Rob Pike 曾经在 Go 官方博客解释过这个问题（查看原文：Go’s Declaration Syntax），简略翻译如下（水平有限翻译的不对的地方见谅）： 引言Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。 C 的语法首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如： int x; 上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明： int *p;int a[3]; 指明了 p 是一个int类型的指针，因为 *p的类型为int。而 a 是一个 int 数组，因为 a[3]的类型为 int（别管这里出现的索引值，它只是用于指明数组的长度）。 我们接下来看看函数声明的情况。C 的函数声明中关于参数的类型是写在括号外的，像下面这样： int main(argc, argv) int argc; char *argv[];&#123; /* ... */ &#125; 如前所述，我们可以看到 main 之所以是函数，是因为表达式 main(argc, argv) 返回 int。在现代记法中我们是这么写的： int main(int argc, char *argv[]) &#123; /* ... */ &#125; 尽管看起来有些不同，但是基本的结构是一样的。 总的来看，当类型比较简单时，C的语法显得很聪明。但是遗憾的是一旦类型开始复杂，C的这套语法很快就能让人迷糊了。著名的例子如函数指针，我们得按下面这样来写： int (*fp)(int a, int b); 在这儿，fp 之所以是一个指针是因为如果你写出 (*fp)(a, b) 这样的表达式将会调用一个函数，其返回 int 类型的值。如果当 fp 的某个参数本身又是一个函数，情况会怎样呢？ int (*fp)(int (*ff)(int x, int y), int b) 这读起来可就点难了。 当然了，我们声明函数时是可以不写明参数的名称的，因此 main 函数可以声明为： int main(int, char *[]) 回想一下，之前 argv 是下面这样的 char *argv[] 你有没有发现你是从声明的「中间」去掉变量名而后构造出其变量类型的？尽管这不是很明显，但你声明某个 char *[]类型的变量的时候，竟然需要把名字插入到变量类型的中间。我们再来看看，如果我们不命名 fp 的参数会怎样： int (*fp)(int (*)(int, int), int) 这东西难懂的地方可不仅仅是要记得参数名原本是放这中间的 int (*)(int, int) 它更让人混淆的地方还在于甚至可能都搞不清这竟然是个函数指针声明。我们接着看看，如果返回值也是个函数指针类型又会怎么样 int (*(*fp)(int (*)(int, int), int))(int, int) 这已经很难看出是关于 fp 的声明了。 你自己还可以构建出比这更复杂的例子，但这已经足以解释 C 的声明语法引入的某些复杂性了。还有一点需要指出，由于类型语法和声明语法是一样的，要解析中间带有类型的表达式可能会有些难度。这也就是为什么，C 在做类型转换的时候总是要把类型用括号括起来的原因，像这样 (int)M_PI Go 的语法非C家族的语言通常在声明时使用一种不同的类型语法。一般是名字先出现，然后常常跟着一个冒号。按照这样来写，我们上面所举的例子就会变成下面这样： x: intp: pointer to inta: array[3] of int 这样的声明即便有些冗长，当至少是清晰的——你只需从左向右读就行。Go 语言所采用的方案就是以此为基础的，但为了追求简洁性，Go 语言丢掉了冒号并去掉了部分关键词，成了下面这样： x intp *inta [3]int 在 [3]int 和表达式中 a的用法没有直接的对应关系（我们在下一节会回过头来探讨指针的问题）。至此，你获得了代码清晰性方面的提升，但付出的代价是语法上需要区别对待。 下面我们来考虑函数的问题。虽然在 Go 语言里，main 函数实际上没有参数，但是我们先誊抄一下之前的 main 函数的声明： func main(argc int, argv *[]byte) int 粗略一看和 C 没什么不同，不过自左向右读的话还不错。main 函数接受一个 int 和一个指针并返回一个int。如果此时把参数名去掉，它还是很清楚——因为参数名总在类型的前面，所以不会引起混淆。 func main(int, *[]byte) int 这种自左向右风格的声明的一个价值在于，当类型变得更复杂时，它依然相对简单。下面是一个函数变量的声明（相当于 C 语言里的函数指针） f func(func(int,int) int, int) int 或者当它返回一个函数时： f func(func(int,int) int, int) func(int, int) int 上面的声明读起来还是很清晰，自左向右，而且究竟哪一个变量名是当前被声明的也容易看懂——因为变量名永远在首位。类型语法和表达式语法带来的差别使得在 Go 语言里调用闭包也变得更简单： sum := func(a, b int) int &#123; return a+b &#125; (3, 4) 指针指针有些例外。注意在数组 (array )和切片 (slice) 中，Go 的类型语法把方括号放在了类型的左边，但是在表达式语法中却又把方括号放到了右边： var a []intx = a[1] 类似的，Go 的指针沿用了 C 的 * 记法，但是我们写的时候也是声明时 在变量名右边，但在表达式中却又得把 放到左左边： var p *intx = *p 不能写成下面这样 var p *intx = p* 因为后缀的 * 可能会和乘法运算混淆，也许我们可以改用 Pascal 的 ^ 标记，像这样 var p ^intx = p^ 我们也许还真的应该把 * 像上面这样改成 ^ （当然这么一改 xor 运算的符号也得改），因为在类型和表达式中的 * 前缀确实把好些事儿都搞得有点复杂，举个例子来说，虽然我们可以像下面这样写 []int(\"hi\") 但在转换时，如果类型是以 * 开头的，就得加上括号： (*int)(nil) 如果有一天我们愿意放弃用 *作为指针语法的话，那么上面的括号就可以省略了。 可见，Go 的指针语法是和 C 相似的。但这种相似也意味着我们无法彻底避免在文法中有时为了避免类型和表达式的歧义需要补充括号的情况。 总而言之，尽管存在不足，但我们相信 Go 的类型语法要比 C 的容易懂。特别是当类型比较复杂时。 我擦，这边文章被知识库收录而且上了首页，吓死宝宝了。赶紧改个Bug压压惊=_=","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/tags/Go语言/"}],"keywords":[{"name":"Go语言","slug":"Go语言","permalink":"http://github.com/categories/Go语言/"}]},{"title":"【Machine Learning】机器学习：简明入门指南","slug":"【Machine Learning】机器学习：简明入门指南","date":"2016-08-14T09:32:55.000Z","updated":"2016-10-18T04:57:03.883Z","comments":true,"path":"2016/08/14/【Machine Learning】机器学习：简明入门指南/","link":"","permalink":"http://github.com/2016/08/14/【Machine Learning】机器学习：简明入门指南/","excerpt":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。","text":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。 何为机器学习？机器学习这个概念认为，对于待解问题，你无需编写任何专门的程序代码，遗传算法（generic algorithms）能够在数据集上为你得出有趣的答案。对于遗传算法，不用编码，而是将数据输入，它将在数据之上建立起它自己的逻辑。 举个例子，有一类算法称为分类算法，它可以将数据划分为不同的组别。一个用来识别手写数字的分类算法，不用修改一行代码，就可以用来将电子邮件分为垃圾邮件和普通邮件。算法没变，但是输入的训练数据变了，因此它得出了不同的分类逻辑。 机器学习算法是个黑盒，可以重用来解决很多不同的分类问题。 “机器学习”是一个涵盖性术语，覆盖了大量类似的遗传算法。 两类机器学习算法你可以认为机器学习算法分为两大类：监督式学习（Supervised Learning）和非监督式学习（Unsupervised Learning）。两者区别很简单，但却非常重要。 监督式学习假设你是一名房产经纪，生意越做越大，因此你雇了一批实习生来帮你。但是问题来了——你可以看一眼房子就知道它到底值多少钱，实习生没有经验，不知道如何估价。 为了帮助你的实习生（也许是为了解放你自己去度个假），你决定写个小软件，可以根据房屋大小、地段以及类似房屋的成交价等因素来评估你所在地区房屋的价值。 你把3个月来城里每笔房屋交易都写了下来，每一单你都记录了一长串的细节——卧室数量、房屋大小、地段等等。但最重要的是，你写下了最终的成交价： 这是我们的“训练数据”: 我们要利用这些训练数据来编写一个程序来估算该地区其他房屋的价值： 这就称为监督式学习。你已经知道每一栋房屋的售价，换句话说，你知道问题的答案，并可以反向找出解题的逻辑。 为了编写软件，你将包含每一套房产的训练数据输入你的机器学习算法。算法尝试找出应该使用何种运算来得出价格数字。 这就像是算术练习题，算式中的运算符号都被擦去了：天哪！一个阴险的学生将老师答案上的算术符号全擦去了。 看了这些题，你能明白这些测验里面是什么样的数学问题吗？你知道，你应该对算式左边的数字“做些什么”以得出算式右边的答案。 在监督式学习中，你是让计算机为你算出数字间的关系。而一旦你知道了解决这类特定问题所需要的数学方法后，你就可以解答同类的其它问题了。 非监督式学习让我们回到开头那个房地产经纪的例子。要是你不知道每栋房子的售价怎么办？即使你所知道的只是房屋的大小、位置等信息，你也可以搞出很酷的花样。这就是所谓的非监督式学习。 即使你不是想去预测未知的数据（如价格），你也可以运用机器学习完成一些有意思的事。 这就有点像有人给你一张纸，上面列出了很多数字，然后对你说:“我不知道这些数字有什么意义，也许你能从中找出规律或是能将它们分类，或是其它什么-祝你好运！” 你该怎么处理这些数据呢？首先，你可以用个算法自动地从数据中划分出不同的细分市场。也许你会发现大学附近的买房者喜欢户型小但卧室多的房子，而郊区的买房者偏好三卧室的大户型。这些信息可以直接帮助你的营销。 你还可以作件很酷的事，自动找出房价的离群数据，即与其它数据迥异的值。这些鹤立鸡群的房产也许是高楼大厦，而你可以将最优秀的推销员集中在这些地区，因为他们的佣金更高。 本文余下部分我们主要讨论监督式学习，但这并不是因为非监督式学习用处不大或是索然无味。实际上，随着算法改良，不用将数据和正确答案联系在一起，因此非监督式学习正变得越来越重要。 老学究请看:还有很多其它种类的机器学习算法。但初学时这样理解不错了。 太酷了，但是评估房价真能被看作“学习”吗？作为人类的一员，你的大脑可以应付绝大多数情况，并且没有任何明确指令也能够学习如何处理这些情况。如果你做房产经纪时间很长，你对于房产的合适定价、它的最佳营销方式以及哪些客户会感兴趣等等都会有一种本能般的“感觉”。强人工智能（Strong AI）研究的目标就是要能够用计算机复制这种能力。 但是目前的机器学习算法还没有那么好——它们只能专注于非常特定的、有限的问题。也许在这种情况下，“学习”更贴切的定义是“在少量范例数据的基础上找出一个等式来解决特定的问题”。 不幸的是，“机器在少量范例数据的基础上找出一个等式来解决特定的问题”这个名字太烂了。所以最后我们用“机器学习”取而代之。 当然，要是你是在50年之后来读这篇文章，那时我们已经得出了强人工智能算法，而本文看起来就像个老古董。未来的人类，你还是别读了，叫你的机器仆人给你做份三明治吧。 让我们写代码吧!前面例子中评估房价的程序，你打算怎么写呢？往下看之前，先思考一下吧。 如果你对机器学习一无所知，很有可能你会尝试写出一些基本规则来评估房价，如下： def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # In my area, the average house costs $200 per sqft price_per_sqft = 200 if neighborhood == \"hipsterton\": # but some areas cost a bit more price_per_sqft = 400 elif neighborhood == \"skid row\": # and some areas cost less price_per_sqft = 100 # start with a base price estimate based on how big the place is price = price_per_sqft * sqft # now adjust our estimate based on the number of bedrooms if num_of_bedrooms == 0: # Studio apartments are cheap price = price — 20000 else: # places with more bedrooms are usually # more valuable price = price + (num_of_bedrooms * 1000) return price 假如你像这样瞎忙几个小时，也许会取得一点成效，但是你的程序永不会完美，而且当价格变化时很难维护。 如果能让计算机找出实现上述函数功能的办法，这样岂不更好？只要返回的房价数字正确，谁会在乎函数具体干了些什么呢？ def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = &lt;computer, plz do some math for me&gt; return price 考虑这个问题的一种角度是将房价看做一碗美味的汤，而汤中成分就是卧室数、面积和地段。如果你能算出每种成分对最终的价格有多大影响，也许就能得到各种成分混合起来形成最终价格的具体比例。 这样可以将你最初的程序（全是疯狂的if else语句）简化成类似如下的样子： def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * .841231951398213 # and a big pinch of that price += sqft * 1231.1231231 # maybe a handful of this price += neighborhood * 2.3242341421 # and finally, just a little extra salt for good measure price += 201.23432095 return price 请注意那些用粗体标注的神奇数字——.841231951398213, 1231.1231231,2.3242341421, 和201.23432095。它们称为权重。如果我们能找出对每栋房子都适用的完美权重，我们的函数就能预测所有的房价！ 找出最佳权重的一种笨办法如下所示： 步骤1：首先，将每个权重都设为1.0： def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * 1.0 # and a big pinch of that price += sqft * 1.0 # maybe a handful of this price += neighborhood * 1.0 # and finally, just a little extra salt for good measure price += 1.0 return price 步骤2：将每栋房产带入你的函数运算，检验估算值与正确价格的偏离程度： 运用你的程序预测房屋价格。 例如：上表中第一套房产实际成交价为25万美元，你的函数估价为17.8万，这一套房产你就差了7.2万。 再将你的数据集中的每套房产估价偏离值平方后求和。假设数据集中有500套房产交易，估价偏离值平方求和总计为86,123,373美元。这就反映了你的函数现在的“正确”程度。 现在，将总计值除以500，得到每套房产的估价偏离平均值。将这个平均误差值称为你函数的代价。 如果你能调整权重使得这个代价变为0，你的函数就完美了。它意味着，根据输入的数据，你的程序对每一笔房产交易的估价都是分毫不差。而这就是我们的目标——尝试不同的权重值以使代价尽可能的低。 步骤3：不断重复步骤2，尝试所有可能的权重值组合。哪一个组合使得代价最接近于0，它就是你要使用的，你只要找到了这样的组合，问题就得到了解决! 思想扰动时间这太简单了，对吧？想一想刚才你做了些什么。你取得了一些数据，将它们输入至三个通用的简单步骤中，最后你得到了一个可以对你所在区域的房屋进行估价的函数。房价网，要当心咯！但是下面的事实可能会扰乱你的思想： 1.过去40年来，很多领域（如语言学/翻译学）的研究表明，这种通用的“搅动数据汤”（我编造的词）式的学习算法已经胜过了需要利用真人明确规则的方法。机器学习的“笨”办法最终打败了人类专家。 2.你最后写出的函数真是笨，它甚至不知道什么是“面积”和“卧室数”。它知道的只是搅动，改变数字来得到正确的答案。 3.很可能你都不知道为何一组特殊的权重值能起效。所以你只是写出了一个你实际上并不理解却能证明的函数。 4.试想一下，你的程序里没有类似“面积”和“卧室数”这样的参数，而是接受了一组数字。假设每个数字代表了你车顶安装的摄像头捕捉的画面中的一个像素，再将预测的输出不称为“价格”而是叫做“方向盘转动度数”，这样你就得到了一个程序可以自动操纵你的汽车了！ 太疯狂了，对吧？ 步骤3中的“尝试每个数字”怎么回事？好吧，当然你不可能尝试所有可能的权重值来找到效果最好的组合。那可真要花很长时间，因为要尝试的数字可能无穷无尽。 为避免这种情况，数学家们找到了很多聪明的办法（比如Gradient descent算法）来快速找到优秀的权重值，而不需要尝试过多。下面是其中一种： 首先，写出一个简单的等式表示前述步骤2，这是你的代价函数： 接着，让我们将这同一个等式用机器学习的数学术语（现在你可以忽略它们）进行重写： θ表示当前的权重值。 J(θ) 意为“当前权重值对应的代价”。 这个等式表示我们的估价程序在当前权重值下偏离程度的大小。如果将所有赋给卧室数和面积的可能权重值以图形形式显示，我们会得到类似下图的图表： 代价函数的图形像一支碗。纵轴表示代价。 图中蓝色的最低点就是代价最低的地方——即我们的程序偏离最小。最高点意味着偏离最大。所以，如果我们能找到一组权重值带领我们到达图中的最低点，我们就找到了答案！ 因此，我们只需要调整权重值使我们在图上能向着最低点“走下坡路”。如果对于权重的细小调节能一直使我们保持向最低点移动，那么最终我们不用尝试太多权重值就能到达那里。 如果你还记得一点微积分的话，你也许记得如果你对一个函数求导，结果会告诉你函数在任一点的斜率。换句话说，对于图上给定一点，它告诉我们那条路是下坡路。我们可以利用这一点朝底部进发。 所以，如果我们对代价函数关于每一个权重求偏导，那么我们就可以从每一个权重中减去该值。这样可以让我们更加接近山底。一直这样做，最终我们将到达底部，得到权重的最优值。（读不懂？不用担心，接着往下读）。 这种找出最佳权重的办法被称为批量梯度下降，上面是对它的高度概括。如果想搞懂细节，不要害怕，继续深入下去吧。 当你使用机器学习算法库来解决实际问题，所有这些都已经为你准备好了。但明白一些具体细节总是有用的。 还有什么你随便就略过了？上面我描述的三步算法被称为多元线性回归。你估算等式是在求一条能够拟合所有房价数据点的直线。然后，你再根据房价在你的直线上可能出现的位置用这个等式来估算从未见过的房屋的价格。这个想法威力强大，可以用它来解决“实际”问题。 但是，我为你展示的这种方法可能在简单的情况下有效，它不会在所有情况下都有用。原因之一是因为房价不会一直那么简单地跟随一条连续直线。 但是，幸运的是，有很多办法来处理这种情况。对于非线性数据，很多其他类型的机器学习算法可以处理（如神经网络或有核向量机）。还有很多方法运用线性回归更灵活，想到了用更复杂的线条来拟合。在所有的情况中，寻找最优权重值这一基本思路依然适用。 还有，我忽略了过拟合的概念。很容易碰上这样一组权重值，它们对于你原始数据集中的房价都能完美预测，但对于原始数据集之外的任何新房屋都预测不准。这种情况的解决之道也有不少（如正则化以及使用交叉验证数据集）。学会如何处理这一问题对于顺利应用机器学习至关重要。 换言之，基本概念非常简单，要想运用机器学习得到有用的结果还需要一些技巧和经验。但是，这是每个开发者都能学会的技巧。 机器学习法力无边吗？一旦你开始明白机器学习技术很容易应用于解决貌似很困难的问题（如手写识别），你心中会有一种感觉，只要有足够的数据，你就能够用机器学习解决任何问题。只需要将数据输入进去，就能看到计算机变戏法一样找出拟合数据的等式。 但是很重要的一点你要记住，机器学习只能对用你占有的数据实际可解的问题才适用。 例如，如果你建立了一个模型来根据每套房屋内盆栽数量来预测房价，它就永远不会成功。房屋内盆栽数量和房价之间没有任何的关系。所以，无论它怎么去尝试，计算机也推导不出两者之间的关系。 你只能对实际存在的关系建模。 怎样深入学习机器学习我认为，当前机器学习的最大问题是它主要活跃于学术界和商业研究组织中。对于圈外想要有个大体了解而不是想成为专家的人们，简单易懂的学习资料不多。但是这一情况每一天都在改善。 吴恩达教授（Andrew Ng）在Coursera上的机器学习免费课程非常不错。我强烈建议由此入门。任何拥有计算机科学学位、还能记住一点点数学的人应该都能理解。 另外，你还可以下载安装SciKit-Learn，用它来试验成千上万的机器学习算法。它是一个python框架，对于所有的标准算法都有“黑盒”版本。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/tags/Machine-Learning/"}],"keywords":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}]},{"title":"【Machine Learning】Github上关注最多的53个深度学习项目","slug":"【Machine Learning】Github上关注最多的53个深度学习项目","date":"2016-08-12T07:22:00.000Z","updated":"2016-10-18T04:56:59.609Z","comments":true,"path":"2016/08/12/【Machine Learning】Github上关注最多的53个深度学习项目/","link":"","permalink":"http://github.com/2016/08/12/【Machine Learning】Github上关注最多的53个深度学习项目/","excerpt":"Top Deep Learning ProjectsA list of popular github projects related to deep learning (ranked by stars). Last Update: 2016.08.09","text":"Top Deep Learning ProjectsA list of popular github projects related to deep learning (ranked by stars). Last Update: 2016.08.09 Project Name Stars Description TensorFlow 29622 Computation using data flow graphs for scalable machine learning. Caffe 11799 Caffe: a fast open framework for deep learning. Neural Style 10148 Torch implementation of neural style algorithm. Deep Dream 9042 Deep Dream. Keras 7502 Deep Learning library for Python. Convnets, recurrent neural networks, and more. Runs on Theano and TensorFlow. Roc AlphaGo 7170 An independent, student-led replication of DeepMind’s 2016 Nature publication, “Mastering the game of Go with deep neural networks and tree search” (Nature 529, 484-489, 28 Jan 2016). TensorFlow Models 6671 Models built with TensorFlow Neural Doodle 6275 Turn your two-bit doodles into fine artworks with deep neural networks, generate seamless textures from photos, transfer style from one image to another, perform example-based upscaling, but wait… there’s more! (An implementation of Semantic Style Transfer.) CNTK 5957 Computational Network Toolkit (CNTK). TensorFlow Examples 5872 TensorFlow tutorials and code examples for beginners. ConvNet JS 5231 Deep Learning in Javascript. Train Convolutional Neural Networks (or ordinary ones) in your browser. Torch 5133 Torch7, Deep Learning Library. OpenFace 4855 Face recognition with deep neural networks. MXNet 4685 Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Scala, Go, Javascript and more. Nupic 4364 Numenta Platform for Intelligent Computing: a brain-inspired machine intelligence platform, and biologically accurate neural network based on cortical learning algorithms. Theano 4286 Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently. It can use GPUs and perform efficient symbolic differentiation. Leaf 4281 Open Machine Intelligence Framework for Hackers. Char RNN 3820 Multi-layer Recurrent Neural Networks (LSTM, GRU, RNN) for character-level language models in Torch. Neural Talk 3694 NeuralTalk is a Python+numpy project for learning Multimodal Recurrent Neural Networks that describe images with sentences. deeplearning4j 3673 Deep Learning for Java, Scala &amp; Clojure on Hadoop, Spark. TFLearn 3368 Deep learning library featuring a higher-level API for TensorFlow. TensorFlow Playground 3352 Play with neural networks! OpenAI Gym 3020 A toolkit for developing and comparing reinforcement learning algorithms. Magenta 2914 Magenta: Music and Art Generation with Machine Intelligence Colornet 2798 Neural Network to colorize grayscale images. Synaptic 2666 architecture-free neural network library for node.js and the browser Neural Talk 2 2550 Efficient Image Captioning code in Torch, runs on GPU. Image Analogies 2540 Generate image analogies using neural matching and blending. TensorFlow Tutorials 2413 From the basics to slightly more interesting applications of Tensorflow. Lasagne 2355 Lightweight library to build and train neural networks in Theano. PyLearn2 2153 A Machine Learning library based on Theano. LISA-lab Deep Learning Tutorials 2134 Deep Learning Tutorial notes and code. See the wiki for more info. Neon 2121 Fast, scalable, easy-to-use Python based Deep Learning Framework by Nervana™. Matlab Deep Learning Toolbox 2032 Matlab/Octave toolbox for deep learning. Includes Deep Belief Nets, Stacked Autoencoders, Convolutional Neural Nets, Convolutional Autoencoders and vanilla Neural Nets. Each method has examples to get you started. Deep Learning Flappy Bird 1721 Flappy Bird hack using Deep Reinforcement Learning (Deep Q-learning). Chainer 1573 A flexible framework of neural networks for deep learning. Neural Story Teller 1514 A recurrent neural network for generating little stories about images. DIGITS 1353 Deep Learning GPU Training System. Deep Jazz 1229 Deep learning driven jazz generation using Keras &amp; Theano! Brainstorm 1143 Fast, flexible and fun neural networks. Darknet 937 Open Source Neural Networks in C Theano Tutorials 904 Bare bones introduction to machine learning from linear regression to convolutional neural networks using Theano. RNN Music Composition 904 A recurrent neural network designed to generate classical music. Blocks 866 A Theano framework for building and training neural networks. TDB 860 Interactive, node-by-node debugging and visualization for TensorFlow. Scikit Neural Net 849 Deep neural networks without the learning cliff! Classifiers and regressors compatible with scikit-learn. Veles 760 Distributed machine learning platform (Python, CUDA, OpenCL) Deep Detect 759 Deep Learning API and Server in C++11 with Python bindings and support for Caffe. TensorFlow DeepQ 759 A deep Q learning demonstration using Google Tensorflow. Caffe on Spark 724 Caffe On Spark. Nolearn 702 Abstractions around neural net libraries, most notably Lasagne. DCGAN TensorFlow 568 A tensorflow implementation of Deep Convolutional Generative Adversarial Networks MatConvNet 479 MATLAB CNN toolbox for computer vision applications. DeepCL 413 OpenCL library to train deep convolutional neural networks. 中文版 项 目 名 称 Stars 项目介绍 TensorFlow 29622 使用数据流图计算可扩展机器学习问题 Caffe 11799 Caffe是一个高效的开源深度学习框架 Neural Style 10148 Torch实现的神经网络算法 Deep Dream 9042 Deep Dream，一款图像识别工具 Keras 7502 一款Python实现的深度学习库，包括卷积神经网络、递归神经网络等。运行在Theano和TensorFlow之上。 Roc AlphaGo 7170 学生主导的一个独立项目，从新实现了 DeepMind在2016 Nature发表的内容， 《用深度神经网络和树搜索学习围棋》 (Nature 529, 484-489, 28 Jan 2016). TensorFlow Models 6671 基于TensorFlow开发的模型 Neural Doodle 6275 运用深度神经网络将涂鸦变为优雅的艺术品，从照片生成无缝纹理，转变图片风格，进行基于实例的提升，等等…还有更多！（语义风格传递的实现） CNTK 5957 计算网络工具（Computational Network Toolkit，CNTK） TensorFlow Examples 5872 初学者的TensorFlow教程和代码示例。 ConvNet JS 5231 基于Javascript的深度学习库。在浏览器中训练卷积神经网络模型（或者普通模型）。 Torch 5133 Torch7，深度学习库。 OpenFace 4855 基于深度学习网络的面部识别。 MXNet 4685 轻巧、便携、灵活的分布式/移动深度学习框架，支持Python, R, Julia, Scala, Go, Javascript等等语言。 Nupic 4364 智能计算的Numenta平台：一个脑启发式的计算智能和机器智能平台，基于皮层学习算法的生物精确神经网络模型。 Theano 4286 Theano 是一个 Python 库,用来定义、优化和模拟数学表达式计算,用于高效的解决多维数组的计算问题。 Leaf 4281 黑客的开源机器智能框架。 Char RNN 3820 多层递归神经网络的字符级别语言模型，基于Torch开发。 Neural Talk 3694 NeuralTalk是一个Python+numpy项目，用多模式递归神经网络描述图像。 deeplearning4j 3673 基于Hadoop和Spark的Java, Scala &amp; Clojure深度学习工具。 TFLearn 3368 深度学习库，包括高层次的TensorFlow接口。 TensorFlow Playground 3352 神经网络模型示例。 OpenAI Gym 3020 一种用于开发和比较强化学习算法的工具包。 Magenta 2914 Magenta: 音乐和艺术的生成与机器智能 Colornet 2798 用神经网络模型给灰度图上色。 Synaptic 2666 基于node.js和浏览器的免架构神经网络库。 Neural Talk 2 2550 Torch开发的图像简介生成代码，运行在GPU上。 Image Analogies 2540 使用神经匹配和融合生成相似图形。 TensorFlow Tutorials 2413 Tensorflow，从基础原理到应用。 Lasagne 2355 基于Theano训练和构建神经网络的轻型函数库。 PyLearn2 2153 基于Theano的机器学习库。 LISA-lab Deep Learning Tutorials 2134 深度学习教程笔记和代码。详情参见wiki页面。 Neon 2121 Nervana™开发的一款快速、可扩展、易上手的Python深度学习框架. Matlab Deep Learning Toolbox 2032 Matlab/Octave的深度学习工具箱。包括深度信念网络、自动编码机、卷积神经网络、卷积自动编码机和vanilla神经网络等。每种方法都有入门示例。 Deep Learning Flappy Bird 1721 使用深度强化学习破解Flappy Bird游戏(深度 Q-学习). Chainer 1573 一款灵活的深度学习神经网络框架。 Neural Story Teller 1514 看图讲故事的递归神经网络模型。 DIGITS 1353 深度学习GPU训练系统。 Deep Jazz 1229 基于Keras和Theano生成jazz的深度学习模型！ Brainstorm 1143 快速、灵活、有趣的神经网络。 Darknet 937 C语言版本的开源神经网络。 Theano Tutorials 904 基于Theano的机器学习入门教程，从线性回归到卷积神经网络。 RNN Music Composition 904 一款生成古典音乐的递归神经网络工具。 Blocks 866 用于构建和训练神经网络模型的Theano框架。 TDB 860 TensorFlow的交互式、节点调试和可视化的工具。 Scikit Neural Net 849 深度神经网络入门工具，类似scikit-learn的分类器和回归模型。 Veles 760 分布式机器学习平台(Python, CUDA, OpenCL) Deep Detect 759 基于C++11的深度学习接口和服务器，与Python绑定并支持Caffe。 TensorFlow DeepQ 759 基于Google Tensorflow的深度Q学习演示。 Caffe on Spark 724 基于Spark的Caffe。 Nolearn 702 神经网络库的抽象，著名的Lasagne。 DCGAN TensorFlow 568 基于tensorflow实现的深度卷积生成对抗网络。 DeepCL 413 用于训练深度卷积神经网络模型的OpenCL库。 来源：Top Deep Learning Projects","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/tags/Machine-Learning/"}],"keywords":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github.com/categories/Machine-Learning/"}]},{"title":"【Android】使用shape的同时，动态替换shape的颜色属性","slug":"【Android】使用shape的同时，动态替换shape的颜色属性","date":"2016-08-08T10:10:00.000Z","updated":"2016-10-18T04:55:58.087Z","comments":true,"path":"2016/08/08/【Android】使用shape的同时，动态替换shape的颜色属性/","link":"","permalink":"http://github.com/2016/08/08/【Android】使用shape的同时，动态替换shape的颜色属性/","excerpt":"在实现布局的时候，有些按钮形状相同，只是颜色有差异，如果使用自定义shape实现了其中一种按钮，有没有可能不需要再为其他每个颜色都写一个shape文件呢？ 一、问题比如以下这三个按钮： 为第一个灰色按钮自定义背景如下：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" android:color=\"@color/gray\"&gt; &lt;corners android:radius=\"60dip\"/&gt; &lt;stroke android:width=\"0dp\" android:color=\"@color/gray\" /&gt; &lt;solid android:color=\"@color/gray\" /&gt;&lt;/shape&gt; 然后，如果再为每个颜色的按钮都写一个shape背景也太麻烦，重用性太差。","text":"在实现布局的时候，有些按钮形状相同，只是颜色有差异，如果使用自定义shape实现了其中一种按钮，有没有可能不需要再为其他每个颜色都写一个shape文件呢？ 一、问题比如以下这三个按钮： 为第一个灰色按钮自定义背景如下：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" android:color=\"@color/gray\"&gt; &lt;corners android:radius=\"60dip\"/&gt; &lt;stroke android:width=\"0dp\" android:color=\"@color/gray\" /&gt; &lt;solid android:color=\"@color/gray\" /&gt;&lt;/shape&gt; 然后，如果再为每个颜色的按钮都写一个shape背景也太麻烦，重用性太差。 二、解决方法参考 stackoverflow 这里， 在java代码里使用 GradientDrawable 动态设置GradientDrawable myGrad = (GradientDrawable)rectangle.getBackground();myGrad.setColor(Color.BLACK); 【参考资料】1、How to change solid color from the code?","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"BAT人才体系的职位层级、薪酬、晋升标准","slug":"BAT人才体系的职位层级、薪酬、晋升标准大全","date":"2016-08-02T03:06:00.000Z","updated":"2016-10-25T08:26:53.661Z","comments":true,"path":"2016/08/02/BAT人才体系的职位层级、薪酬、晋升标准大全/","link":"","permalink":"http://github.com/2016/08/02/BAT人才体系的职位层级、薪酬、晋升标准大全/","excerpt":"互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？可以先看看这个话题百度、腾讯和阿里内部的级别和薪资待遇是什么样的？ ★ 腾讯 ★1、职级腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如： 产品/项目通道，简称P族技术通道，简称T族市场通道，简称M族职能通道，简称S族 以T族为例，分别为： T1：助理工程师 （一般为校招新人） T2：工程师 T3：高级工程师 3-1相当于阿里的p6+到p7（能力强可能到p7） T4：专家工程师 T5：科学家 T6：首席科学家","text":"互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？可以先看看这个话题百度、腾讯和阿里内部的级别和薪资待遇是什么样的？ ★ 腾讯 ★1、职级腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如： 产品/项目通道，简称P族技术通道，简称T族市场通道，简称M族职能通道，简称S族 以T族为例，分别为： T1：助理工程师 （一般为校招新人） T2：工程师 T3：高级工程师 3-1相当于阿里的p6+到p7（能力强可能到p7） T4：专家工程师 T5：科学家 T6：首席科学家 目前全腾讯貌似就一个T6。 每一级之间又分为3个子级，3-1是任命组长/副组长的必要条件，其他线也是这样。T4基本为总监级，也不排除有T3-3的总监，因为T4非常难晋级。 2、晋升腾讯的晋级还是很困难的。尤其是T2 升T3，T3升T4。非常多的人卡在2-3,3-3没办法晋级。有的小伙伴做了3、4年的2-3 也升不上去啊。 3、薪水腾讯薪资架构：12+1+1=14薪 年终奖：看部门盈利情况，一般是3个月 职级待遇基本如下(2015年左右)： 级别越高base薪酬也越高，一年根据你的performance大概能发15.3个月至18个月的工资，T3.1的base 2w+，T3以上级别的员工都会有股票期权，腾讯09以前的员工赚钱主要靠股票，从08到现在股票up了500%+，T5+的base薪酬在600w~800w/年。 4、人才人才流动的可能： 深圳：很多腾讯员工都买了房，当你的房子，妻子的工作，儿子的学校，你的朋友圈，都在一个城市的时候，换城市就有困难了。所以只能挖一些比较浅的人走。 北京：人数不少 ，不过骨干员工不多。腾讯视频的主要团队在北京的倒是不少。 成都、大连：在这些二线城市，腾讯就是当地最好的互联网公司了，提供的待遇也是非常高的，不少人都对自己的薪资比较满意，工作环境也很满意。跳槽的可能性低了很多。 人才结构： 腾讯的研发序列硕士学历的占多度，211大学，985大学占多数。大家都知道腾讯研究院解散了。去年走出来很多人，腾讯人才创业比例不高。 在腾讯最常碰到的晋升问题就是天花板。可能新人进去，学东西会很多，但业务线就这些，没有那么多坑，自然也就很难晋升高级岗。 在腾讯最悲剧的时刻就是公司有收购和整合。搜狗合并，搜搜的人哭了，京东合作，易迅的人哭了。在腾讯跳出来碰到最大的问题就是，外面的公司太不完善了。 ★ 阿里巴巴 ★1、层级阿里的职称大部分都归纳在P序列 ,你的title+工种。比如P7产品经理=产品专家。 一般到P3为助理 P4=专员 P5=资深专员 P6=高级专员（也可能是高级资深） P7=专家 P8=资深专家（架构师） P9=高级专家（资深架构师） P10=研究员 P11=高级研究员 P12=科学家 P13=首席科学家 P14=马云 同时对应P级还有一套管理层的机制在： M1=P6 主管 M2=P7 经理 M3=P8 资深经理 M4 =P9 总监 M5= P10 资深总监 M6 =P11 副总裁 M7=P12 资深副总裁 M8=P13 子公司CEO 或集团其他O M9=P14 陆兆禧（前马云） 在阿里早些时候P级普遍偏低，专员可能是P2这样，后来有了一次P级通货膨胀，出现了更多的P级。在阿里只有P6（M1）后才算是公司的中层。不同的子公司给出P级的标准不一样。 比如：B2B的普遍P级较高，但是薪资水平低于天猫子公司的同级人员。同时到达该P级员工才有享受公司RSU的机会。（低于P6的除非项目出色有RSU奖励，否则1股都拿不到） 2、晋升晋升很简单： 晋升资格：上年度KPI达3.75。 主管提名。一般KPI不达3.75主管不会提名。 晋升委员会面试。（晋升委员会组成一般是合作方业务部门大佬、HRG、该业务线大佬等。） 晋升委员会投票。 P5升P6相对容易，再往上会越来越难，一般到P7都是团队技术leader了，P6到P7非常难，从员工到管理的那一步跨出去不容易，当然有同学说P一般都是专家，M才是管理，actually，专家线/管理线有时并不是分的那么清楚的。 3、薪水• 阿里薪资结构：一般是12+1+3=16薪 • 年底的奖金为0-6个月薪资，90%人可拿到3个月 • 股票是工作满2年才能拿，第一次拿50%，4年能全部拿完 ★ 百度 ★1、层级百度的级别架构分成四条线。 技术序列 T：T3 - T11 （一般对应阿里高一级序列，如：百度T3=阿里P4，T5/T6属于部门骨干，非常抢手，人人猎中相当一部分offer人选都来自这个序列） 产品运营序列 P：p3-P11 （产品和运营岗，对应阿里高1-1.5级序列 百度p3=阿里P4-P5之间) 后勤支持部门 S ：S3-S11 (主要是公共、行政、渠道等等，晋升比较困难) 管理序列 M：M1-M5 (每一级又分为2个子级 M1A、M1B , 最低的是M1A，至少是部门二把手了，李明远是M3.2，以前的汤和松都是这个级别，李彦宏是唯一的M5，其实从M3开始就有机会加入E——star，类似于阿里的合伙人会议，属于最高战略决策层。 2、薪资月薪14.6（12+0.6+2）,其他岗位：月薪14 T5以上为关键岗位，另外有股票、期权。T5、T6占比最大的级别，T8、T9占比最小，级别越高，每档之间的宽幅越大。 3、晋升基本上应届毕业生应该是T3，但是内部晋升非常激烈。公司那么大，部门和部门之间有业务竞争，肯定也有人才竞争。 通常应届毕业生入职1年多能升到T4，但如果你的部门业务足够核心，或许1年就可以了。3年升T5。从目前百度的情况来看，核心工程师集中在T5/6，但是从5/6到7是非常艰难的过程。 百度是很唯KPI至上的，其次部门很核心，再次老大话语权比较高，相对晋升容易些。 一般情况分2种： 自己提名，当你自己觉得已经具备下一level的素质，可以自己提名，提名后进入考察期，主管设定考察期目标，考察通过顺利晋升，考察不通过维持原层级不变； 主管提名，如果是主管提名，一般都是直接通过的，但是如果你现层级已经比较高了，那就不是直接提名这么简单了。 P.S.如果你能升到T7，基本上是TL的级别，写代码/直接做业务的时间就很少了。","categories":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/categories/BAT/"}],"tags":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/tags/BAT/"}],"keywords":[{"name":"BAT","slug":"BAT","permalink":"http://github.com/categories/BAT/"}]},{"title":"【Android】dip和px之间到底如何转换","slug":"【Android】dip和px之间到底如何转换","date":"2016-07-22T04:02:00.000Z","updated":"2016-11-21T04:14:48.931Z","comments":true,"path":"2016/07/22/【Android】dip和px之间到底如何转换/","link":"","permalink":"http://github.com/2016/07/22/【Android】dip和px之间到底如何转换/","excerpt":"在Android xml布局文件中，我们既可以设置px，也可以设置dp（或者dip）。一般情况下，我们都会选择使用dp，这样可以保证不同屏幕分辨率的机器上布局一致。 但是在代码中，如何处理呢？很多控件的方法中都只提供了设置px的方法，例如setPadding，并没有提供设置dp的方法。这个时候，如果需要设置dp的话，就要将dp转换成px了。 一、名词介绍 PPI = Pixels per inch，每英寸上的像素数,即 “像素密度”&nbsp;&nbsp;&nbsp;&nbsp; ● xhdpi: 2.0&nbsp;&nbsp;&nbsp;&nbsp; ● hdpi: 1.5&nbsp;&nbsp;&nbsp;&nbsp; ● mdpi: 1.0 (baseline)&nbsp;&nbsp;&nbsp;&nbsp; ● ldpi: 0.75下图是Android官网dpi的定义（其实在计算机中dpi就是ppi。注意，是dpi，不是dip，dpi是现实概念，dip是人为抽象概念。还是不明白可以看看这里 dpi与ppi区别）： dp = 也就是dip（device independent pixels），设备独立像素。以160PPI屏幕为标准，则1dp=1px，在不同的像素密度的设备上会自动适配，比如:&nbsp;&nbsp;&nbsp;&nbsp; ● 在320x480分辨率，像素密度为160，1dp=1px&nbsp;&nbsp;&nbsp;&nbsp; ● 在480x800分辨率，像素密度为240，1dp=1.5px&nbsp;&nbsp;&nbsp;&nbsp; &gt; 计算公式：1dp*像素密度/160 = 实际像素数 sp = Scale-independent pixels，它是安卓的字体单位","text":"在Android xml布局文件中，我们既可以设置px，也可以设置dp（或者dip）。一般情况下，我们都会选择使用dp，这样可以保证不同屏幕分辨率的机器上布局一致。 但是在代码中，如何处理呢？很多控件的方法中都只提供了设置px的方法，例如setPadding，并没有提供设置dp的方法。这个时候，如果需要设置dp的话，就要将dp转换成px了。 一、名词介绍 PPI = Pixels per inch，每英寸上的像素数,即 “像素密度”&nbsp;&nbsp;&nbsp;&nbsp; ● xhdpi: 2.0&nbsp;&nbsp;&nbsp;&nbsp; ● hdpi: 1.5&nbsp;&nbsp;&nbsp;&nbsp; ● mdpi: 1.0 (baseline)&nbsp;&nbsp;&nbsp;&nbsp; ● ldpi: 0.75下图是Android官网dpi的定义（其实在计算机中dpi就是ppi。注意，是dpi，不是dip，dpi是现实概念，dip是人为抽象概念。还是不明白可以看看这里 dpi与ppi区别）： dp = 也就是dip（device independent pixels），设备独立像素。以160PPI屏幕为标准，则1dp=1px，在不同的像素密度的设备上会自动适配，比如:&nbsp;&nbsp;&nbsp;&nbsp; ● 在320x480分辨率，像素密度为160，1dp=1px&nbsp;&nbsp;&nbsp;&nbsp; ● 在480x800分辨率，像素密度为240，1dp=1.5px&nbsp;&nbsp;&nbsp;&nbsp; &gt; 计算公式：1dp*像素密度/160 = 实际像素数 sp = Scale-independent pixels，它是安卓的字体单位 二、换算公式 PPI 的运算方式是：PPI = √（长度像素数² + 宽度像素数²） / 屏幕对角线英寸数 dp和px的换算公式 ：dp*ppi/160 = px。比如1dp x 320ppi/160 = 2px。 sp 与 px 的换算公式：sp*ppi/160 = px 三、总结px = dp*ppi/160dp = px / (ppi / 160) px = sp*ppi/160sp = px / (ppi / 160) dp = sp? 四、转换代码 为了方便进行px和dp之间的转换，可以使用以下代码。 import android.content.Context; public class DensityUtil &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; &#125; 【参考资料】1、px 与 dp, sp换算公式2、dp、sp、px傻傻分不清楚[完整]","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Monkey压力测试与停止","slug":"【Android】Monkey压力测试与停止","date":"2016-07-19T03:09:00.000Z","updated":"2016-10-18T04:55:14.551Z","comments":true,"path":"2016/07/19/【Android】Monkey压力测试与停止/","link":"","permalink":"http://github.com/2016/07/19/【Android】Monkey压力测试与停止/","excerpt":"一、Monkey 是什么？Monkey测试是Android自动化测试的一种手段。该工具用于进行压力测试，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。 二、Monkey命令1）. 标准的monkey 命令[adb shell] monkey [options] &lt; eventcount &gt; , 例如： adb shell monkey -v 500 产生500次随机事件，作用在系统中所有activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。上面只是一个简单的例子，实际情况中通常会有很多的options 选项. 2）. 四大类 常用选项 事件选项 约束选项 调试选项 具体的命令解释可以看这里：android 压力测试命令monkey详解","text":"一、Monkey 是什么？Monkey测试是Android自动化测试的一种手段。该工具用于进行压力测试，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。 二、Monkey命令1）. 标准的monkey 命令[adb shell] monkey [options] &lt; eventcount &gt; , 例如： adb shell monkey -v 500 产生500次随机事件，作用在系统中所有activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。上面只是一个简单的例子，实际情况中通常会有很多的options 选项. 2）. 四大类 常用选项 事件选项 约束选项 调试选项 具体的命令解释可以看这里：android 压力测试命令monkey详解 一个简单的Monkey命令如下： adb shell monkey -p com.example.xystudy -s 500 -v 10000 工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。monkey 测试命令如下： /** * monkey 作用的包：com.ckt.android.junit * 产生时间序列的种子值：500 * 忽略程序崩溃、 忽略超时、 监视本地程序崩溃、 详细信息级别为2， 产生10000个事件 。 */adb shell monkey -p com.xy.android.junit -s 500 --ignore-crashes--ignore-timeouts --monitor-native-crashes -v -v 10000 &gt; E:\\monkey_log\\java_monkey_log.txt 三、强制停止Monkey测试adb shell ps | awk '/com\\.android\\.commands\\.monkey/ &#123; system(\"adb shell kill \" $2) &#125;' ####【参考资料】 1、android 压力测试命令monkey详解2、Monkey 的专项测试浅谈","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？","slug":"【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？","date":"2016-07-14T08:27:00.000Z","updated":"2016-10-18T04:55:00.540Z","comments":true,"path":"2016/07/14/【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？/","link":"","permalink":"http://github.com/2016/07/14/【Android】App应用崩溃(Crash-Force Close)之后如何让它自动重启？/","excerpt":"英文原文： Auto Restart application after Crash/Force Close in Android. 手机上的Android应用，经常会出现“Force Close”的错误，这种情况一般是因为代码中没有正确获取到Exceptions。那么如果想让App在出现这种错误崩溃Crash以后自动重启，我们该怎么办呢？ 这篇教程我们将学到如何自动处理Exception，并且了解在App Crash以后如何自动重启。 其实方法很简单，这里我们需要用到 Thread.setDefaultUncaughtExceptionHandler()，当应用崩溃的时候代码就会自动调用 uncaughtException() 这个方法。","text":"英文原文： Auto Restart application after Crash/Force Close in Android. 手机上的Android应用，经常会出现“Force Close”的错误，这种情况一般是因为代码中没有正确获取到Exceptions。那么如果想让App在出现这种错误崩溃Crash以后自动重启，我们该怎么办呢？ 这篇教程我们将学到如何自动处理Exception，并且了解在App Crash以后如何自动重启。 其实方法很简单，这里我们需要用到 Thread.setDefaultUncaughtExceptionHandler()，当应用崩溃的时候代码就会自动调用 uncaughtException() 这个方法。 操作步骤如下： Step 1 像下面这样创建一个重启目标 Activity 的 Intent，并添加一些 Activity 启动的 Flags： Intent intent = new Intent(activity, RelaunchActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); 其中， Intent.FLAG_ACTIVITY_CLEAR_TOP ： 销毁目标Activity和它之上的所有Activity，重新创建目标Activity。 Intent.FLAG_ACTIVITY_CLEAR_TASK ： 启动Activity时，清除之前已经存在的Activity实例所在的task，这自然也就清除了之前存在的Activity实例！ Intent.FLAG_ACTIVITY_NEW_TASK ： 很少单独使用，通常与FLAG_ACTIVITY_CLEAR_TASK或FLAG_ACTIVITY_CLEAR_TOP联合使用。 Step 2 在 uncaughtException() 方法中，添加如下代码： PendingIntent pendingIntent = PendingIntent.getActivity( YourApplication.getInstance().getBaseContext(), 0, intent, intent.getFlags()); AlarmManager mgr = (AlarmManager) YourApplication.getInstance().getBaseContext() .getSystemService(Context.ALARM_SERVICE);mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, pendingIntent); activity.finish();System.exit(2); 这里的 PendingIntent 不同于常见的 Intent ，PendingIntent 是对 Intent 的一个包装，可以保存下来在将来某一刻执行。它存储了request code、intent 和 flags。 AlarmManager 是为了设置一个计时器来延迟两秒再执行 pendingIntent 的，也就是重启我们的Activity的任务。 Step 3 最后，在 Activity 的 onCreate() 方法中调用如下代码： Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler(this)); 【完整代码】 YourApplication.java import android.app.Application; /** * This custom class is used to Application level things. * * @author Chintan Rathod (http://www.chintanrathod.com) */public class YourApplication extends Application &#123; private static Context mContext; public static YourApplication instace; @Override public void onCreate() &#123; super.onCreate(); mContext = getApplicationContext(); instace = this; &#125; @Override public Context getApplicationContext() &#123; return super.getApplicationContext(); &#125; public static YourApplication getIntance() &#123; return instace; &#125;&#125; DefaultExceptionHandler.java import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.lang.Thread.UncaughtExceptionHandler;import java.text.SimpleDateFormat;import java.util.Date; import android.app.Activity;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.Environment;import android.util.Log; /** * This custom class is used to handle exception. * * @author Chintan Rathod (http://www.chintanrathod.com) */public class DefaultExceptionHandler implements UncaughtExceptionHandler &#123; private UncaughtExceptionHandler defaultUEH; Activity activity; public DefaultExceptionHandler(Activity activity) &#123; this.activity = activity; &#125; @Override public void uncaughtException(Thread thread, Throwable ex) &#123; try &#123; Intent intent = new Intent(activity, RelaunchActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity( YourApplication.getInstance().getBaseContext(), 0, intent, intent.getFlags()); //Following code will restart your application after 2 seconds AlarmManager mgr = (AlarmManager) YourApplication.getInstance().getBaseContext() .getSystemService(Context.ALARM_SERVICE); mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent); //This will finish your activity manually activity.finish(); //This will stop your application and take out from it. System.exit(2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【参考资料】： 1、Activity启动模式(二)之 Intent的Flag属性","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【SVN】使用patch命令保存更改","slug":"【SVN】使用patch命令保存更改","date":"2016-06-12T03:06:00.000Z","updated":"2016-10-18T04:57:14.094Z","comments":true,"path":"2016/06/12/【SVN】使用patch命令保存更改/","link":"","permalink":"http://github.com/2016/06/12/【SVN】使用patch命令保存更改/","excerpt":"使用svn管理工程代码时，有些时候的更改尚未整理好，需要暂时搁置，转而进行下一个任务，此时就需要将当前的更改（diff）暂时保存下来，忙完其他的任务之后再继续进行。但是如果不进行commit，怎么保存当前的更改呢？答案是使用 patch 命令！ 一、生成patch文件svn diff &gt; patchFile // 整个工程的变动生成patchsvn diff FILE_NAME &gt; patchFile // 某个文件单独变动的patch 二、svn回滚svn revert FILE // 单个文件回滚svn revert DIR --depth=infinity // 整个目录进行递归回滚svn revert . --depth=infinity // 当前目录进行递归回滚","text":"使用svn管理工程代码时，有些时候的更改尚未整理好，需要暂时搁置，转而进行下一个任务，此时就需要将当前的更改（diff）暂时保存下来，忙完其他的任务之后再继续进行。但是如果不进行commit，怎么保存当前的更改呢？答案是使用 patch 命令！ 一、生成patch文件svn diff &gt; patchFile // 整个工程的变动生成patchsvn diff FILE_NAME &gt; patchFile // 某个文件单独变动的patch 二、svn回滚svn revert FILE // 单个文件回滚svn revert DIR --depth=infinity // 整个目录进行递归回滚svn revert . --depth=infinity // 当前目录进行递归回滚 三、打patchpatch -p0 &lt; test.patch // -p0 选项要从当前目录查找目的文件（夹）patch -p1 &lt; test.patch // -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录（夹）","categories":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/categories/SVN/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/tags/SVN/"}],"keywords":[{"name":"SVN","slug":"SVN","permalink":"http://github.com/categories/SVN/"}]},{"title":"【Android】技术调研：用代码模拟屏幕点击、触摸事件","slug":"【Android】技术调研：用代码模拟屏幕点击、触摸事件","date":"2016-06-02T03:55:00.000Z","updated":"2016-10-18T04:55:38.831Z","comments":true,"path":"2016/06/02/【Android】技术调研：用代码模拟屏幕点击、触摸事件/","link":"","permalink":"http://github.com/2016/06/02/【Android】技术调研：用代码模拟屏幕点击、触摸事件/","excerpt":"在Android中，有些场景需要使用代码来模拟人的操作，比如微信自动抢红包、UI测试等都需要模拟实现点击事件（Click）、触摸事件（Touch）、键盘事件（KeyBoard）等。那么，有没有现成的方案可以实现呢？答案当然是肯定的啦，往下看。 经过调研发现，给系统模拟注入输入事件有如下几种方式： 一、使用shell命令使用android自带的adb shell，里面自带一个input工具，使用方法如下： adb shell #进入系统input keyevent KEYCODE_BACK #模拟按返回键input keyevent KEYCODE_HOME #模拟按Home键","text":"在Android中，有些场景需要使用代码来模拟人的操作，比如微信自动抢红包、UI测试等都需要模拟实现点击事件（Click）、触摸事件（Touch）、键盘事件（KeyBoard）等。那么，有没有现成的方案可以实现呢？答案当然是肯定的啦，往下看。 经过调研发现，给系统模拟注入输入事件有如下几种方式： 一、使用shell命令使用android自带的adb shell，里面自带一个input工具，使用方法如下： adb shell #进入系统input keyevent KEYCODE_BACK #模拟按返回键input keyevent KEYCODE_HOME #模拟按Home键 还可以直接输入点击屏幕的事件，模拟点击屏幕： input tap 100 200 #在屏幕坐标(100, 200)处点击 详细的用法如下： 二、使用 InstrumentationInstrumentation本身是Android用来做测试的工具，可以通过它监测系统与应用程序之间的交互。详情可以参考官方文档[Test Your App]。我们这里只关注怎么使用Instrumentation产生发送按键或者触屏事件。 它可以发送按键： Instrumentation mInst = new Instrumentation(); mInst.sendKeyDownUpSync(KeyEvent.KEYCODE_CAMERA); 也可以发送触屏事件：Instrumentation mInst = new Instrumentation(); mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, x, y, 0); //x,y 即是事件的坐标mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, x, y, 0); 与Shell工具一样，还有类似sendStringSync()发送文本，sendTrackballEventSync()发送轨迹球事件等方法。 sendCharacterSync(int keyCode) //用于发送指定KeyCode的按键sendKeyDownUpSync(int key) //用于发送指定KeyCode的按键sendPointerSync(MotionEvent event) //用于模拟TouchsendStringSync(String text) //用于发送字符串 需要注意的是，这些方法均不可以在UI主线程中执行，必须放到子线程中调用，否则就会报错。另外，使用上面的方法，需要在AndroidManifast.xml中申明如下权限： &lt;uses-permission android:name=\"android.permission.INJECT_EVENTS\"/&gt; 三、使用Android内部API在Android系统中，有些内部的API提供注入事件的方法。因为是内部API，在不同版本上可能变化比较大。使用如果想在普通App中使用，可能需要通过反射机制来调用。 在Android API 16之前，WindownManager有相应的方法提供注入事件的方法，如下： IBinder wmbinder = ServiceManager.getService(\"window\"); IWindowManager wm = IWindowManager.Stub.asInterface(wmbinder); //pointer wm.injectPointerEvent(myMotionEvent, false); //key wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_A), false); wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_A), false); //trackball wm.injectTrackballEvent(myMotionEvent, false); 在API 15之后，引入了InputManager，把上面的哪些injectXXXEvent()方法从WindowManager中移除了。使用方法类似： IBinder imBinder = ServiceManager.getService(\"input\"); IInputManager im = IInputManager.Stub.asInterface(imBinder);//inject key eventfinal KeyEvent keyEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount, metaState, deviceId, scancode, flags | KeyEvent.FLAG_FROM_SYSTEM |KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_SOFT_KEYBOARD, source);event.setSource(InputDevice.SOURCE_ANY) im.injectInputEvent(keyEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);//inject pointer eventmotionEvent.setSource(InputDevice.SOURCE_TOUCHSCREEN); im.injectInputEvent(motionEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH); 从API 16开始，InputManager就成了一个公开的类了，可以通过如下方法获得InputManager实例： InputManager im = (InputManager) getSystemService(Context.INPUT_SERVICE); 注意，使用injectEvent()同样需要申明android:name=”android.permission.INJECT_EVENTS”权限。 四、可以考虑使用Monkey测试框架这种方案就是希望能够模拟Android Monkey的测试方法，不过博主并没有来得及对这方面进行深入的研究，可以参考这篇文章Android Monkey源码解析 【参考资料】：1、Android模拟产生事件2、Android 模拟键盘鼠标事件（Socket+Instrumentation实现）3、Android Monkey源码解析","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】按位存储：使用int存储boolean数组","slug":"【Java】按位存储：使用int存储boolean数组","date":"2016-06-02T03:55:00.000Z","updated":"2016-10-18T04:56:22.429Z","comments":true,"path":"2016/06/02/【Java】按位存储：使用int存储boolean数组/","link":"","permalink":"http://github.com/2016/06/02/【Java】按位存储：使用int存储boolean数组/","excerpt":"有一种场景，比如App设置页中会有一组开关选项，这个时候保存这些开关的状态，如果每个按钮都对应一个boolean值的话，太大材小用显得鸡肋，频繁读取SharedPreferences 存取效率自然快不过一次读取。 首先，敲定每个boolean值存储的位置private int mBroadcastCustomValue = 0; //用来存储的int值public static final int BROADCAST_TYPE_CUSTOM_BASE = 1; //基础类播报public static final int BROADCAST_TYPE_CUSTOM_TRAFFIC = 1 &lt;&lt; 1; //实时路况public static final int BROADCAST_TYPE_CUSTOM_CAMERA = 1 &lt;&lt; 2; //摄像头限速播报public static final int BROADCAST_TYPE_CUSTOM_SAFE = 1 &lt;&lt; 3; //安全提醒类 一、添加Addprivate void addLevel(int level)&#123; mBroadcastCustomValue |= level; //add&#125;//调用方式如下addLevel(BROADCAST_TYPE_CUSTOM_BASE);","text":"有一种场景，比如App设置页中会有一组开关选项，这个时候保存这些开关的状态，如果每个按钮都对应一个boolean值的话，太大材小用显得鸡肋，频繁读取SharedPreferences 存取效率自然快不过一次读取。 首先，敲定每个boolean值存储的位置private int mBroadcastCustomValue = 0; //用来存储的int值public static final int BROADCAST_TYPE_CUSTOM_BASE = 1; //基础类播报public static final int BROADCAST_TYPE_CUSTOM_TRAFFIC = 1 &lt;&lt; 1; //实时路况public static final int BROADCAST_TYPE_CUSTOM_CAMERA = 1 &lt;&lt; 2; //摄像头限速播报public static final int BROADCAST_TYPE_CUSTOM_SAFE = 1 &lt;&lt; 3; //安全提醒类 一、添加Addprivate void addLevel(int level)&#123; mBroadcastCustomValue |= level; //add&#125;//调用方式如下addLevel(BROADCAST_TYPE_CUSTOM_BASE); 二、删除Deleteprivate void deleteLevel(int level)&#123; mBroadcastCustomValue ^= mBroadcastCustomValue &amp; level; //delete&#125;//调用方式如下deleteLevel(BROADCAST_TYPE_CUSTOM_BASE); 三、读取Read/** * 从value中读取level的设置值，level即是某个boolean值的位置 */private boolean isLevelAccess(int value, int level)&#123; if((value &amp; level) == level)&#123; return true; &#125; return false;&#125;//调用方式如下boolean a = isLevelAccess(mBroadcastCustomValue, BROADCAST_TYPE_CUSTOM_BASE);","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【MySQL】查询保持IN中的顺序","slug":"【MySQL】查询保持IN中的顺序","date":"2016-04-29T07:36:00.000Z","updated":"2016-10-18T04:57:07.725Z","comments":true,"path":"2016/04/29/【MySQL】查询保持IN中的顺序/","link":"","permalink":"http://github.com/2016/04/29/【MySQL】查询保持IN中的顺序/","excerpt":"select * from table_name where id in ()的时候，MySQL会自动按主键自增排序，要是按IN中给定的顺序来取，如何实现呢？ 比如下面这个查询结果，mysql会默认使用主键id的ASC自增排序结果集：","text":"select * from table_name where id in ()的时候，MySQL会自动按主键自增排序，要是按IN中给定的顺序来取，如何实现呢？ 比如下面这个查询结果，mysql会默认使用主键id的ASC自增排序结果集： 那么，如果我们想维持查询语句中IN(26613,26612,26611,26610,26609,26608,26607)的顺序可以么？当然可以，像下面这样，使用Order by field()： SELECT * from `models` where `id` in (26612,26611,26610) order by field(id,26612,26611,26610); 这样读取出来的顺序就是IN（）语句中的顺序。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/tags/MySQL/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/categories/MySQL/"}]},{"title":"【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决","slug":"【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决","date":"2016-04-29T03:37:09.000Z","updated":"2016-10-18T04:56:53.039Z","comments":true,"path":"2016/04/29/【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决/","link":"","permalink":"http://github.com/2016/04/29/【Linux】执行shell脚本出现异常：bad interpreter- No such file or directory如何解决/","excerpt":"在Linux中执行.sh脚本，异常/bin/bash^M: bad interpreter: No such file or directory. 一、分析这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 二、解决1）在windows下转换：利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。","text":"在Linux中执行.sh脚本，异常/bin/bash^M: bad interpreter: No such file or directory. 一、分析这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 二、解决1）在windows下转换：利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。 2）直接在Linux中转换（推荐做法）： 首先要确保文件有可执行权限 #sh&gt; chmod a+x filename 然后修改文件格式 #sh&gt; vi filename 利用如下命令查看文件格式 :set ff 或 :set fileformat 可以看到如下信息 fileformat=dos 或 fileformat=unix 利用如下命令修改文件格式 :set ff=unix 或 :set fileformat=unix :wq (存盘退出) 最后再执行文件 #sh&gt;./filename","categories":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}]},{"title":"”二分查找“算法的时间复杂度","slug":"”二分查找“算法的时间复杂度","date":"2016-04-06T06:03:00.000Z","updated":"2016-10-18T04:54:36.739Z","comments":true,"path":"2016/04/06/”二分查找“算法的时间复杂度/","link":"","permalink":"http://github.com/2016/04/06/”二分查找“算法的时间复杂度/","excerpt":"算法的时间复杂度无非就是for、while等包含起来的基本运算单元的循环次数 1、二分查找二分查找（binary search），也称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！","text":"算法的时间复杂度无非就是for、while等包含起来的基本运算单元的循环次数 1、二分查找二分查找（binary search），也称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数！ //二分查找 Java 实现public static int binarySearch(Integer[] srcArray, int des) &#123; int low = 0; int high = srcArray.length - 1; while ((low &lt;= high) &amp;&amp; (low &lt;= srcArray.length - 1) &amp;&amp; (high &lt;= srcArray.length - 1)) &#123; int middle = (high + low) &gt;&gt; 1; if (des == srcArray[middle]) &#123; return middle; &#125; else if (des &lt; srcArray[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; return -1;&#125; 2、时间复杂度比如：总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。由于n/2^k取整后&gt;=1，即令n/2^k=1，可得k=log2n,（是以2为底，n的对数），所以时间复杂度可以表示O()=O(logn)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"给大家推荐一款Sublime Text的主题”brogrammer-theme“","slug":"给大家推荐一款Sublime Text的主题”brogrammer-theme“","date":"2016-03-30T08:46:00.000Z","updated":"2016-10-18T04:51:49.926Z","comments":true,"path":"2016/03/30/给大家推荐一款Sublime Text的主题”brogrammer-theme“/","link":"","permalink":"http://github.com/2016/03/30/给大家推荐一款Sublime Text的主题”brogrammer-theme“/","excerpt":"先给大家看一下这个主题的颜值：","text":"先给大家看一下这个主题的颜值： 快看安装方法：1、下载：https://github.com/kenwheeler/brogrammer-theme/archive/master.zip 2、解压后将文件夹改名成Theme - Brogrammer，然后打开sublime text3，找到里面的 Preferences -&gt; Browse Packages，将改名后的文件夹copy到弹出的文件夹中 3、然后首选项-&gt;设置用户（Preferences -&gt; setting uer），将下列代码拷进去： &#123; &quot;color_scheme&quot;: &quot;Packages/brogrammer-theme-master/brogrammer.tmTheme&quot;, &quot;font_size&quot;: 10&#125; 【官方文档】： brogrammer-theme on Github Theme - Brogrammer on Package Control","categories":[],"tags":[],"keywords":[]},{"title":"【Android】Picasso加载本地图片如何清理缓存cache？","slug":"【Android】Picasso加载本地图片如何清理缓存cache？","date":"2016-03-08T07:03:00.000Z","updated":"2016-10-28T02:23:43.007Z","comments":true,"path":"2016/03/08/【Android】Picasso加载本地图片如何清理缓存cache？/","link":"","permalink":"http://github.com/2016/03/08/【Android】Picasso加载本地图片如何清理缓存cache？/","excerpt":"","text":"使用Picasso加载SD卡图片的时候，Picasso也会对该图片进行缓存。所以如果该图片即使已经变了，Picasso在加载时会仍然使用缓存，而不更新图片。 1、Picasso缓存策略我们都知道图片缓存使用的是Map键值对存储的，这里的Key就是加载的图片的Url，所以如果我们使用相同的ImageUrl去加载图片的话，如果使用了缓存，Picasso会直接读取缓存的内容，而不是从SD卡、或者网络Http中重新加载。 2、Picasso如何跳过缓存试了很多网上推荐的方法均不见起效，最后使用了下面这种策略，也就是加载图片时直接跳过缓存 Picasso.with(getContext()).load(imageUrl).memoryPolicy(MemoryPolicy.NO_CACHE).into(image); 注意其中的.memoryPolicy(MemoryPolicy.NO_CACHE)即是关键代码，其中 MemoryPolicy.NO_CACHE：是指图片加载时放弃在内存缓存中查找。 MemoryPolicy.NO_STORE：是指图片加载完不缓存在内存中。 ps：此处的方法并不是真正的清理缓存，而是跳过缓存直接从源头获取。 网上有几种错误的方法如下，经验证均不起效： 1、Picasso.with(getActivity()).invalidate(file);2、Picasso.with(getActivity()).load(url).skipMemoryCache().into(image); 最后还是在StackOverFlow的Clear Cache memory of Picasso查到了如上的解决办法。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"如何生成100个1-100以内的不重复的随机数","slug":"如何生成100个1-100以内的不重复的随机数","date":"2016-01-22T03:55:00.000Z","updated":"2016-10-18T04:58:09.102Z","comments":true,"path":"2016/01/22/如何生成100个1-100以内的不重复的随机数/","link":"","permalink":"http://github.com/2016/01/22/如何生成100个1-100以内的不重复的随机数/","excerpt":"这是个经典的面试题目：生成长度为100的数组，插入1-100以内的但均不重复的随机数 一、简单实现思路:(1) 把N个数放入Hashtable 或者arrayList 中. (2) 从上面的集合中随机抽取一个数放入int数组中. (3) 把取出的这个数从上面的集合中删除. (4) 循环 (2),(3) 步骤,直到int数组取满为止.","text":"这是个经典的面试题目：生成长度为100的数组，插入1-100以内的但均不重复的随机数 一、简单实现思路:(1) 把N个数放入Hashtable 或者arrayList 中. (2) 从上面的集合中随机抽取一个数放入int数组中. (3) 把取出的这个数从上面的集合中删除. (4) 循环 (2),(3) 步骤,直到int数组取满为止. 这是一种比较简单的实现思路，实现代码如下： import java.util.ArrayList;import java.util.Collections;import java.util.Random;public class Main &#123; private static int range = 100; private static ArrayList&lt;Integer&gt; originalList = new ArrayList&lt;Integer&gt;(); private static ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); static &#123; for (int i = 1; i &lt;= range; i++) &#123; originalList.add(i); &#125; &#125; public static void main(String args[]) &#123; for (int i = 0; i &lt; range; i++) &#123; int j = range - i; int r = (int) (new Random().nextInt(j)); result.add(originalList.get(r)); System.out.print(originalList.get(r) + \", \"); originalList.remove(r); &#125; Collections.sort(result); System.out.println(\"\\n\\n生成的数组大小是：\" + result.size() + \"------以下是排序结果，看是否有重复的随机数\"); for (Integer i : result) &#123; System.out.print(i + \", \"); &#125; &#125;&#125; 执行结果如下： 74, 75, 47, 76, 59, 94, 2, 33, 23, 66, 60, 13, 44, 34, 7, 92, 11, 86, 4, 38, 26, 55, 64, 99, 1, 54, 30, 72, 80, 87, 15, 24, 25, 37, 83, 49, 28, 81, 79, 35, 18, 68, 61, 46, 98, 58, 85, 29, 39, 48, 53, 14, 8, 91, 42, 36, 65, 62, 6, 52, 21, 78, 63, 73, 16, 88, 5, 69, 19, 51, 50, 43, 40, 70, 89, 10, 12, 71, 96, 45, 93, 9, 31, 22, 95, 20, 17, 3, 67, 90, 41, 82, 57, 84, 100, 32, 77, 27, 97, 56, 生成的数组大小是：100------以下是排序结果，看是否有重复的随机数1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 二、改进算法我们一般都会想到这种做法,但是当Hashtable或者ArrayList中放几千万,几亿数据时,这时从集合中删除元素将严重影响性能,如果突破此瓶颈? 网上找到一种更好的方法. (1) 把N个数放到容器A(int数组)中.(2) 从N个数中随机取出1个数放入容器B(int数组)中.(3) 把容器A中最后一个数与随机抽取的数对调 或者 把容器A中最后一个数覆盖随机抽取出来的数.(4) 这时从容器A(假设N个数,索引0 到 索引N-2)之间随机取一个数.再放入容器B中,重复此步骤. 说明：也就是第二次是从容器A中 第一个元素到倒数第二个元素 中随机取一个数.这种好处是,随机数所取范围逐步缩小,而且杜绝了大数据时集合执行删除操作时产生的瓶颈. 所以，向下面这样实现会更好： public class Main &#123; private static int range = 100; private static int[] result; public static void main(String args[]) &#123; result = getNumber(range); for (int i = 0; i &lt; range; i++) &#123; System.out.print(result[i] + \", \"); &#125; &#125; public static int[] getNumber(int total)&#123; int[] NumberBox = new int[total]; //容器A int[] rtnNumber = new int[total]; //容器B for (int i = 0; i &lt; total; i++)&#123; NumberBox[i] = i; //先把N个数放入容器A中 &#125; int end = total - 1; for (int j = 0; j &lt; total; j++)&#123; int num = new Random().nextInt(end + 1); //取随机数 rtnNumber[j] = NumberBox[num]; //把随机数放入容器B NumberBox[num] = NumberBox[end]; //把容器A中最后一个数覆盖所取的随机数 end--; //缩小随机数所取范围 &#125; return rtnNumber; //返回int型数组 &#125;&#125; 执行结果如下： 80, 9, 70, 22, 3, 63, 12, 81, 73, 41, 90, 83, 27, 71, 88, 5, 40, 18, 25, 37, 55, 60, 93, 87, 17, 89, 99, 84, 32, 96, 62, 98, 77, 30, 23, 35, 47, 24, 21, 53, 95, 7, 85, 2, 65, 1, 39, 43, 76, 46, 42, 91, 4, 26, 52, 86, 34, 54, 38, 78, 31, 11, 66, 36, 50, 75, 16, 68, 56, 33, 48, 15, 74, 69, 49, 6, 58, 10, 29, 92, 64, 59, 28, 61, 45, 19, 14, 13, 44, 72, 94, 20, 97, 51, 67, 79, 0, 82, 8, 57,","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Android】如何查看Activity Task栈的情况","slug":"【Android】如何查看Activity Task栈的情况","date":"2016-01-19T03:48:00.000Z","updated":"2016-10-18T04:55:43.216Z","comments":true,"path":"2016/01/19/【Android】如何查看Activity Task栈的情况/","link":"","permalink":"http://github.com/2016/01/19/【Android】如何查看Activity Task栈的情况/","excerpt":"我们都知道，每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。 如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一、查看task栈情况 在cmd命令行里或者Android Studio中的Terminal里敲入如下命令：adb shell dumpsys activity 然后会出现很长一段详细信息，滚到中间的地方，会看到Task栈的状态如下：","text":"我们都知道，每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。 如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一、查看task栈情况 在cmd命令行里或者Android Studio中的Terminal里敲入如下命令：adb shell dumpsys activity 然后会出现很长一段详细信息，滚到中间的地方，会看到Task栈的状态如下： 此外，这些信息的最底部还可以看到当前显示在前台的Activity是哪一个，还有使用设备的分辨率等信息","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"Java中的封装、继承与多态","slug":"Java中的封装、继承与多态","date":"2016-01-15T07:43:20.000Z","updated":"2016-10-18T04:57:38.022Z","comments":true,"path":"2016/01/15/Java中的封装、继承与多态/","link":"","permalink":"http://github.com/2016/01/15/Java中的封装、继承与多态/","excerpt":"这次我们来了解一下面向对象的三大基石封装，继承、多态，然后大致对比一下继承和多态的区别。 一、封装： 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。","text":"这次我们来了解一下面向对象的三大基石封装，继承、多态，然后大致对比一下继承和多态的区别。 一、封装： 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据（用域来实现）在程序中定义为公用的（public）我们将它们(fields)定义为私有的（privat）在很多方面会更好。 Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 下面用表格的形式来展示四种访问权限之间的异同点，这样会更加形象。注意其中protected和default的区别，表格如下所示： 权限修饰符 同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ 二、继承 通过继承可以实现代码的复用，使子类可以拥有父类的一些属性和方法。继承应该符合下列规则： 继承是可传递的。如果C从B中派生，B又从A中派生，那么C不仅继承了B中声明的成员，同样也继承了A中的成员。Object类作为所有类的基类。 派生类应当是对基类的扩展。派生类可以添加新的成员，但不能除去已经继承的成员的定义。构造函数和析构函数不能被继承。除此之外的其它成员，不论对它们定义了怎样的访问方式，都能被继承。基类中成员的访问方式只能决定派生类能否访问它们。 派生类如果定义了与继承而来的成员同名的新成员，就可以覆盖已继承的成员。但这并不因为这派生类删除了这些成员，只是不能再访问这些成员。 类可以定义为abstract抽象类，它的派生类就能够重载这些成员，从而实现类可以展示出多态性。 三、多态 多态就是指父类的某个方法被子类重写时，可以各自产生自己的功能行为。同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。 可以这么说：编译时看父类，运行时看子类。运行时的多态性就是指直到系统运行时，才根据实际情况决定实现何种操作。C#中，运行时的多态性通过虚成员实现。 父类A a = new 父类的子类B();a.方法();//这就是多态 实现多态的方式： 接口多态性。 继承多态性。 通过抽象类实现的多态性。 四、继承与多态的区别 网上看到一个有趣的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。 继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。可以这么说：编译时看父类，运行时看子类。 【参考资料】：1、java类的访问权限2、继承、封装、多态3、java中继承和多态区别.4、重载，继承，重写和多态的区别","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"Java访问权限修饰符的区别","slug":"Java访问权限修饰符的区别","date":"2016-01-15T07:07:20.000Z","updated":"2016-10-18T04:57:34.963Z","comments":true,"path":"2016/01/15/Java访问权限修饰符的区别/","link":"","permalink":"http://github.com/2016/01/15/Java访问权限修饰符的区别/","excerpt":"Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。","text":"Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 下面用表格的形式来展示四种访问权限之间的异同点，这样会更加形象。注意其中protected和default的区别，表格如下所示： 权限修饰符 同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ 【参考资料】：1、java类的访问权限","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？","slug":"【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？","date":"2016-01-05T07:31:00.000Z","updated":"2016-10-18T04:57:17.588Z","comments":true,"path":"2016/01/05/【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？/","link":"","permalink":"http://github.com/2016/01/05/【面试题】N级台阶（比如100级），每次可走1步或者2步，求总共有多少种走法？/","excerpt":"走台阶算法（本质上是斐波那契数列）在面试中常会遇到，描述就如题目那样：总共100级台阶（任意级都行），小明每次可选择走1步、2步或者3步，问走完这100级台阶总共有多少种走法？ 一、 题目分析这个问题本质上是斐波那契数列，假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。将上面的斐波那契数列代码稍微改一下就是本题的答案。我们来看一下代码的实现。 二、斐波那契数列法public class Test &#123; static final int s = 100; //自定义的台阶数 static int compute(int stair)&#123; if ( stair &lt;= 0)&#123; return 0; &#125; if (stair == 1)&#123; return 1; &#125; if (stair == 2)&#123; return 2; &#125; return compute(stair-1) + compute(stair-2); &#125; public static void main(String args[]) &#123; System.out.println(\"共有\" + compute(s) + \"种走法\"); &#125;&#125;","text":"走台阶算法（本质上是斐波那契数列）在面试中常会遇到，描述就如题目那样：总共100级台阶（任意级都行），小明每次可选择走1步、2步或者3步，问走完这100级台阶总共有多少种走法？ 一、 题目分析这个问题本质上是斐波那契数列，假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。将上面的斐波那契数列代码稍微改一下就是本题的答案。我们来看一下代码的实现。 二、斐波那契数列法public class Test &#123; static final int s = 100; //自定义的台阶数 static int compute(int stair)&#123; if ( stair &lt;= 0)&#123; return 0; &#125; if (stair == 1)&#123; return 1; &#125; if (stair == 2)&#123; return 2; &#125; return compute(stair-1) + compute(stair-2); &#125; public static void main(String args[]) &#123; System.out.println(\"共有\" + compute(s) + \"种走法\"); &#125;&#125; 三、 走台阶问题的简单解决算法但我自己对于这个题目最早的想法是使用树（多叉树）的方式，100为根节点，每次选择的分支有两种（1、2），然后生成深度为1的树，再从每个2级节点延伸出1、2两个分支，直到所有节点的值&lt;=0，最后统计出所有值为0的叶子节点的数目，就是结果。 不过自己想法实际上把问题复杂化了，下面这种使用递归方式实现的算法本质上和我的思想差不多，但是很明显下面这个算法会简单很多。接下来我们来看看这个算法的实现方式。 public class Test &#123; static final int s = 100; //自定义的台阶数 static int len = 0, sum = 0; //最多也只有走100步就到了 static int step[] = new int[s]; static void compute(final int stair) &#123; if (stair &lt; 0) return; //表示已经走完了 if (stair == 0) &#123; printSum(); sum++; return; &#125; //每次到下一步选择时都可以走1-2步 for (int i = 1; i &lt;= 2; i++) &#123; step[len] = i; len++; //进行下一步的迭代，迭代完之后将每后加上的一步去掉，换成其它的步数(如从1换成2) compute(stair - i); len--; &#125; &#125; static void printSum() &#123; System.out.print(\"走法:\"); for (int i = 0; i &lt; len; i++) System.out.print(step[i] + \" \"); System.out.println(); &#125; public static void main(String args[]) &#123; compute(s); System.out.println(\"共有\" + sum + \"种走法\"); &#125; &#125; 【参考资料】： 面试题9:斐波那契数列 - xwdreamer - 博客园 PHP上台阶问题（斐波纳契数列应用）","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"新主题酝酿中...","slug":"新主题酝酿中","date":"2016-01-04T07:08:00.000Z","updated":"2016-11-21T07:42:48.982Z","comments":true,"path":"2016/01/04/新主题酝酿中/","link":"","permalink":"http://github.com/2016/01/04/新主题酝酿中/","excerpt":"人们对于“美”，都有着超乎自己想象的执念。 图集 from Dribbble","text":"人们对于“美”，都有着超乎自己想象的执念。 图集 from Dribbble from Dribbble from Dribbble from Dribbble Website New York Times Akina theme 淡腾 louie iacool TA4.cn 波浪 EndSkin Wordpress主题 （报纸黑白）FASHIONISTA tagDiv &amp; （报纸）NEWSMAG 漂亮的蒙层","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}]},{"title":"好看的多说样式","slug":"好看的多说样式","date":"2016-01-03T07:08:00.000Z","updated":"2016-11-11T04:54:02.538Z","comments":true,"path":"2016/01/03/好看的多说样式/","link":"","permalink":"http://github.com/2016/01/03/好看的多说样式/","excerpt":"介于不想破坏主题评论框与整体的协调性，所以就把多说评论框的样式改成了跟主题自带评论一样的样子…下边是截图 多说样式 啊…简简单单就好，这个样式也是抄袭 jjlin 的，头像什么的都没有做动画 没意义我觉得","text":"介于不想破坏主题评论框与整体的协调性，所以就把多说评论框的样式改成了跟主题自带评论一样的样子…下边是截图 多说样式 啊…简简单单就好，这个样式也是抄袭 jjlin 的，头像什么的都没有做动画 没意义我觉得 下边是css代码 备份一下#ds-reset .ds-avatar img &#123;width:50px;height:auto ;border;border-radius: 50%;&#125;#ds-thread #ds-reset .ds-comment-body &#123;background:#f5f5f5;padding: 20px 20px;margin-left: 70px;border-radius: 4px;&#125;#ds-thread #ds-reset li.ds-post &#123;border-top: 0px dotted #ddd;&#125;#ds-thread #ds-reset ul.ds-children .ds-avatar img &#123;width: 40px;height: 40px;&#125;#ds-reset .ds-highlight &#123;color: #C76666 !important;&#125;#ds-thread #ds-reset .ds-comment-body, #ds-thread #ds-reset ul.ds-children .ds-comment-body &#123;padding-left: 20px;&#125;#ds-thread #ds-reset .ds-comment-header &#123;padding-top: 1px;padding-bottom: 10px;border-bottom: 1px dashed #ddd;&#125;a.ds-post-repost &#123;display:none&#125;#ds-thread #ds-reset .ds-comment-footer &#123;text-align: right;&#125;#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;#ds-thread #ds-reset .ds-comments, #ds-thread #ds-reset .ds-paginator &#123;border-bottom: 0px dotted #ddd;&#125;#ds-reset .ds-avatar &#123;background-color: #FDFDFD;&#125;#ds-thread #ds-reset li.ds-tab a.ds-current &#123;background-color: rgb(50, 69, 93);padding: 10px;color: white;text-shadow: none;border:none&#125;#ds-thread #ds-reset .ds-textarea-wrapper &#123;background: #F5F5F5 !important;height: 110px;border: 0px solid #ccc;&#125;#ds-thread #ds-reset .ds-post-options &#123;margin-right: 0;border: 1px solid #FBFBFB;&#125;#ds-thread #ds-reset .ds-post-options .ds-sync &#123;display:none&#125;#ds-thread #ds-reset .ds-post-button &#123; background:#FF5B5B ;width:100px&#125;#ds-thread #ds-reset .ds-post-button:hover &#123;background:#484848&#125;#ds-thread #ds-reset .ds-replybox &#123;padding: 0 0 0 60px;&#125;#ds-reset .ds-avatar &#123; box-shadow: none;&#125;#ds-thread #ds-reset .ds-replybox .ds-avatar img &#123;width: 40px;height: 40px;&#125;#ds-thread #ds-reset .ds-comment-body p &#123;margin: 1em 0;&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}],"tags":[],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://github.com/categories/Hexo/"}]},{"title":"【Java】内部类（Inner Class）如何创建（new）","slug":"【Java】内部类（Inner Class）如何创建（new）","date":"2016-01-02T13:13:20.000Z","updated":"2016-10-18T04:56:45.206Z","comments":true,"path":"2016/01/02/【Java】内部类（Inner Class）如何创建（new）/","link":"","permalink":"http://github.com/2016/01/02/【Java】内部类（Inner Class）如何创建（new）/","excerpt":"简单来说，内部类（inner class）指那些类定义代码被置于其它类定义中的类；而对于一般的、类定义代码不嵌套在其它类定义中的类，称为顶层（top-level）类。对于一个内部类，包含其定义代码的类称为它的外部（outer）类。 那么对于内部类，该如何去使用呢？ 下面给出静态成员类（Static Member Class）和普通成员类（Member Class）使用的方式。 package cuc;import cuc.TestClass.Inner1;public class Main &#123; public static void main(String args[]) &#123; //静态的内部类 TestClass.Inner1 inner1 = new Inner1(); //和普通的顶层类new的方法一样 inner1.report(); //普通内部成员类 TestClass tc = new TestClass(); TestClass.Inner2 inner2 = tc.new Inner2(); //注意这里的使用方式 inner2.report(); &#125;&#125;","text":"简单来说，内部类（inner class）指那些类定义代码被置于其它类定义中的类；而对于一般的、类定义代码不嵌套在其它类定义中的类，称为顶层（top-level）类。对于一个内部类，包含其定义代码的类称为它的外部（outer）类。 那么对于内部类，该如何去使用呢？ 下面给出静态成员类（Static Member Class）和普通成员类（Member Class）使用的方式。 package cuc;import cuc.TestClass.Inner1;public class Main &#123; public static void main(String args[]) &#123; //静态的内部类 TestClass.Inner1 inner1 = new Inner1(); //和普通的顶层类new的方法一样 inner1.report(); //普通内部成员类 TestClass tc = new TestClass(); TestClass.Inner2 inner2 = tc.new Inner2(); //注意这里的使用方式 inner2.report(); &#125;&#125; 两种内部类的定义如下： package cuc;public class TestClass &#123; //静态成员类 public static class Inner1&#123; public void report()&#123; System.out.println(\"This is a inner class. (NOT static)\"); &#125; &#125; //普通内部成员类 public class Inner2&#123; public void report()&#123; System.out.println(\"This is a static inner class.\"); &#125; &#125;&#125; 【参考资料】：1、java - 内部类(Inner Class)详解","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】 加解密算法 HMAC 的使用","slug":"【Android】 加解密算法 HMAC 的使用","date":"2015-12-31T07:30:00.000Z","updated":"2016-10-18T04:54:48.598Z","comments":true,"path":"2015/12/31/【Android】 加解密算法 HMAC 的使用/","link":"","permalink":"http://github.com/2015/12/31/【Android】 加解密算法 HMAC 的使用/","excerpt":"1、HMAC算法 &nbsp;&nbsp; HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 &nbsp;&nbsp;简而言之，HMAC就是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。关于hmac算法的详情可以参看RFC 2104(http://www.ietf.org/rfc/rfc2104.txt)，这里包含了HmacMD5算法的C语言实现。","text":"1、HMAC算法 &nbsp;&nbsp; HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 &nbsp;&nbsp;简而言之，HMAC就是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。关于hmac算法的详情可以参看RFC 2104(http://www.ietf.org/rfc/rfc2104.txt)，这里包含了HmacMD5算法的C语言实现。 2、代码实现（Android）//这是HMAC的Android代码//之所以不是Java是因为代码中的Base64使用的是android.util包下的Base64类，而不是Java自带的Base64类。public class HMACTest &#123; private static final String LOG_TAG = \"HMACTest\"; private static final String REGISTER_HMAC_KEY = \"12a9cc3f-1fd9-48a3-1fd9-1fd9d027ac2\"; private String stringToSign(String data) &#123; try &#123; Mac mac = Mac.getInstance(\"HmacSHA1\"); SecretKeySpec secret = new SecretKeySpec( REGISTER_HMAC_KEY.getBytes(\"UTF-8\"), mac.getAlgorithm()); mac.init(secret); return Base64.encodeToString(mac.doFinal(data.getBytes()), Base64.NO_WRAP); &#125; catch (NoSuchAlgorithmException e) &#123; Log.e(LOG_TAG, \"Hash algorithm SHA-1 is not supported\", e); &#125; catch (UnsupportedEncodingException e) &#123; Log.e(LOG_TAG, \"Encoding UTF-8 is not supported\", e); &#125; catch (InvalidKeyException e) &#123; Log.e(LOG_TAG, \"Invalid key\", e); &#125; return \"\"; &#125; /* * 测试函数 */ public static void test() &#123; HMACTest hmac = new HMACTest(); String str = \"Bello, Miss.Seven\"; System.out.println(\"加密前：\" + str); System.out.println(\"加密后：\" + hmac.stringToSign(str)); &#125;&#125; 【参考资料】：1、消息摘要算法-HMAC算法2、Java 加解密技术系列之 HMAC","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息","slug":"【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息","date":"2015-12-25T02:57:55.000Z","updated":"2016-10-18T04:54:56.856Z","comments":true,"path":"2015/12/25/【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息/","link":"","permalink":"http://github.com/2015/12/25/【Android】app打包成apk文件以后，如何查看VersionCode、VersionName等版本信息/","excerpt":"Android App打包成Apk后，其实是一个压缩文件，可以将后缀名apk改为zip然后用winrar打开也能看到里面的文件结构。还能看到AndroidManifest.xml。但是里面的内容经过编码显示为乱码，不方便查看。 — aapt工具： &nbsp;&nbsp;这里我们可以使用aapt工具来查看。aapt.exe工具即Android Asset Packaging Tool，在SDK的build-tools目录下。 &nbsp;&nbsp;该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE插件会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。","text":"Android App打包成Apk后，其实是一个压缩文件，可以将后缀名apk改为zip然后用winrar打开也能看到里面的文件结构。还能看到AndroidManifest.xml。但是里面的内容经过编码显示为乱码，不方便查看。 — aapt工具： &nbsp;&nbsp;这里我们可以使用aapt工具来查看。aapt.exe工具即Android Asset Packaging Tool，在SDK的build-tools目录下。 &nbsp;&nbsp;该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE插件会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。 &nbsp;&nbsp;也就是说平时我们不会用这个东西，但是打包成Apk的时候其实是用到了的，只不过IDE替我们做了这一步，那么我们就用这个工具来查看VersionCode和VersionName。 — 操作流程： 1、首先找到aapt工具，在Android SDK文件夹下的build-tools包里，如下： cd D:\\Android\\SDK\\build-tools\\23.0.0_rc3 2、然后使用aapt dump bading XXX.apk就能看到VersionCode等信息 aapt dump badging C:\\Users\\kuguan\\Desktop\\app-release_1.0.9.apk","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】不用循环语句如何输入打印数组元素","slug":"【Java】不用循环语句如何输入打印数组元素","date":"2015-12-09T05:58:20.000Z","updated":"2016-10-18T04:56:25.580Z","comments":true,"path":"2015/12/09/【Java】不用循环语句如何输入打印数组元素/","link":"","permalink":"http://github.com/2015/12/09/【Java】不用循环语句如何输入打印数组元素/","excerpt":"","text":"Java中可以使用Arrays.toString()来输出数组，免了使用各种循环来挨个print的痛苦。 package javacc.test;import java.util.Arrays; public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;0,1,4,7,2,5,8,3,6,9&#125;; System.out.println(Arrays.toString(array)); //注意这里的 Arrays.toString() &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】Activity与Fragment的生命周期的关系","slug":"【Android】Activity与Fragment的生命周期的关系","date":"2015-11-25T06:31:55.000Z","updated":"2016-11-28T08:18:13.210Z","comments":true,"path":"2015/11/25/【Android】Activity与Fragment的生命周期的关系/","link":"","permalink":"http://github.com/2015/11/25/【Android】Activity与Fragment的生命周期的关系/","excerpt":"一、问题描述： 假设有两个Activity（1和2）,每个Activity拥有一个Fragment，并分别有一个Button，点击Button1可以start Activity2，然后点击Button2可以finish掉自己（即Activity2）,然后返回到Activity1。根据这个简单模型描述一下Activity和Fragment的生命周期之间的依赖关系？","text":"一、问题描述： 假设有两个Activity（1和2）,每个Activity拥有一个Fragment，并分别有一个Button，点击Button1可以start Activity2，然后点击Button2可以finish掉自己（即Activity2）,然后返回到Activity1。根据这个简单模型描述一下Activity和Fragment的生命周期之间的依赖关系？ 二、生命周期知识Activity和Fragment的生命周期图谱可以参考我的另外一篇博客：【Android】Fragment的生命周期详解，他们的关系大致如下图： 三、代码验证 MainActivity和SecondActivity的布局是这样的，里面各添加了一个Fragment： /** * MainActivity布局xml文件 */&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;Button android:id=\"@+id/button\" android:text=\"开启第二个Activity\" android:layout_gravity=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt;&lt;/Button&gt; &lt;LinearLayout android:id=\"@+id/linearlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"#339999\"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; /** * MainActivity.java代码，SecondActivity的代码与之类似，这里就不贴那么多了 */public class MainActivity extends Activity &#123; private static final String LOG_TAG = \"MainActivity\"; private Button mButton; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.w(LOG_TAG, \"==============onCreate()\"); FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); FirstFragment firstFragment = new FirstFragment(); fragmentTransaction.add(R.id.linearlayout, firstFragment); fragmentTransaction.commit(); mButton = (Button) findViewById(R.id.button); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.w(LOG_TAG, \"------------------mButton onClick-------------------\"); startActivity(new Intent(MainActivity.this, SecondActivity.class)); &#125; &#125;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.w(LOG_TAG, \"==============onStart()\"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.w(LOG_TAG, \"==============onRestart()\"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.w(LOG_TAG, \"==============onResume()\"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.w(LOG_TAG, \"==============onPause()\"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.w(LOG_TAG, \"==============onStop()\"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.w(LOG_TAG, \"==============onDestroy()\"); &#125;&#125; /** * FirstFragment.java代码， SecondFragment和它差不多一样 */public class FirstFragment extends Fragment &#123; private static final String LOG_TAG = \"FirstFragment\"; private static final String ARG_PARAM1 = \"param1\"; private static final String ARG_PARAM2 = \"param2\"; private String mParam1; private String mParam2; public FirstFragment() &#123; &#125; @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); Log.w(LOG_TAG, \"onAttach...\"); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.w(LOG_TAG, \"onCreate...\"); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.w(LOG_TAG, \"onCreateView...\"); return inflater.inflate(R.layout.fragment_first, container, false); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.w(LOG_TAG, \"onActivityCreated...\"); &#125; @Override public void onStart() &#123; super.onStart(); Log.w(LOG_TAG, \"onStart...\"); &#125; @Override public void onResume() &#123; super.onResume(); Log.w(LOG_TAG, \"onResume...\"); &#125; @Override public void onPause() &#123; super.onPause(); Log.w(LOG_TAG, \"onPause...\"); &#125; @Override public void onStop() &#123; super.onStop(); Log.w(LOG_TAG, \"onStop...\"); &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); Log.w(LOG_TAG, \"onDestroyView...\"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(LOG_TAG, \"onDestroy...\"); &#125; @Override public void onDetach() &#123; super.onDetach(); Log.w(LOG_TAG, \"onDetach...\"); &#125;&#125; 四、运行结果1、第一次打开以后： com.example.kuguan.anlearning W/MainActivity﹕ ==============onCreate()com.example.kuguan.anlearning W/FirstFragment﹕ onAttach...com.example.kuguan.anlearning W/FirstFragment﹕ onCreate...com.example.kuguan.anlearning W/FirstFragment﹕ onCreateView...com.example.kuguan.anlearning W/FirstFragment﹕ onActivityCreated...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume... 2、点击MainActivity中的按钮“打开第二个Activity”以后： com.example.kuguan.anlearning W/MainActivity﹕ ----------------mButton onClick-----------------com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/SecondFragment﹕ onAttach...com.example.kuguan.anlearning W/SecondFragment﹕ onCreate...com.example.kuguan.anlearning W/SecondFragment﹕ onCreateView...com.example.kuguan.anlearning W/SecondFragment﹕ onActivityCreated...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onStart()com.example.kuguan.anlearning W/SecondFragment﹕ onStart...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onResume()com.example.kuguan.anlearning W/SecondFragment﹕ onResume...com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop() 3、点击SecondActivity的按钮“finish”之后： com.example.kuguan.anlearning W/SecondActivity﹕ -----------------mButton onClick------------------com.example.kuguan.anlearning W/SecondFragment﹕ onPause...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onPause()com.example.kuguan.anlearning W/MainActivity﹕ ==============onRestart()com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume...com.example.kuguan.anlearning W/SecondFragment﹕ onStop...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onStop()com.example.kuguan.anlearning W/SecondFragment﹕ onDestroyView...com.example.kuguan.anlearning W/SecondFragment﹕ onDestroy...com.example.kuguan.anlearning W/SecondFragment﹕ onDetach...com.example.kuguan.anlearning W/SecondActivity﹕ ==============onDestroy() 4、点击back键使MainActivity退到后台： com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop()com.example.kuguan.anlearning W/FirstFragment﹕ onDestroyView...com.example.kuguan.anlearning W/FirstFragment﹕ onDestroy...com.example.kuguan.anlearning W/FirstFragment﹕ onDetach...com.example.kuguan.anlearning W/MainActivity﹕ ==============onDestroy() 5、在MianActivity显示的时候，按HOME键： com.example.kuguan.anlearning W/FirstFragment﹕ onPause...com.example.kuguan.anlearning W/MainActivity﹕ ==============onPause()com.example.kuguan.anlearning W/FirstFragment﹕ onStop...com.example.kuguan.anlearning W/MainActivity﹕ ==============onStop() 6、然后再点击Icon打开： com.example.kuguan.anlearning W/MainActivity﹕ ==============onRestart()com.example.kuguan.anlearning W/MainActivity﹕ ==============onStart()com.example.kuguan.anlearning W/FirstFragment﹕ onStart...com.example.kuguan.anlearning W/MainActivity﹕ ==============onResume()com.example.kuguan.anlearning W/FirstFragment﹕ onResume... 【参考资料】：1、Fragment和Activity","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】Fragment的生命周期详解","slug":"【Android】Fragment的生命周期详解","date":"2015-11-25T03:43:55.000Z","updated":"2016-10-18T04:55:08.663Z","comments":true,"path":"2015/11/25/【Android】Fragment的生命周期详解/","link":"","permalink":"http://github.com/2015/11/25/【Android】Fragment的生命周期详解/","excerpt":"作为Android开发的基础知识，大家可能都了解Activity的生命周期，但是Fragment的生命周期和Activity生命周期之间的关系到底是怎么样的呢？相互调用机制又如何呢？ 一、我们首先观察一下Activity的生命周期：","text":"作为Android开发的基础知识，大家可能都了解Activity的生命周期，但是Fragment的生命周期和Activity生命周期之间的关系到底是怎么样的呢？相互调用机制又如何呢？ 一、我们首先观察一下Activity的生命周期： Fragment生命周期： Activity和Fragment生命周期的对比图：【参考资料】：1、Android Fragment源代码2、API Doc for fragments (Fragments | Android Developers)3、Fragment生命周期","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】长按连续触发事件的实现方法","slug":"【Android】长按连续触发事件的实现方法","date":"2015-11-19T06:35:55.000Z","updated":"2016-10-18T04:56:01.785Z","comments":true,"path":"2015/11/19/【Android】长按连续触发事件的实现方法/","link":"","permalink":"http://github.com/2015/11/19/【Android】长按连续触发事件的实现方法/","excerpt":"项目中需要实现一个类似购物车数量的小组件，需要单击时增加数量，长按时可以连续增大，之前的代码实现效果不理想，google后得到一个解决方法,测试可以完美实现。 实现效果大致如图： 【原理说明】 大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。","text":"项目中需要实现一个类似购物车数量的小组件，需要单击时增加数量，长按时可以连续增大，之前的代码实现效果不理想，google后得到一个解决方法,测试可以完美实现。 实现效果大致如图： 【原理说明】 大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。 【实现】 1、首先,让对应的View设置一个OnTouchListener，在手指按下时触发不停的发送消息,手指抬起时停止发送。 subtractButton.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; updateAddOrSubtract(v.getId()); //手指按下时触发不停的发送消息 &#125;else if(event.getAction() == MotionEvent.ACTION_UP)&#123; stopAddOrSubtract(); //手指抬起时停止发送 &#125; return true; &#125; &#125;); 2、发送消息与终止方法：先定义一个ScheduledExecutorService对象，然后调用scheduleWithFixedDelay()方法 private ScheduledExecutorService scheduledExecutor;private void updateAddOrSubtract(int viewId) &#123; final int vid = viewId; scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); scheduledExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.what = vid; handler.sendMessage(msg); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); //每间隔100ms发送Message &#125; private void stopAddOrSubtract() &#123; if (scheduledExecutor != null) &#123; scheduledExecutor.shutdownNow(); scheduledExecutor = null; &#125; &#125; 3、用来处理Touch事件的Handler定义如下：private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; int viewId = msg.what; switch (viewId)&#123; case R.id.custom_number_picker_subtract_button: setValue(value - rangeability); //减小操作 break; case R.id.custom_number_picker_add_button: setValue(value + rangeability); //增大操作 break; &#125; &#125; &#125;;","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】HashMap 和 HashTable 的区别到底是什么？","slug":"【Java】HashMap 和 HashTable 的区别到底是什么？","date":"2015-11-10T03:55:00.000Z","updated":"2016-10-18T04:56:18.669Z","comments":true,"path":"2015/11/10/【Java】HashMap 和 HashTable 的区别到底是什么？/","link":"","permalink":"http://github.com/2015/11/10/【Java】HashMap 和 HashTable 的区别到底是什么？/","excerpt":"第一、继承不同第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;...&#125;public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;...&#125; 而HashMap继承的抽象类AbstractMap实现了Map接口： public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;...&#125;","text":"第一、继承不同第一个不同主要是历史原因。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;...&#125;public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;...&#125; 而HashMap继承的抽象类AbstractMap实现了Map接口： public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;...&#125; 第二、线程安全不一样Hashtable 中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 //这是Hashtable的put()方法:/** * Associate the specified value with the specified key in this * &#123;@code Hashtable&#125;. If the key already exists, the old value is replaced. * The key and value cannot be null. * * @param key * the key to add. * @param value * the value to add. * @return the old value associated with the specified key, or &#123;@code null&#125; * if the key did not exist. * @see #elements * @see #get * @see #keys * @see java.lang.Object#equals */ public synchronized V put(K key, V value) &#123; if (key == null) &#123; throw new NullPointerException(\"key == null\"); &#125; else if (value == null) &#123; throw new NullPointerException(\"value == null\"); &#125; int hash = Collections.secondaryHash(key); HashtableEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashtableEntry&lt;K, V&gt; first = tab[index]; for (HashtableEntry&lt;K, V&gt; e = first; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; //这是HashMap的put()方法:/** * Maps the specified key to the specified value. * * @param key * the key. * @param value * the value. * @return the value of any previous mapping with the specified key or * &#123;@code null&#125; if there was no such mapping. */ @Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; 从上面的源代码可以看到Hashtable的put()方法是synchronized的，而HashMap的put()方法却不是。 第三、允不允许null值从上面的put()方法源码可以看到，Hashtable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。而在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 第四、遍历方式的内部实现上不同Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 第五、哈希值的使用不同HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 第六、内部实现方式的数组的初始大小和扩容的方式不一样HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 【总结】： HashMap 线程不安全 允许有null的键和值 效率高一点、 方法不是Synchronize的要提供外同步 有containsvalue和containsKey方法 HashMap 是Java1.2 引进的Map interface 的一个实现 HashMap是Hashtable的轻量级实现 Hashtable 线程安全 不允许有null的键和值 效率稍低、 方法是是Synchronize的 有contains方法方法 Hashtable 继承于Dictionary 类 Hashtable 比HashMap 要旧 【建议】： 一些资料建议，当需要同步时，用Hashtable，反之用HashMap。但是，因为在需要时，HashMap可以被同步，HashMap的功能比Hashtable的功能更多，而且它不是基于一个陈旧的类的，所以有人认为，在各种情况下，HashMap都优先于Hashtable。 【参考资料】： 1、Hashtable、HashMap源代码 2、Java的HashMap和HashTable 3、HashMap与HashTable的区别","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"各种排序算法时间复杂度和空间复杂度表","slug":"各种排序算法时间复杂度和空间复杂度表","date":"2015-11-03T03:55:00.000Z","updated":"2016-10-18T04:57:49.647Z","comments":true,"path":"2015/11/03/各种排序算法时间复杂度和空间复杂度表/","link":"","permalink":"http://github.com/2015/11/03/各种排序算法时间复杂度和空间复杂度表/","excerpt":"各种排序算法时间复杂度和空间复杂度表: 比较时间复杂度函数的情况如下图： 对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法： 接下来博主抽时间要整理一下各经典算法思想和心得，敬请期待","text":"各种排序算法时间复杂度和空间复杂度表: 比较时间复杂度函数的情况如下图： 对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法： 接下来博主抽时间要整理一下各经典算法思想和心得，敬请期待 一、快速排序（Quicksort）import java.util.Arrays;public class MySort &#123; public static void main(String args[])&#123; int[] array = &#123;5,3,9,1,6,4,10,2,8,7&#125;; System.out.println(&quot;Before: &quot; + Arrays.toString(array)); new MySort().quickSort(array, 0, array.length-1); System.out.println(&quot;After: &quot; + Arrays.toString(array)); &#125; /** * 快速排序： 递归实现的挖坑填数法 * @param array * @param left * @param right */ private void quickSort(int[] array, int left, int right)&#123; if(left &gt;= right)&#123; return; &#125; int i = left; int j = right; int key = array[left]; while(i&lt;j)&#123; while(array[j] &gt;= key &amp;&amp; i&lt;j)&#123; //从后向前搜索，比key小的值就挖出来填到i处的坑 j--; &#125; array[i] = array[j]; while(array[i] &lt;= key &amp;&amp; i&lt;j)&#123; //从前向后搜索，找出比key大的值填到刚才j处空缺的坑 i++; &#125; array[j] = array[i]; &#125; array[i] = key; //把key回填到数组的空缺处 System.out.println(&quot;Sort: &quot; + Arrays.toString(array)); quickSort(array, left, i-1); quickSort(array, i+1, right); &#125;&#125; 快速排序的测试代码输出结果如下：Before: [5, 3, 9, 1, 6, 4, 10, 2, 8, 7]Sort: [2, 3, 4, 1, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 4, 3, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 10, 9, 8, 7]Sort: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]Sort: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]Sort: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]After: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 【参考资料】： 白话经典算法系列之六 快速排序 快速搞定","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://github.com/categories/Algorithm/"}]},{"title":"【Java】函数中的参数传递是“引用传递”还是“值传递”？","slug":"【Java】函数中的参数传递是“引用传递”还是“值传递”？","date":"2015-11-02T07:33:20.000Z","updated":"2016-10-18T04:56:41.696Z","comments":true,"path":"2015/11/02/【Java】函数中的参数传递是“引用传递”还是“值传递”？/","link":"","permalink":"http://github.com/2015/11/02/【Java】函数中的参数传递是“引用传递”还是“值传递”？/","excerpt":"问题引入：在一个快速排序的函数 private void quickSort(List intList, int left, int right) 中，传进去的参数intList是对象传递还是引用传递呢？ 先抛出结论： 将对象（对象的引用）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的对象。 当将基本类型或基本类型的包装集作为参数传递时，传递的是值。也就是说函数内对参数所做的修改不会影响原来的变量。 数组(数组引用)）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的数组。 String类型(引用)作为参数传递时传递的是引用，只是对String做出任何修改时有一个新的String对象会产生，原来的String对象的值不会做任何修改。(但是可以将新的对象的 引用赋给原来的引用,这样给人的表面现象就是原来的对象变了，其实没有变，只是原来指向它的引用指向了新的对象)。","text":"问题引入：在一个快速排序的函数 private void quickSort(List intList, int left, int right) 中，传进去的参数intList是对象传递还是引用传递呢？ 先抛出结论： 将对象（对象的引用）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的对象。 当将基本类型或基本类型的包装集作为参数传递时，传递的是值。也就是说函数内对参数所做的修改不会影响原来的变量。 数组(数组引用)）作为参数传递时传递的是引用(相当于指针)。也就是说函数内对参数所做的修改会影响原来的数组。 String类型(引用)作为参数传递时传递的是引用，只是对String做出任何修改时有一个新的String对象会产生，原来的String对象的值不会做任何修改。(但是可以将新的对象的 引用赋给原来的引用,这样给人的表面现象就是原来的对象变了，其实没有变，只是原来指向它的引用指向了新的对象)。 举例一：public class Mainjava &#123; String str=new String(&quot;good&quot;); char[] ch=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;; Integer i = 0; int x = 0; Test t1 = new Test(); Test t2 = new Test(); public static void main(String args[])&#123; Mainjava ex=new Mainjava(); ex.change(ex.str,ex.ch, ex.x, ex.i, ex.t1, ex.t2); System.out.print(ex.str + &quot; and &quot;); System.out.print(String.valueOf(ex.ch) + &quot; and &quot;); System.out.print(ex.x + &quot;,&quot; + ex.i + &quot;,&quot; + ex.t1.getA() + &quot;,&quot; + ex.t2.getA()); &#125; public void change(String str, char ch[], int x, Integer i, Test t1, Test t2)&#123; str=&quot;test ok&quot;; ch[0]=&apos;g&apos;; x = 2; i = 5; Test newT = new Test(); newT.setA(99); t1 = newT; t2.setA(33); &#125;&#125;//Test类public class Test &#123; private int a = 0; public void setA(int a)&#123; this.a = a; &#125; public int getA()&#123; return a; &#125;&#125; 输出结果是多少呢？ good and gbc and 0,0,0,33 为什么不是”test ok and gbc and 2,5,99,33”呢？ 因为str是引用数据类型String,而字符数组是基本数据类型,二者存放在内存中的机制是不一样的!public void change(String str, char ch[], int x)&#123; str = &quot;test ok&quot;; ch[0] = &apos;g&apos;; x = 2;&#125; change()方法传入str,虽然把”test ok”强行赋给str,但是这里的str存放在新的栈内存中,和原来的str存放的地址不一样,所以你System.out.print(ex.str+”and”);这里的输出还是调用原来内存中的str;字符数组不一样,你声明一个字符数组之后,那个数组的位置就定死了,你调用change()之后,把原来的字符数组的第1个元素改为了g.这就是引用数据类型和基本数据类型的区别。 举例二： import java.util.ArrayList;import java.util.List;public class Mainjava &#123; public static void main(String args[])&#123; List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;(); integerList.add(7); integerList.add(1); integerList.add(3); integerList.add(8); integerList.add(9); integerList.add(2); integerList.add(5); integerList.add(4); integerList.add(10); integerList.add(6); print(integerList); quickSort(integerList, 0, integerList.size()-1); print(integerList); /*对比排序前后的integerList中的值，如果发生改变，说明是引用传递，即传递的是对象地址值*/ &#125; private static void quickSort(List&lt;Integer&gt; intList, int left, int right)&#123; if(left &gt;= right) &#123; return; &#125; int i = left; int j = right; int key = intList.get(i); System.out.println(&quot;key:&quot;+&quot;intList.get(&quot;+i+&quot;)=&quot;+key); while(i &lt; j)&#123; while(i &lt; j &amp;&amp; intList.get(j) &gt;= key)&#123; j--; &#125; intList.set(i, intList.get(j)); while(i &lt; j &amp;&amp; intList.get(i) &lt;= key)&#123; i++; &#125; intList.set(j, intList.get(i)); &#125; intList.set(i, key); quickSort(intList, left, i - 1); quickSort(intList, i + 1, right); &#125; private static void print(List&lt;Integer&gt; intList)&#123; for (int i = 0; i &lt; intList.size(); i++) &#123; System.out.print(intList.get(i)+&quot;, &quot;); &#125; System.out.println(&quot;&quot;); &#125;&#125; 运行输出结果如下： 7, 1, 3, 8, 9, 2, 5, 4, 10, 6,key:intList.get(0)=7key:intList.get(0)=6key:intList.get(0)=2key:intList.get(2)=3key:intList.get(3)=4key:intList.get(7)=91, 2, 3, 4, 5, 6, 7, 8, 9, 10, 结论： 实验证明，Java中函数传递对象时，传递的是该对象的地址值，即引用传递。函数传递基本类型数据时，传递的是值，也就是说函数返回之后不会改变这个值。","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]},{"title":"【Android】onActivityResult()和onResume()的调用顺序问题","slug":"【Android】onActivityResult()和onResume()的调用顺序问题","date":"2015-09-18T09:16:55.000Z","updated":"2016-10-18T04:55:17.484Z","comments":true,"path":"2015/09/18/【Android】onActivityResult()和onResume()的调用顺序问题/","link":"","permalink":"http://github.com/2015/09/18/【Android】onActivityResult()和onResume()的调用顺序问题/","excerpt":"在Android生命周期中，如果使用到startActivityForResult()，则在新Activity被finish掉之后，onActivityResult()和onResume()到底是哪一个先调用的呢？ 我们来看官方源码： /** * Called when an activity you launched exits, giving you the requestCode * you started it with, the resultCode it returned, and any additional * data from it. The &lt;var&gt;resultCode&lt;/var&gt; will be * {@link #RESULT_CANCELED} if the activity explicitly returned that, * didn't return any result, or crashed during its operation. * * &lt;p&gt;You will receive this call immediately before onResume() when your * activity is re-starting. * * &lt;p&gt;This method is never invoked if your activity sets * {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to * &lt;code&gt;true&lt;/code&gt;. * * @param requestCode The integer request code originally supplied to * startActivityForResult(), allowing you to identify who this * result came from. * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \"extras\"). * * @see #startActivityForResult * @see #createPendingResult * @see #setResult(int) */ protected void onActivityResult(int requestCode, int resultCode, Intent data) { }","text":"在Android生命周期中，如果使用到startActivityForResult()，则在新Activity被finish掉之后，onActivityResult()和onResume()到底是哪一个先调用的呢？ 我们来看官方源码： /** * Called when an activity you launched exits, giving you the requestCode * you started it with, the resultCode it returned, and any additional * data from it. The &lt;var&gt;resultCode&lt;/var&gt; will be * {@link #RESULT_CANCELED} if the activity explicitly returned that, * didn't return any result, or crashed during its operation. * * &lt;p&gt;You will receive this call immediately before onResume() when your * activity is re-starting. * * &lt;p&gt;This method is never invoked if your activity sets * {@link android.R.styleable#AndroidManifestActivity_noHistory noHistory} to * &lt;code&gt;true&lt;/code&gt;. * * @param requestCode The integer request code originally supplied to * startActivityForResult(), allowing you to identify who this * result came from. * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \"extras\"). * * @see #startActivityForResult * @see #createPendingResult * @see #setResult(int) */ protected void onActivityResult(int requestCode, int resultCode, Intent data) { } &#160; &#160; &#160; &#160;从上面的源码注释第二段可以看到：You will receive this call immediately before onResume() when your activity is re-starting. 所以很明显，在activity重新恢复启动的时候，onActivityResult()会在onResume()之前调用完毕。 &#160; &#160; &#160; &#160;而且，onActivityResult()还会在onStart()之前调用完毕。经过断点调试，发现它们三者的调用顺序如下： onActivityResult() -&gt; onStart() -&gt; onResume()","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】如何启动调用其他app中的Activity","slug":"【Android】如何启动调用其他app中的Activity","date":"2015-09-15T03:06:00.000Z","updated":"2016-10-18T04:55:55.045Z","comments":true,"path":"2015/09/15/【Android】如何启动调用其他app中的Activity/","link":"","permalink":"http://github.com/2015/09/15/【Android】如何启动调用其他app中的Activity/","excerpt":"最近项目正在将原系统拆分为小型App，所以需要在原Project中启动另一个新的App中的Activity。这样的话启动要用到ComponentName ，它就是用来打开其他应用程序中的Activity或服务的。 用法其实很简单，像下面这样： //第一个参数是Activity所在的package包名，第二个参数是完整的Class类名（包括包路径）ComponentName componetName = new ComponentName(\"com.cybo3d.cybox.miya\", \"com.cybo3d.cybox.miya.MainActivity\");Intent intent = new Intent();intent.setComponent(componetName);startActivity(intent);","text":"最近项目正在将原系统拆分为小型App，所以需要在原Project中启动另一个新的App中的Activity。这样的话启动要用到ComponentName ，它就是用来打开其他应用程序中的Activity或服务的。 用法其实很简单，像下面这样： //第一个参数是Activity所在的package包名，第二个参数是完整的Class类名（包括包路径）ComponentName componetName = new ComponentName(\"com.cybo3d.cybox.miya\", \"com.cybo3d.cybox.miya.MainActivity\");Intent intent = new Intent();intent.setComponent(componetName);startActivity(intent); 我们来看源码中ComponentName的参数信息，pkg和cls均不能为null。此处特别注意第二个参数cls必须为 完整的Class类名。 /** * Create a new component identifier. * * @param pkg The name of the package that the component exists in. Can * not be null. * @param cls The name of the class inside of &lt;var&gt;pkg&lt;/var&gt; that * implements the component. Can not be null. */ public ComponentName(String pkg, String cls) &#123; if (pkg == null) throw new NullPointerException(\"package name is null\"); if (cls == null) throw new NullPointerException(\"class name is null\"); mPackage = pkg; mClass = cls; &#125; 另外，在调用的时候一定要保证在Manifest.xml中设置被启动Activity的exported=true，否则会报错Activity is not found.","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Android】保存图片到系统图库, 并立即显示在图库中","slug":"【Android】保存图片到系统图库, 并立即显示在图库中","date":"2014-09-12T03:55:00.000Z","updated":"2016-10-18T04:55:26.176Z","comments":true,"path":"2014/09/12/【Android】保存图片到系统图库, 并立即显示在图库中/","link":"","permalink":"http://github.com/2014/09/12/【Android】保存图片到系统图库, 并立即显示在图库中/","excerpt":"搬运原链接：http://stormzhang.github.io/android/2014/07/24/android-save-image-to-gallery 正文最近有些用户反映保存图片之后在系统图库找不到保存的图片，遂决定彻底查看并解决下。 Android中保存图片的方法可能有如下两种： 第一种是自己写方法，如下代码： public static File saveImage(Bitmap bmp) &#123; File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","text":"搬运原链接：http://stormzhang.github.io/android/2014/07/24/android-save-image-to-gallery 正文最近有些用户反映保存图片之后在系统图库找不到保存的图片，遂决定彻底查看并解决下。 Android中保存图片的方法可能有如下两种： 第一种是自己写方法，如下代码： public static File saveImage(Bitmap bmp) &#123; File appDir = new File(Environment.getExternalStorageDirectory(), \"Boohee\"); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + \".jpg\"; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 以上代码便是将Bitmap保存图片到指定的路径/sdcard/Boohee/下，文件名以当前系统时间命名,但是这种方法保存的图片没有加入到系统图库中 第二种是调用系统提供的插入图库的方法： MediaStore.Images.Media.insertImage(getContentResolver(), bitmap, \"title\", \"description\"); 调用以上系统自带的方法会把bitmap对象保存到系统图库中，但是这种方法无法指定保存的路径和名称，上述方法的title、description参数只是插入数据库中的字段，真实的图片名称系统会自动分配。 看似上述第二种方法就是我们要用到的方法，但是可惜的调用上述第二种插入图库的方法图片并没有立刻显示在图库中，而我们需要立刻更新系统图库以便让用户可以立刻查看到这张图片。 更新系统图库的方法sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(\"file://\"+ Environment.getExternalStorageDirectory()))); 上面那条广播是扫描整个sd卡的广播，如果你sd卡里面东西很多会扫描很久，在扫描当中我们是不能访问sd卡，所以这样子用户体现很不好，所以下面我们还有如下的方法： sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(\"/sdcard/Boohee/image.jpg\")));); 或者还有如下方法： final MediaScannerConnection msc = new MediaScannerConnection(mContext, new MediaScannerConnectionClient() &#123; public void onMediaScannerConnected() &#123; msc.scanFile(\"/sdcard/Boohee/image.jpg\", \"image/jpeg\"); &#125; public void onScanCompleted(String path, Uri uri) &#123; Log.v(TAG, \"scan completed\"); msc.disconnect(); &#125; &#125;); 上面代码的图片路径不管是通过自己写方法还是系统插入图库的方法都可以很容易的获取到。 终极完美解决方案那么到这里可能有人又会问了，如果我想把图片保存到指定的文件夹，同时又需要图片出现在图库里呢？答案是可以的，sdk还提供了这样一个方法: MediaStore.Images.Media.insertImage(getContentResolver(), \"image path\", \"title\", \"description\"); 上述方法的第二个参数是image path，这样的话就有思路了，首先自己写方法把图片指定到指定的文件夹，然后调用上述方法把刚保存的图片路径传入进去，最后通知图库更新。 所以写了一个方法，完整的代码如下： public static void saveImageToGallery(Context context, Bitmap bmp) &#123; // 首先保存图片 File appDir = new File(Environment.getExternalStorageDirectory(), &quot;Boohee&quot;); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; String fileName = System.currentTimeMillis() + &quot;.jpg&quot;; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); bmp.compress(CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 其次把文件插入到系统图库 try &#123; MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), fileName, null); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; // 最后通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot; + path)));&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"如何删除多行首字母，Sublime Text多行编辑运用","slug":"如何删除多行首字母，Sublime Text多行编辑运用","date":"2014-05-15T03:55:00.000Z","updated":"2016-10-18T04:58:04.697Z","comments":true,"path":"2014/05/15/如何删除多行首字母，Sublime Text多行编辑运用/","link":"","permalink":"http://github.com/2014/05/15/如何删除多行首字母，Sublime Text多行编辑运用/","excerpt":"一、问题描述：问答区有个问题是这样问的：如何在eclipse中删除多行首字母？ 题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？我们在进行代码重用的时候时常会出现行号同时被复制的情况，比如下面的这点代码： 155. @Override 156. public boolean onKeyDown(int keyCode, KeyEvent event) 157. &#123; 158. Log.d(\"onKeyDown:\", \" keyCode=\" + keyCode + \" KeyEvent=\" + event); 159. switch (keyCode) 160. &#123; 161. case KeyEvent.KEYCODE_DPAD_UP: 162. 163. break; 164. case KeyEvent.KEYCODE_DPAD_DOWN: 165. 166. break; 167. case KeyEvent.KEYCODE_DPAD_LEFT: 168. //右左按键可以控制第一进度的增减 169. pb.setProgress( pb.getProgress()-5 ); 170. break; 171. case KeyEvent.KEYCODE_DPAD_RIGHT: 172. pb.setProgress( pb.getProgress()+5 ); 173. break; 174. case KeyEvent.KEYCODE_DPAD_CENTER: 175. 176. break; 177. case KeyEvent.KEYCODE_0: 178. break; 179. &#125; 180. return super.onKeyDown(keyCode, event); 181. &#125; 182. &#125;","text":"一、问题描述：问答区有个问题是这样问的：如何在eclipse中删除多行首字母？ 题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？我们在进行代码重用的时候时常会出现行号同时被复制的情况，比如下面的这点代码： 155. @Override 156. public boolean onKeyDown(int keyCode, KeyEvent event) 157. &#123; 158. Log.d(\"onKeyDown:\", \" keyCode=\" + keyCode + \" KeyEvent=\" + event); 159. switch (keyCode) 160. &#123; 161. case KeyEvent.KEYCODE_DPAD_UP: 162. 163. break; 164. case KeyEvent.KEYCODE_DPAD_DOWN: 165. 166. break; 167. case KeyEvent.KEYCODE_DPAD_LEFT: 168. //右左按键可以控制第一进度的增减 169. pb.setProgress( pb.getProgress()-5 ); 170. break; 171. case KeyEvent.KEYCODE_DPAD_RIGHT: 172. pb.setProgress( pb.getProgress()+5 ); 173. break; 174. case KeyEvent.KEYCODE_DPAD_CENTER: 175. 176. break; 177. case KeyEvent.KEYCODE_0: 178. break; 179. &#125; 180. return super.onKeyDown(keyCode, event); 181. &#125; 182. &#125; 这是博主从别处摘来的代码粘贴在Eclipse中的，很明显行号也被复制了进来。 对于这样的问题，如果代码行数真的多到可以用来数绵羊了，还用Delete键一行一行地解决可真就轻而易举地抑郁了哭 #其实我有特别的患抑郁症技巧# 二、解决办法：解决办法就是利用Sublime Text的多行编辑功能删除掉行首的序号。在Sublime Text中打开或者粘贴你想清理的代码，然后选中所有行 选中需要清理的所有行 按下Ctrl + Shift + L（Command + Shift + L）——— 可以同时编辑这些行 用左右方向键把光标移动到行首，然后按下 Delete键 或者 Backspace退格键 来删除行号。","categories":[],"tags":[],"keywords":[]},{"title":"Ubuntu上Eclipse识别不了Android手机的解决方法","slug":"Ubuntu上Eclipse识别不了Android手机的解决方法","date":"2013-10-20T08:46:00.000Z","updated":"2016-10-18T04:57:41.236Z","comments":true,"path":"2013/10/20/Ubuntu上Eclipse识别不了Android手机的解决方法/","link":"","permalink":"http://github.com/2013/10/20/Ubuntu上Eclipse识别不了Android手机的解决方法/","excerpt":"转载链接： http://www.cnblogs.com/AndroidManifest/archive/2011/12/09/2281635.html google官方开发向导里对Android手机已经设置了允许安装非market程序，并且处于usb调试模式，但是仍然在usb连接电脑后无法被识别的问题作了解释。官方网址：http://developer.android.com/guide/developing/device.html 操作步骤：如果是windows平台下，需要安装一个为adb准备的usb驱动。如果是Ubuntu Linux需要添加一个rules文件，里面包含了每一个想要调试的设备的usb配置信息。以HTC手机为例实现步骤如下： 1、在终端输入 : sudo gedit /etc/udev/rules.d/51-android.rules","text":"转载链接： http://www.cnblogs.com/AndroidManifest/archive/2011/12/09/2281635.html google官方开发向导里对Android手机已经设置了允许安装非market程序，并且处于usb调试模式，但是仍然在usb连接电脑后无法被识别的问题作了解释。官方网址：http://developer.android.com/guide/developing/device.html 操作步骤：如果是windows平台下，需要安装一个为adb准备的usb驱动。如果是Ubuntu Linux需要添加一个rules文件，里面包含了每一个想要调试的设备的usb配置信息。以HTC手机为例实现步骤如下： 1、在终端输入 : sudo gedit /etc/udev/rules.d/51-android.rules 2、在打开的文件里加入 SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0bb4&quot;, MODE=&quot;0666&quot; 3、保存退出后在终端执行 : sudo chmod a+r /etc/udev/rules.d/51-android.rules 重新将手机连接到电脑后HTC手机就可以被正常识别了。注意：如果按步骤操作仍不能识别的，检查 ATTR{idVendor} 值里的字母是否是小写。 如果是别的厂家的手机，需要在步骤2更改ATTR{idVendor}的值。如果要添加多个厂家的手机，重复步骤2。其他usb供应商的ID如下： Company USB Vendor ID Acer 0502 ASUS 0B05 Dell 413C Foxconn 0489 Garmin-Asus 091E Google 18D1 HTC 0BB4 Huawei 12D1 K-Touch 24E3 KT Tech 2116 Kyocera 0482 Lenevo 17EF LG 1004 Motorola 22B8 NEC 0409 Nook 2080 Nvidia 0955 OTGV 2257 Pantech 10A9 Pegatron 1D4D Philips 0471 PMC-Sierra 04DA Qualcomm 05C6 SK Telesys 1F53 Samsung 04E8 Sharp 04DD Sony Ericsson 0FCE Toshiba 0930 ZTE 19D2 注意：如果按步骤操作仍不能识别的，检查 ATTR{idVendor} 值里的字母是否是小写。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.com/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://github.com/categories/Android/"}]},{"title":"【Java】操作excel表，包括创建、读取、以及修改","slug":"【Java】操作excel表，包括创建、读取、以及修改","date":"2013-08-01T04:31:20.000Z","updated":"2016-10-18T04:56:35.699Z","comments":true,"path":"2013/08/01/【Java】操作excel表，包括创建、读取、以及修改/","link":"","permalink":"http://github.com/2013/08/01/【Java】操作excel表，包括创建、读取、以及修改/","excerpt":"作者的网站上对它的特征有如下描述： 支持Excel 95-2000的所有版本 生成Excel 2000标准格式 支持字体、数字、日期操作 能够修饰单元格属性 支持图像和图表 应该说以上功能已经能够大致满足我们的需要。最关键的是这套API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 搭建环境下载jxl.jar（可以点击这里进行下载），放入classpath，安装就完成了。","text":"作者的网站上对它的特征有如下描述： 支持Excel 95-2000的所有版本 生成Excel 2000标准格式 支持字体、数字、日期操作 能够修饰单元格属性 支持图像和图表 应该说以上功能已经能够大致满足我们的需要。最关键的是这套API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 搭建环境下载jxl.jar（可以点击这里进行下载），放入classpath，安装就完成了。 基本操作一、创建文件拟生成一个名为“测试数据.xls”的Excel文件，其中第一个工作表被命名为“第一页”。代码（CreateXLS.java）： //生成Excel的类 import java.io. * ;import jxl. * ;import jxl.write. * ;public class CreateXLS &#123; public static void main(String args[]) &#123; try &#123; //打开文件 WritableWorkbook book = Workbook.createWorkbook(new File(“测试.xls”)); //生成名为“第一页”的工作表，参数0表示这是第一页 WritableSheet sheet = book.createSheet(“第一页”, 0); //在Label对象的构造子中指名单元格位置是第一列第一行(0,0) //以及单元格内容为test Label label = new Label(0, 0, ”test”); //将定义好的单元格添加到工作表中 sheet.addCell(label); /*生成一个保存数字的单元格, 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123*/ jxl.write.Number number = new jxl.write.Number(1, 0, 789.123); sheet.addCell(number); //写入数据并关闭文件 book.write(); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 编译执行后，会在当前位置产生一个Excel文件。 二、读取文件以刚才我们创建的Excel文件为例，做一个简单的读取操作，程序代码如下： //读取Excel的类 import java.io. * ;import jxl. * ;public class ReadXLS &#123; public static void main(String args[]) &#123; try &#123; Workbook book = Workbook.getWorkbook(new File(“测试.xls”)); //获得第一个工作表对象 Sheet sheet = book.getSheet(0); //得到第一列第一行的单元格 Cell cell1 = sheet.getCell(0, 0); String result = cell1.getContents(); System.out.println(result); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 三、修改文件利用jExcelAPI可以修改已有的Excel文件，修改Excel文件的时候，除了打开文件的方式不同之外，其他操作和创建Excel是一样的。下面的例子是在我们已经生成的Excel文件中添加一个工作表： //修改Excel的类，添加一个工作表 import java.io.*;import jxl.*;import jxl.write.*;public class UpdateXLS &#123; public static void main(String args[]) &#123; try &#123; //Excel获得文件 Workbook wb = Workbook.getWorkbook(new File(“测试.xls”)); //打开一个文件的副本，并且指定数据写回到原文件 WritableWorkbook book = Workbook.createWorkbook(new File(“测试.xls”), wb); //添加一个工作表 WritableSheet sheet = book.createSheet(“第二页”, 1); sheet.addCell(new Label(0, 0, ”第二页的测试数据”)); book.write(); book.close(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 高级操作一、 数据格式化在Excel中不涉及复杂的数据类型，能够比较好的处理字串、数字和日期已经能够满足一般的应用。 1、 字串格式化字符串的格式化涉及到的是字体、粗细、字号等元素，这些功能主要由WritableFont和WritableCellFormat类来负责。假设我们在生成一个含有字串的单元格时，使用如下语句，为方便叙述，我们为每一行命令加了编号： WritableFont font1=new WritableFont(WritableFont.TIMES,16,WritableFont.BOLD); 或//设置字体格式为excel支持的格式 WritableFont font3=new WritableFont(WritableFont.createFont(“楷体 _GB2312”),12,WritableFont.NO_BOLD );① WritableCellFormat format1=new WritableCellFormat(font1); ② Label label=new Label(0,0,”data 4 test”,format1) ③ 其中①指定了字串格式：字体为TIMES，字号16，加粗显示。WritableFont有非常丰富的构造子，供不同情况下使用，jExcelAPI的 java-doc中有详细列表，这里不再列出。 ②处代码使用了WritableCellFormat类，这个类非常重要，通过它可以指定单元格的各种属性，后面的单元格格式化中会有更多描述。 ③处使用了Label类的构造子，指定了字串被赋予那种格式。 在WritableCellFormat类中，还有一个很重要的方法是指定数据的对齐方式，比如针对我们上面的实例，可以指定： //把水平对齐方式指定为居中 format1.setAlignment(jxl.format.Alignment.CENTRE); //把垂直对齐方式指定为居中 format1.setVerticalAlignment(jxl.format.VerticalAlignment.CENTRE);//设置自动换行format1.setWrap(true); 二、单元格操作Excel中很重要的一部分是对单元格的操作，比如行高、列宽、单元格合并等，所幸jExcelAPI提供了这些支持。这些操作相对比较简单，下面只介绍一下相关的API。 1、 合并单元格 WritableSheet.mergeCells(int m,int n,int p,int q);作用是从(m,n)到(p,q)的单元格全部合并，比如： WritableSheet sheet=book.createSheet(“第一页”,0); //合并第一列第一行到第六列第一行的所有单元格 sheet.mergeCells(0,0,5,0); 合并既可以是横向的，也可以是纵向的。合并后的单元格不能再次进行合并，否则会触发异常。 2、 行高和列宽 WritableSheet.setRowView(int i,int height);作用是指定第i+1行的高度，比如： //将第一行的高度设为200 sheet.setRowView(0,200); WritableSheet.setColumnView(int i,int width);作用是指定第i+1列的宽度，比如： //将第一列的宽度设为30 sheet.setColumnView(0,30); 三、操作图片public static void write() throws Exception &#123; WritableWorkbook wwb = Workbook.createWorkbook(new File(\"c:/1.xls\")); WritableSheet ws = wwb.createSheet(\"Test Sheet 1\", 0); File file = new File(\"C:\\\\jbproject\\\\PVS\\\\WebRoot\\\\weekhit\\\\1109496996281.png\"); WritableImage image = new WritableImage(1, 4, 6, 18, file); ws.addImage(image); wwb.write(); wwb.close();&#125; 很简单和插入单元格的方式一样，不过就是参数多了些，WritableImage这个类继承了Draw，上面只是他构造方法的一种，最后一个参数不用了说 了，前面四个参数的类型都是double，依次是 x, y, width, height,注意，这里的宽和高可不是图片的宽和高，而是图片所要占的单位格的个数，因为继承的Draw所以他的类型必须是double，具体里面怎么 实现的我还没细看：）因为着急赶活，先完成功能，其他的以后有时间慢慢研究。以后会继续写出在使用中的心得给大家。 总结1、读 读的时候是这样的一个思路,先用一个输入流(InputStream)得到Excel文件,然后用jxl中的Workbook得到工作薄,用Sheet从工作薄中得到工作表,用Cell得到工作表中得某个单元格.InputStream-&gt;Workbook-&gt;Sheet-&gt;Cell,就得到了excel文件中的单元格 String path = \"c:\\\\excel.xls\"; //Excel文件URLInputStream is = new FileInputStream(path); //写入到FileInputStreamjxl.Workbook wb = Workbook.getWorkbook(is); //得到工作薄 jxl.Sheet st = wb.getSheet(0); //得到工作薄中的第一个工作表Cell cell = st.getCell(0, 0); //得到工作表的第一个单元格,即A1String content = cell.getContents(); //getContents()将Cell中的字符转为字符串wb.close(); //关闭工作薄is.close(); //关闭输入流 我们可以通过Sheet的getCell(x,y)方法得到任意一个单元格,x,y和excel中的坐标对应.例如A1对应(0,0),A2对应(0,1),D3对应(3,2).Excel中坐标从A,1开始,jxl中全部是从0开始.还可以通过Sheet的getRows(),getColumns()方法得到行数列数,并用于循环控制,输出一个sheet中的所有内容. 2、写 往Excel中写入内容主要是用jxl.write包中的类.思路是这样的:OutputStream&lt;-WritableWorkbook&lt;-WritableSheet&lt;-Label这里面Label代表的是写入Sheet的Cell位置及内容. OutputStream os = new FileOutputStream(\"c:\\\\test.xls\"); WritableWorkbook wwb = Workbook.createWorkbook(os); WritableSheet ws = wwb.createSheet(\"sheet1\", 0); //创建可写工作表Label labelCF = new Label(0, 0, \"hello\"); //创建写入位置和内容ws.addCell(labelCF); //将Label写入sheet中//Label的构造函数Label(int x, int y,String aString)xy意同读的时候的xy,aString是写入的内容.WritableFont wf = new WritableFont(WritableFont.TIMES, 12, WritableFont.BOLD, false); //设置写入字体WritableCellFormat wcfF = new WritableCellFormat(wf); //设置CellFormatLabel labelCF = new Label(0, 0, \"hello\"); //创建写入位置,内容和格式//Label的另一构造函数Label(int c, int r, String cont, CellFormat st)可以对写入内容进行格式化,设置字体及其它的属性. wwb.write();wwb.close();os.close; OK,只要把读和写结合起来,就可以在N个Excel中读取数据写入你希望的Excel新表中,还是比较方便的. 下面是程序代码: sql = \"select * from tablename\";rs = stmt.executeQuery(sql);//新建Excel文件String filePath = request.getRealPath(\"aaa.xls\");File myFilePath = new File(filePath);if (!myFilePath.exists()) myFilePath.createNewFile();FileWriter resultFile = new FileWriter(myFilePath);PrintWriter myFile = new PrintWriter(resultFile);resultFile.close();//用JXL向新建的文件中添加内容OutputStream outf = new FileOutputStream(filePath);jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(outf);jxl.write.WritableSheet ws = wwb.createSheet(\"sheettest\", 0);int i = 0;int j = 0;for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123; ws.addCell(new Label(k, 0, rs.getMetaData().getColumnName(k + 1)));&#125;while (rs.next()) &#123; out.println(rs.getMetaData().getColumnCount()); for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123; ws.addCell(new Label(k, j + i + 1, rs.getString(k + 1))); &#125; i++;&#125;wwb.write();wwb.close();&#125; catch(Exception e) &#123; e.printStackTrace();&#125; finally &#123; rs.close(); conn.close();&#125;response.sendRedirect(\"aaa.xls\");","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://github.com/categories/Java/"}]}]}